length = 4
	};
	int err = 0;
	u32 tmp = tx_power;

	if (tx_power != IPW_TX_POWER_DEFAULT)
		tmp = (tx_power - IPW_TX_POWER_MIN_DBM) * 16 /
		      (IPW_TX_POWER_MAX_DBM - IPW_TX_POWER_MIN_DBM);

	cmd.host_command_parameters[0] = tmp;

	if (priv->ieee->iw_mode == IW_MODE_ADHOC)
		err = ipw2100_hw_send_command(priv, &cmd);
	if (!err)
		priv->tx_power = tx_power;

	return 0;
}

static int ipw2100_set_ibss_beacon_interval(struct ipw2100_priv *priv,
					    u32 interval, int batch_mode)
{
	struct host_command cmd = {
		.host_command = BEACON_INTERVAL,
		.host_command_sequence = 0,
		.host_command_length = 4
	};
	int err;

	cmd.host_command_parameters[0] = interval;

	IPW_DEBUG_INFO("enter\n");

	if (priv->ieee->iw_mode == IW_MODE_ADHOC) {
		if (!batch_mode) {
			err = ipw2100_disable_adapter(priv);
			if (err)
				return err;
		}

		ipw2100_hw_send_command(priv, &cmd);

		if (!batch_mode) {
			err = ipw2100_enable_adapter(priv);
			if (err)
				return err;
		}
	}

	IPW_DEBUG_INFO("exit\n");

	return 0;
}

static void ipw2100_queues_initialize(struct ipw2100_priv *priv)
{
	ipw2100_tx_initialize(priv);
	ipw2100_rx_initialize(priv);
	ipw2100_msg_initialize(priv);
}

static void ipw2100_queues_free(struct ipw2100_priv *priv)
{
	ipw2100_tx_free(priv);
	ipw2100_rx_free(priv);
	ipw2100_msg_free(priv);
}

static int ipw2100_queues_allocate(struct ipw2100_priv *priv)
{
	if (ipw2100_tx_allocate(priv) ||
	    ipw2100_rx_allocate(priv) || ipw2100_msg_allocate(priv))
		goto fail;

	return 0;

      fail:
	ipw2100_tx_free(priv);
	ipw2100_rx_free(priv);
	ipw2100_msg_free(priv);
	return -ENOMEM;
}

#define IPW_PRIVACY_CAPABLE 0x0008

static int ipw2100_set_wep_flags(struct ipw2100_priv *priv, u32 flags,
				 int batch_mode)
{
	struct host_command cmd = {
		.host_command = WEP_FLAGS,
		.host_command_sequence = 0,
		.host_command_length = 4
	};
	int err;

	cmd.host_command_parameters[0] = flags;

	IPW_DEBUG_HC("WEP_FLAGS: flags = 0x%08X\n", flags);

	if (!batch_mode) {
		err = ipw2100_disable_adapter(priv);
		if (err) {
			printk(KERN_ERR DRV_NAME
			       ": %s: Could not disable adapter %d\n",
			       priv->net_dev->name, err);
			return err;
		}
	}

	/* send cmd to firmware */
	err = ipw2100_hw_send_command(priv, &cmd);

	if (!batch_mode)
		ipw2100_enable_adapter(priv);

	return err;
}

struct ipw2100_wep_key {
	u8 idx;
	u8 len;
	u8 key[13];
};

/* Macros to ease up priting WEP keys */
#define WEP_FMT_64  "%02X%02X%02X%02X-%02X"
#define WEP_FMT_128 "%02X%02X%02X%02X-%02X%02X%02X%02X-%02X%02X%02X"
#define WEP_STR_64(x) x[0],x[1],x[2],x[3],x[4]
#define WEP_STR_128(x) x[0],x[1],x[2],x[3],x[4],x[5],x[6],x[7],x[8],x[9],x[10]

/**
 * Set a the wep key
 *
 * @priv: struct to work on
 * @idx: index of the key we want to set
 * @key: ptr to the key data to set
 * @len: length of the buffer at @key
 * @batch_mode: FIXME perform the operation in batch mode, not
 *              disabling the device.
 *
 * @returns 0 if OK, < 0 errno code on error.
 *
 * Fill out a command structure with the new wep key, length an
 * index and send it down the wire.
 */
static int ipw2100_set_key(struct ipw2100_priv *priv,
			   int idx, char *key, int len, int batch_mode)
{
	int keylen = len ? (len <= 5 ? 5 : 13) : 0;
	struct host_command cmd = {
		.host_command = WEP_KEY_INFO,
		.host_command_sequence = 0,
		.host_command_length = sizeof(struct ipw2100_wep_key),
	};
	struct ipw2100_wep_key *wep_key = (void *)cmd.host_command_parameters;
	int err;

	IPW_DEBUG_HC("WEP_KEY_INFO: index = %d, len = %d/%d\n",
		     idx, keylen, len);

	/* NOTE: We don't check cached values in case the firmware was reset
	 * or some other problem is occurring.  If the user is setting the key,
	 * then we push the change */

	wep_key->idx = idx;
	wep_key->len = keylen;

	if (keylen) {
		memcpy(wep_key->key, key, len);
		memset(wep_key->key + len, 0, keylen - len);
	}

	/* Will be optimized out on debug not being configured in */
	if (keylen == 0)
		IPW_DEBUG_WEP("%s: Clearing key %d\n",
			      priv->net_dev->name, wep_key->idx);
	else if (keylen == 5)
		IPW_DEBUG_WEP("%s: idx: %d, len: %d key: " WEP_FMT_64 "\n",
			      priv->net_dev->name, wep_key->idx, wep_key->len,
			      WEP_STR_64(wep_key->key));
	else
		IPW_DEBUG_WEP("%s: idx: %d, len: %d key: " WEP_FMT_128
			      "\n",
			      priv->net_dev->name, wep_key->idx, wep_key->len,
			      WEP_STR_128(wep_key->key));

	if (!batch_mode) {
		err = ipw2100_disable_adapter(priv);
		/* FIXME: IPG: shouldn't this prink be in _disable_adapter()? */
		if (err) {
			printk(KERN_ERR DRV_NAME
			       ": %s: Could not disable adapter %d\n",
			       priv->net_dev->name, err);
			return err;
		}
	}

	/* send cmd to firmware */
	err = ipw2100_hw_send_command(priv, &cmd);

	if (!batch_mode) {
		int err2 = ipw2100_enable_adapter(priv);
		if (err == 0)
			err = err2;
	}
	return err;
}

static int ipw2100_set_key_index(struct ipw2100_priv *priv,
				 int idx, int batch_mode)
{
	struct host_command cmd = {
		.host_command = WEP_KEY_INDEX,
		.host_command_sequence = 0,
		.host_command_length = 4,
		.host_command_parameters = {idx},
	};
	int err;

	IPW_DEBUG_HC("WEP_KEY_INDEX: index = %d\n", idx);

	if (idx < 0 || idx > 3)
		return -EINVAL;

	if (!batch_mode) {
		err = ipw2100_disable_adapter(priv);
		if (err) {
			printk(KERN_ERR DRV_NAME
			       ": %s: Could not disable adapter %d\n",
			       priv->net_dev->name, err);
			return err;
		}
	}

	/* send cmd to firmware */
	err = ipw2100_hw_send_command(priv, &cmd);

	if (!batch_mode)
		ipw2100_enable_adapter(priv);

	return err;
}

static int ipw2100_configure_security(struct ipw2100_priv *priv, int batch_mode)
{
	int i, err, auth_mode, sec_level, use_group;

	if (!(priv->status & STATUS_RUNNING))
		return 0;

	if (!batch_mode) {
		err = ipw2100_disable_adapter(priv);
		if (err)
			return err;
	}

	if (!priv->ieee->sec.enabled) {
		err =
		    ipw2100_set_security_information(priv, IPW_AUTH_OPEN,
						     SEC_LEVEL_0, 0, 1);
	} else {
		auth_mode = IPW_AUTH_OPEN;
		if (priv->ieee->sec.flags & SEC_AUTH_MODE) {
			if (priv->ieee->sec.auth_mode == WLAN_AUTH_SHARED_KEY)
				auth_mode = IPW_AUTH_SHARED;
			else if (priv->ieee->sec.auth_mode == WLAN_AUTH_LEAP)
				auth_mode = IPW_AUTH_LEAP_CISCO_ID;
		}

		sec_level = SEC_LEVEL_0;
		if (priv->ieee->sec.flags & SEC_LEVEL)
			sec_level = priv->ieee->sec.level;

		use_group = 0;
		if (priv->ieee->sec.flags & SEC_UNICAST_GROUP)
			use_group = priv->ieee->sec.unicast_uses_group;

		err =
		    ipw2100_set_security_information(priv, auth_mode, sec_level,
						     use_group, 1);
	}

	if (err)
		goto exit;

	if (priv->ieee->sec.enabled) {
		for (i = 0; i < 4; i++) {
			if (!(priv->ieee->sec.flags & (1 << i))) {
				memset(priv->ieee->sec.keys[i], 0, WEP_KEY_LEN);
				priv->ieee->sec.key_sizes[i] = 0;
			} else {
				err = ipw2100_set_key(priv, i,
						      priv->ieee->sec.keys[i],
						      priv->ieee->sec.
						      key_sizes[i], 1);
				if (err)
					goto exit;
			}
		}

		ipw2100_set_key_index(priv, priv->ieee->crypt_info.tx_keyidx, 1);
	}

	/* Always enable privacy so the Host can filter WEP packets if
	 * encrypted data is sent up */
	err =
	    ipw2100_set_wep_flags(priv,
				  priv->ieee->sec.
				  enabled ? IPW_PRIVACY_CAPABLE : 0, 1);
	if (err)
		goto exit;

	priv->status &= ~STATUS_SECURITY_UPDATED;

      exit:
	if (!batch_mode)
		ipw2100_enable_adapter(priv);

	return err;
}

static void ipw2100_security_work(struct work_struct *work)
{
	struct ipw2100_priv *priv =
		container_of(work, struct ipw2100_priv, security_work.work);

	/* If we happen to have reconnected before we get a chance to
	 * process this, then update the security settings--which causes
	 * a disassociation to occur */
	if (!(priv->status & STATUS_ASSOCIATED) &&
	    priv->status & STATUS_SECURITY_UPDATED)
		ipw2100_configure_security(priv, 0);
}

static void shim__set_security(struct net_device *dev,
			       struct libipw_security *sec)
{
	struct ipw2100_priv *priv = libipw_priv(dev);
	int i, force_update = 0;

	mutex_lock(&priv->action_mutex);
	if (!(priv->status & STATUS_INITIALIZED))
		goto done;

	for (i = 0; i < 4; i++) {
		if (sec->flags & (1 << i)) {
			priv->ieee->sec.key_sizes[i] = sec->key_sizes[i];
			if (sec->key_sizes[i] == 0)
				priv->ieee->sec.flags &= ~(1 << i);
			else
				memcpy(priv->ieee->sec.keys[i], sec->keys[i],
				       sec->key_sizes[i]);
			if (sec->level == SEC_LEVEL_1) {
				priv->ieee->sec.flags |= (1 << i);
				priv->status |= STATUS_SECURITY_UPDATED;
			} else
				priv->ieee->sec.flags &= ~(1 << i);
		}
	}

	if ((sec->flags & SEC_ACTIVE_KEY) &&
	    priv->ieee->sec.active_key != sec->active_key) {
		priv->ieee->sec.active_key = sec->active_key;
		priv->ieee->sec.flags |= SEC_ACTIVE_KEY;
		priv->status |= STATUS_SECURITY_UPDATED;
	}

	if ((sec->flags & SEC_AUTH_MODE) &&
	    (priv->ieee->sec.auth_mode != sec->auth_mode)) {
		priv->ieee->sec.auth_mode = sec->auth_mode;
		priv->ieee->sec.flags |= SEC_AUTH_MODE;
		priv->status |= STATUS_SECURITY_UPDATED;
	}

	if (sec->flags & SEC_ENABLED && priv->ieee->sec.enabled != sec->enabled) {
		priv->ieee->sec.flags |= SEC_ENABLED;
		priv->ieee->sec.enabled = sec->enabled;
		priv->status |= STATUS_SECURITY_UPDATED;
		force_update = 1;
	}

	if (sec->flags & SEC_ENCRYPT)
		priv->ieee->sec.encrypt = sec->encrypt;

	if (sec->flags & SEC_LEVEL && priv->ieee->sec.level != sec->level) {
		priv->ieee->sec.level = sec->level;
		priv->ieee->sec.flags |= SEC_LEVEL;
		priv->status |= STATUS_SECURITY_UPDATED;
	}

	IPW_DEBUG_WEP("Security flags: %c %c%c%c%c %c%c%c%c\n",
		      priv->ieee->sec.flags & (1 << 8) ? '1' : '0',
		      priv->ieee->sec.flags & (1 << 7) ? '1' : '0',
		      priv->ieee->sec.flags & (1 << 6) ? '1' : '0',
		      priv->ieee->sec.flags & (1 << 5) ? '1' : '0',
		      priv->ieee->sec.flags & (1 << 4) ? '1' : '0',
		      priv->ieee->sec.flags & (1 << 3) ? '1' : '0',
		      priv->ieee->sec.flags & (1 << 2) ? '1' : '0',
		      priv->ieee->sec.flags & (1 << 1) ? '1' : '0',
		      priv->ieee->sec.flags & (1 << 0) ? '1' : '0');

/* As a temporary work around to enable WPA until we figure out why
 * wpa_supplicant toggles the security capability of the driver, which
 * forces a disassociation with force_update...
 *
 *	if (force_update || !(priv->status & STATUS_ASSOCIATED))*/
	if (!(priv->status & (STATUS_ASSOCIATED | STATUS_ASSOCIATING)))
		ipw2100_configure_security(priv, 0);
      done:
	mutex_unlock(&priv->action_mutex);
}

static int ipw2100_adapter_setup(struct ipw2100_priv *priv)
{
	int err;
	int batch_mode = 1;
	u8 *bssid;

	IPW_DEBUG_INFO("enter\n");

	err = ipw2100_disable_adapter(priv);
	if (err)
		return err;
#ifdef CONFIG_IPW2100_MONITOR
	if (priv->ieee->iw_mode == IW_MODE_MONITOR) {
		err = ipw2100_set_channel(priv, priv->channel, batch_mode);
		if (err)
			return err;

		IPW_DEBUG_INFO("exit\n");

		return 0;
	}
#endif				/* CONFIG_IPW2100_MONITOR */

	err = ipw2100_read_mac_address(priv);
	if (err)
		return -EIO;

	err = ipw2100_set_mac_address(priv, batch_mode);
	if (err)
		return err;

	err = ipw2100_set_port_type(priv, priv->ieee->iw_mode, batch_mode);
	if (err)
		return err;

	if (priv->ieee->iw_mode == IW_MODE_ADHOC) {
		err = ipw2100_set_channel(priv, priv->channel, batch_mode);
		if (err)
			return err;
	}

	err = ipw2100_system_config(priv, batch_mode);
	if (err)
		return err;

	err = ipw2100_set_tx_rates(priv, priv->tx_rates, batch_mode);
	if (err)
		return err;

	/* Default to power mode OFF */
	err = ipw2100_set_power_mode(priv, IPW_POWER_MODE_CAM);
	if (err)
		return err;

	err = ipw2100_set_rts_threshold(priv, priv->rts_threshold);
	if (err)
		return err;

	if (priv->config & CFG_STATIC_BSSID)
		bssid = priv->bssid;
	else
		bssid = NULL;
	err = ipw2100_set_mandatory_bssid(priv, bssid, batch_mode);
	if (err)
		return err;

	if (priv->config & CFG_STATIC_ESSID)
		err = ipw2100_set_essid(priv, priv->essid, priv->essid_len,
					batch_mode);
	else
		err = ipw2100_set_essid(priv, NULL, 0, batch_mode);
	if (err)
		return err;

	err = ipw2100_configure_security(priv, batch_mode);
	if (err)
		return err;

	if (priv->ieee->iw_mode == IW_MODE_ADHOC) {
		err =
		    ipw2100_set_ibss_beacon_interval(priv,
						     priv->beacon_interval,
						     batch_mode);
		if (err)
			return err;

		err = ipw2100_set_tx_power(priv, priv->tx_power);
		if (err)
			return err;
	}

	/*
	   err = ipw2100_set_fragmentation_threshold(
	   priv, priv->frag_threshold, batch_mode);
	   if (err)
	   return err;
	 */

	IPW_DEBUG_INFO("exit\n");

	return 0;
}

/*************************************************************************
 *
 * EXTERNALLY CALLED METHODS
 *
 *************************************************************************/

/* This method is called by the network layer -- not to be confused with
 * ipw2100_set_mac_address() declared above called by this driver (and this
 * method as well) to talk to the firmware */
static int ipw2100_set_address(struct net_device *dev, void *p)
{
	struct ipw2100_priv *priv = libipw_priv(dev);
	struct sockaddr *addr = p;
	int err = 0;

	if (!is_valid_ether_addr(addr->sa_data))
		return -EADDRNOTAVAIL;

	mutex_lock(&priv->action_mutex);

	priv->config |= CFG_CUSTOM_MAC;
	memcpy(priv->mac_addr, addr->sa_data, ETH_ALEN);

	err = ipw2100_set_mac_address(priv, 0);
	if (err)
		goto done;

	priv->reset_backoff = 0;
	mutex_unlock(&priv->action_mutex);
	ipw2100_reset_adapter(&priv->reset_work.work);
	return 0;

      done:
	mutex_unlock(&priv->action_mutex);
	return err;
}

static int ipw2100_open(struct net_device *dev)
{
	struct ipw2100_priv *priv = libipw_priv(dev);
	unsigned long flags;
	IPW_DEBUG_INFO("dev->open\n");

	spin_lock_irqsave(&priv->low_lock, flags);
	if (priv->status & STATUS_ASSOCIATED) {
		netif_carrier_on(dev);
		netif_start_queue(dev);
	}
	spin_unlock_irqrestore(&priv->low_lock, flags);

	return 0;
}

static int ipw2100_close(struct net_device *dev)
{
	struct ipw2100_priv *priv = libipw_priv(dev);
	unsigned long flags;
	struct list_head *element;
	struct ipw2100_tx_packet *packet;

	IPW_DEBUG_INFO("enter\n");

	spin_lock_irqsave(&priv->low_lock, flags);

	if (priv->status & STATUS_ASSOCIATED)
		netif_carrier_off(dev);
	netif_stop_queue(dev);

	/* Flush the TX queue ... */
	while (!list_empty(&priv->tx_pend_list)) {
		element = priv->tx_pend_list.next;
		packet = list_entry(element, struct ipw2100_tx_packet, list);

		list_del(element);
		DEC_STAT(&priv->tx_pend_stat);

		libipw_txb_free(packet->info.d_struct.txb);
		packet->info.d_struct.txb = NULL;

		list_add_tail(element, &priv->tx_free_list);
		INC_STAT(&priv->tx_free_stat);
	}
	spin_unlock_irqrestore(&priv->low_lock, flags);

	IPW_DEBUG_INFO("exit\n");

	return 0;
}

/*
 * TODO:  Fix this function... its just wrong
 */
static void ipw2100_tx_timeout(struct net_device *dev)
{
	struct ipw2100_priv *priv = libipw_priv(dev);

	dev->stats.tx_errors++;

#ifdef CONFIG_IPW2100_MONITOR
	if (priv->ieee->iw_mode == IW_MODE_MONITOR)
		return;
#endif

	IPW_DEBUG_INFO("%s: TX timed out.  Scheduling firmware restart.\n",
		       dev->name);
	schedule_reset(priv);
}

static int ipw2100_wpa_enable(struct ipw2100_priv *priv, int value)
{
	/* This is called when wpa_supplicant loads and closes the driver
	 * interface. */
	priv->ieee->wpa_enabled = value;
	return 0;
}

static int ipw2100_wpa_set_auth_algs(struct ipw2100_priv *priv, int value)
{

	struct libipw_device *ieee = priv->ieee;
	struct libipw_security sec = {
		.flags = SEC_AUTH_MODE,
	};
	int ret = 0;

	if (value & IW_AUTH_ALG_SHARED_KEY) {
		sec.auth_mode = WLAN_AUTH_SHARED_KEY;
		ieee->open_wep = 0;
	} else if (value & IW_AUTH_ALG_OPEN_SYSTEM) {
		sec.auth_mode = WLAN_AUTH_OPEN;
		ieee->open_wep = 1;
	} else if (value & IW_AUTH_ALG_LEAP) {
		sec.auth_mode = WLAN_AUTH_LEAP;
		ieee->open_wep = 1;
	} else
		return -EINVAL;

	if (ieee->set_security)
		ieee->set_security(ieee->dev, &sec);
	else
		ret = -EOPNOTSUPP;

	return ret;
}

static void ipw2100_wpa_assoc_frame(struct ipw2100_priv *priv,
				    char *wpa_ie, int wpa_ie_len)
{

	struct ipw2100_wpa_assoc_frame frame;

	frame.fixed_ie_mask = 0;

	/* copy WPA IE */
	memcpy(frame.var_ie, wpa_ie, wpa_ie_len);
	frame.var_ie_len = wpa_ie_len;

	/* make sure WPA is enabled */
	ipw2100_wpa_enable(priv, 1);
	ipw2100_set_wpa_ie(priv, &frame, 0);
}

static void ipw_ethtool_get_drvinfo(struct net_device *dev,
				    struct ethtool_drvinfo *info)
{
	struct ipw2100_priv *priv = libipw_priv(dev);
	char fw_ver[64], ucode_ver[64];

	strlcpy(info->driver, DRV_NAME, sizeof(info->driver));
	strlcpy(info->version, DRV_VERSION, sizeof(info->version));

	ipw2100_get_fwversion(priv, fw_ver, sizeof(fw_ver));
	ipw2100_get_ucodeversion(priv, ucode_ver, sizeof(ucode_ver));

	snprintf(info->fw_version, sizeof(info->fw_version), "%s:%d:%s",
		 fw_ver, priv->eeprom_version, ucode_ver);

	strlcpy(info->bus_info, pci_name(priv->pci_dev),
		sizeof(info->bus_info));
}

static u32 ipw2100_ethtool_get_link(struct net_device *dev)
{
	struct ipw2100_priv *priv = libipw_priv(dev);
	return (priv->status & STATUS_ASSOCIATED) ? 1 : 0;
}

static const struct ethtool_ops ipw2100_ethtool_ops = {
	.get_link = ipw2100_ethtool_get_link,
	.get_drvinfo = ipw_ethtool_get_drvinfo,
};

static void ipw2100_hang_check(struct work_struct *work)
{
	struct ipw2100_priv *priv =
		container_of(work, struct ipw2100_priv, hang_check.work);
	unsigned long flags;
	u32 rtc = 0xa5a5a5a5;
	u32 len = sizeof(rtc);
	int restart = 0;

	spin_lock_irqsave(&priv->low_lock, flags);

	if (priv->fatal_error != 0) {
		/* If fatal_error is set then we need to restart */
		IPW_DEBUG_INFO("%s: Hardware fatal error detected.\n",
			       priv->net_dev->name);

		restart = 1;
	} else if (ipw2100_get_ordinal(priv, IPW_ORD_RTC_TIME, &rtc, &len) ||
		   (rtc == priv->last_rtc)) {
		/* Check if firmware is hung */
		IPW_DEBUG_INFO("%s: Firmware RTC stalled.\n",
			       priv->net_dev->name);

		restart = 1;
	}

	if (restart) {
		/* Kill timer */
		priv->stop_hang_check = 1;
		priv->hangs++;

		/* Restart the NIC */
		schedule_reset(priv);
	}

	priv->last_rtc = rtc;

	if (!priv->stop_hang_check)
		schedule_delayed_work(&priv->hang_check, HZ / 2);

	spin_unlock_irqrestore(&priv->low_lock, flags);
}

static void ipw2100_rf_kill(struct work_struct *work)
{
	struct ipw2100_priv *priv =
		container_of(work, struct ipw2100_priv, rf_kill.work);
	unsigned long flags;

	spin_lock_irqsave(&priv->low_lock, flags);

	if (rf_kill_active(priv)) {
		IPW_DEBUG_RF_KILL("RF Kill active, rescheduling GPIO check\n");
		if (!priv->stop_rf_kill)
			schedule_delayed_work(&priv->rf_kill,
					      round_jiffies_relative(HZ));
		goto exit_unlock;
	}

	/* RF Kill is now disabled, so bring the device back up */

	if (!(priv->status & STATUS_RF_KILL_MASK)) {
		IPW_DEBUG_RF_KILL("HW RF Kill no longer active, restarting "
				  "device\n");
		schedule_reset(priv);
	} else
		IPW_DEBUG_RF_KILL("HW RF Kill deactivated.  SW RF Kill still "
				  "enabled\n");

      exit_unlock:
	spin_unlock_irqrestore(&priv->low_lock, flags);
}

static void ipw2100_irq_tasklet(struct ipw2100_priv *priv);

static const struct net_device_ops ipw2100_netdev_ops = {
	.ndo_open		= ipw2100_open,
	.ndo_stop		= ipw2100_close,
	.ndo_start_xmit		= libipw_xmit,
	.ndo_tx_timeout		= ipw2100_tx_timeout,
	.ndo_set_mac_address	= ipw2100_set_address,
	.ndo_validate_addr	= eth_validate_addr,
};

/* Look into using netdev destructor to shutdown libipw? */

static struct net_device *ipw2100_alloc_device(struct pci_dev *pci_dev,
					       void __iomem * ioaddr)
{
	struct ipw2100_priv *priv;
	struct net_device *dev;

	dev = alloc_libipw(sizeof(struct ipw2100_priv), 0);
	if (!dev)
		return NULL;
	priv = libipw_priv(dev);
	priv->ieee = netdev_priv(dev);
	priv->pci_dev = pci_dev;
	priv->net_dev = dev;
	priv->ioaddr = ioaddr;

	priv->ieee->hard_start_xmit = ipw2100_tx;
	priv->ieee->set_security = shim__set_security;

	priv->ieee->perfect_rssi = -20;
	priv->ieee->worst_rssi = -85;

	dev->netdev_ops = &ipw2100_netdev_ops;
	dev->ethtool_ops = &ipw2100_ethtool_ops;
	dev->wireless_handlers = &ipw2100_wx_handler_def;
	priv->wireless_data.libipw = priv->ieee;
	dev->wireless_data = &priv->wireless_data;
	dev->watchdog_timeo = 3 * HZ;
	dev->irq = 0;
	dev->min_mtu = 68;
	dev->max_mtu = LIBIPW_DATA_LEN;

	/* NOTE: We don't use the wireless_handlers hook
	 * in dev as the system will start throwing WX requests
	 * to us before we're actually initialized and it just
	 * ends up causing problems.  So, we just handle
	 * the WX extensions through the ipw2100_ioctl interface */

	/* memset() puts everything to 0, so we only have explicitly set
	 * those values that need to be something else */

	/* If power management is turned on, default to AUTO mode */
	priv->power_mode = IPW_POWER_AUTO;

#ifdef CONFIG_IPW2100_MONITOR
	priv->config |= CFG_CRC_CHECK;
#endif
	priv->ieee->wpa_enabled = 0;
	priv->ieee->drop_unencrypted = 0;
	priv->ieee->privacy_invoked = 0;
	priv->ieee->ieee802_1x = 1;

	/* Set module parameters */
	switch (network_mode) {
	case 1:
		priv->ieee->iw_mode = IW_MODE_ADHOC;
		break;
#ifdef CONFIG_IPW2100_MONITOR
	case 2:
		priv->ieee->iw_mode = IW_MODE_MONITOR;
		break;
#endif
	default:
	case 0:
		priv->ieee->iw_mode = IW_MODE_INFRA;
		break;
	}

	if (disable == 1)
		priv->status |= STATUS_RF_KILL_SW;

	if (channel != 0 &&
	    ((channel >= REG_MIN_CHANNEL) && (channel <= REG_MAX_CHANNEL))) {
		priv->config |= CFG_STATIC_CHANNEL;
		priv->channel = channel;
	}

	if (associate)
		priv->config |= CFG_ASSOCIATE;

	priv->beacon_interval = DEFAULT_BEACON_INTERVAL;
	priv->short_retry_limit = DEFAULT_SHORT_RETRY_LIMIT;
	priv->long_retry_limit = DEFAULT_LONG_RETRY_LIMIT;
	priv->rts_threshold = DEFAULT_RTS_THRESHOLD | RTS_DISABLED;
	priv->frag_threshold = DEFAULT_FTS | FRAG_DISABLED;
	priv->tx_power = IPW_TX_POWER_DEFAULT;
	priv->tx_rates = DEFAULT_TX_RATES;

	strcpy(priv->nick, "ipw2100");

	spin_lock_init(&priv->low_lock);
	mutex_init(&priv->action_mutex);
	mutex_init(&priv->adapter_mutex);

	init_waitqueue_head(&priv->wait_command_queue);

	netif_carrier_off(dev);

	INIT_LIST_HEAD(&priv->msg_free_list);
	INIT_LIST_HEAD(&priv->msg_pend_list);
	INIT_STAT(&priv->msg_free_stat);
	INIT_STAT(&priv->msg_pend_stat);

	INIT_LIST_HEAD(&priv->tx_free_list);
	INIT_LIST_HEAD(&priv->tx_pend_list);
	INIT_STAT(&priv->tx_free_stat);
	INIT_STAT(&priv->tx_pend_stat);

	INIT_LIST_HEAD(&priv->fw_pend_list);
	INIT_STAT(&priv->fw_pend_stat);

	INIT_DELAYED_WORK(&priv->reset_work, ipw2100_reset_adapter);
	INIT_DELAYED_WORK(&priv->security_work, ipw2100_security_work);
	INIT_DELAYED_WORK(&priv->wx_event_work, ipw2100_wx_event_work);
	INIT_DELAYED_WORK(&priv->hang_check, ipw2100_hang_check);
	INIT_DELAYED_WORK(&priv->rf_kill, ipw2100_rf_kill);
	INIT_DELAYED_WORK(&priv->scan_event, ipw2100_scan_event);

	tasklet_init(&priv->irq_tasklet, (void (*)(unsigned long))
		     ipw2100_irq_tasklet, (unsigned long)priv);

	/* NOTE:  We do not start the deferred work for status checks yet */
	priv->stop_rf_kill = 1;
	priv->stop_hang_check = 1;

	return dev;
}

static int ipw2100_pci_init_one(struct pci_dev *pci_dev,
				const struct pci_device_id *ent)
{
	void __iomem *ioaddr;
	struct net_device *dev = NULL;
	struct ipw2100_priv *priv = NULL;
	int err = 0;
	int registered = 0;
	u32 val;

	IPW_DEBUG_INFO("enter\n");

	if (!(pci_resource_flags(pci_dev, 0) & IORESOURCE_MEM)) {
		IPW_DEBUG_INFO("weird - resource type is not memory\n");
		err = -ENODEV;
		goto out;
	}

	ioaddr = pci_iomap(pci_dev, 0, 0);
	if (!ioaddr) {
		printk(KERN_WARNING DRV_NAME
		       "Error calling ioremap_nocache.\n");
		err = -EIO;
		goto fail;
	}

	/* allocate and initialize our net_device */
	dev = ipw2100_alloc_device(pci_dev, ioaddr);
	if (!dev) {
		printk(KERN_WARNING DRV_NAME
		       "Error calling ipw2100_alloc_device.\n");
		err = -ENOMEM;
		goto fail;
	}

	/* set up PCI mappings for device */
	err = pci_enable_device(pci_dev);
	if (err) {
		printk(KERN_WARNING DRV_NAME
		       "Error calling pci_enable_device.\n");
		return err;
	}

	priv = libipw_priv(dev);

	pci_set_master(pci_dev);
	pci_set_drvdata(pci_dev, priv);

	err = pci_set_dma_mask(pci_dev, DMA_BIT_MASK(32));
	if (err) {
		printk(KERN_WARNING DRV_NAME
		       "Error calling pci_set_dma_mask.\n");
		pci_disable_device(pci_dev);
		return err;
	}

	err = pci_request_regions(pci_dev, DRV_NAME);
	if (err) {
		printk(KERN_WARNING DRV_NAME
		       "Error calling pci_request_regions.\n");
		pci_disable_device(pci_dev);
		return err;
	}

	/* We disable the RETRY_TIMEOUT register (0x41) to keep
	 * PCI Tx retries from interfering with C3 CPU state */
	pci_read_config_dword(pci_dev, 0x40, &val);
	if ((val & 0x0000ff00) != 0)
		pci_write_config_dword(pci_dev, 0x40, val & 0xffff00ff);

	if (!ipw2100_hw_is_adapter_in_system(dev)) {
		printk(KERN_WARNING DRV_NAME
		       "Device not found via register read.\n");
		err = -ENODEV;
		goto fail;
	}

	SET_NETDEV_DEV(dev, &pci_dev->dev);

	/* Force interrupts to be shut off on the device */
	priv->status |= STATUS_INT_ENABLED;
	ipw2100_disable_interrupts(priv);

	/* Allocate and initialize the Tx/Rx queues and lists */
	if (ipw2100_queues_allocate(priv)) {
		printk(KERN_WARNING DRV_NAME
		       "Error calling ipw2100_queues_allocate.\n");
		err = -ENOMEM;
		goto fail;
	}
	ipw2100_queues_initialize(priv);

	err = request_irq(pci_dev->irq,
			  ipw2100_interrupt, IRQF_SHARED, dev->name, priv);
	if (err) {
		printk(KERN_WARNING DRV_NAME
		       "Error calling request_irq: %d.\n", pci_dev->irq);
		goto fail;
	}
	dev->irq = pci_dev->irq;

	IPW_DEBUG_INFO("Attempting to register device...\n");

	printk(KERN_INFO DRV_NAME
	       ": Detected Intel PRO/Wireless 2100 Network Connection\n");

	err = ipw2100_up(priv, 1);
	if (err)
		goto fail;

	err = ipw2100_wdev_init(dev);
	if (err)
		goto fail;
	registered = 1;

	/* Bring up the interface.  Pre 0.46, after we registered the
	 * network device we would call ipw2100_up.  This introduced a race
	 * condition with newer hotplug configurations (network was coming
	 * up and making calls before the device was initialized).
	 */
	err = register_netdev(dev);
	if (err) {
		printk(KERN_WARNING DRV_NAME
		       "Error calling register_netdev.\n");
		goto fail;
	}
	registered = 2;

	mutex_lock(&priv->action_mutex);

	IPW_DEBUG_INFO("%s: Bound to %s\n", dev->name, pci_name(pci_dev));

	/* perform this after register_netdev so that dev->name is set */
	err = sysfs_create_group(&pci_dev->dev.kobj, &ipw2100_attribute_group);
	if (err)
		goto fail_unlock;

	/* If the RF Kill switch is disabled, go ahead and complete the
	 * startup sequence */
	if (!(priv->status & STATUS_RF_KILL_MASK)) {
		/* Enable the adapter - sends HOST_COMPLETE */
		if (ipw2100_enable_adapter(priv)) {
			printk(KERN_WARNING DRV_NAME
			       ": %s: failed in call to enable adapter.\n",
			       priv->net_dev->name);
			ipw2100_hw_stop_adapter(priv);
			err = -EIO;
			goto fail_unlock;
		}

		/* Start a scan . . . */
		ipw2100_set_scan_options(priv);
		ipw2100_start_scan(priv);
	}

	IPW_DEBUG_INFO("exit\n");

	priv->status |= STATUS_INITIALIZED;

	mutex_unlock(&priv->action_mutex);
out:
	return err;

      fail_unlock:
	mutex_unlock(&priv->action_mutex);
      fail:
	if (dev) {
		if (registered >= 2)
			unregister_netdev(dev);

		if (registered) {
			wiphy_unregister(priv->ieee->wdev.wiphy);
			kfree(priv->ieee->bg_band.channels);
		}

		ipw2100_hw_stop_adapter(priv);

		ipw2100_disable_interrupts(priv);

		if (dev->irq)
			free_irq(dev->irq, priv);

		ipw2100_kill_works(priv);

		/* These are safe to call even if they weren't allocated */
		ipw2100_queues_free(priv);
		sysfs_remove_group(&pci_dev->dev.kobj,
				   &ipw2100_attribute_group);

		free_libipw(dev, 0);
	}

	pci_iounmap(pci_dev, ioaddr);

	pci_release_regions(pci_dev);
	pci_disable_device(pci_dev);
	goto out;
}

static void ipw2100_pci_remove_one(struct pci_dev *pci_dev)
{
	struct ipw2100_priv *priv = pci_get_drvdata(pci_dev);
	struct net_device *dev = priv->net_dev;

	mutex_lock(&priv->action_mutex);

	priv->status &= ~STATUS_INITIALIZED;

	sysfs_remove_group(&pci_dev->dev.kobj, &ipw2100_attribute_group);

#ifdef CONFIG_PM
	if (ipw2100_firmware.version)
		ipw2100_release_firmware(priv, &ipw2100_firmware);
#endif
	/* Take down the hardware */
	ipw2100_down(priv);

	/* Release the mutex so that the network subsystem can
	 * complete any needed calls into the driver... */
	mutex_unlock(&priv->action_mutex);

	/* Unregister the device first - this results in close()
	 * being called if the device is open.  If we free storage
	 * first, then close() will crash.
	 * FIXME: remove the comment above. */
	unregister_netdev(dev);

	ipw2100_kill_works(priv);

	ipw2100_queues_free(priv);

	/* Free potential debugging firmware snapshot */
	ipw2100_snapshot_free(priv);

	free_irq(dev->irq, priv);

	pci_iounmap(pci_dev, priv->ioaddr);

	/* wiphy_unregister needs to be here, before free_libipw */
	wiphy_unregister(priv->ieee->wdev.wiphy);
	kfree(priv->ieee->bg_band.channels);
	free_libipw(dev, 0);

	pci_release_regions(pci_dev);
	pci_disable_device(pci_dev);

	IPW_DEBUG_INFO("exit\n");
}

#ifdef CONFIG_PM
static int ipw2100_suspend(struct pci_dev *pci_dev, pm_message_t state)
{
	struct ipw2100_priv *priv = pci_get_drvdata(pci_dev);
	struct net_device *dev = priv->net_dev;

	IPW_DEBUG_INFO("%s: Going into suspend...\n", dev->name);

	mutex_lock(&priv->action_mutex);
	if (priv->status & STATUS_INITIALIZED) {
		/* Take down the device; powers it off, etc. */
		ipw2100_down(priv);
	}

	/* Remove the PRESENT state of the device */
	netif_device_detach(dev);

	pci_save_state(pci_dev);
	pci_disable_device(pci_dev);
	pci_set_power_state(pci_dev, PCI_D3hot);

	priv->suspend_at = ktime_get_boottime_seconds();

	mutex_unlock(&priv->action_mutex);

	return 0;
}

static int ipw2100_resume(struct pci_dev *pci_dev)
{
	struct ipw2100_priv *priv = pci_get_drvdata(pci_dev);
	struct net_device *dev = priv->net_dev;
	int err;
	u32 val;

	if (IPW2100_PM_DISABLED)
		return 0;

	mutex_lock(&priv->action_mutex);

	IPW_DEBUG_INFO("%s: Coming out of suspend...\n", dev->name);

	pci_set_power_state(pci_dev, PCI_D0);
	err = pci_enable_device(pci_dev);
	if (err) {
		printk(KERN_ERR "%s: pci_enable_device failed on resume\n",
		       dev->name);
		mutex_unlock(&priv->action_mutex);
		return err;
	}
	pci_restore_state(pci_dev);

	/*
	 * Suspend/Resume resets the PCI configuration space, so we have to
	 * re-disable the RETRY_TIMEOUT register (0x41) to keep PCI Tx retries
	 * from interfering with C3 CPU state. pci_restore_state won't help
	 * here since it only restores the first 64 bytes pci config header.
	 */
	pci_read_config_dword(pci_dev, 0x40, &val);
	if ((val & 0x0000ff00) != 0)
		pci_write_config_dword(pci_dev, 0x40, val & 0xffff00ff);

	/* Set the device back into the PRESENT state; this will also wake
	 * the queue of needed */
	netif_device_attach(dev);

	priv->suspend_time = ktime_get_boottime_seconds() - priv->suspend_at;

	/* Bring the device back up */
	if (!(priv->status & STATUS_RF_KILL_SW))
		ipw2100_up(priv, 0);

	mutex_unlock(&priv->action_mutex);

	return 0;
}
#endif

static void ipw2100_shutdown(struct pci_dev *pci_dev)
{
	struct ipw2100_priv *priv = pci_get_drvdata(pci_dev);

	/* Take down the device; powers it off, etc. */
	ipw2100_down(priv);

	pci_disable_device(pci_dev);
}

#define IPW2100_DEV_ID(x) { PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, x }

static const struct pci_device_id ipw2100_pci_id_table[] = {
	IPW2100_DEV_ID(0x2520),	/* IN 2100A mPCI 3A */
	IPW2100_DEV_ID(0x2521),	/* IN 2100A mPCI 3B */
	IPW2100_DEV_ID(0x2524),	/* IN 2100A mPCI 3B */
	IPW2100_DEV_ID(0x2525),	/* IN 2100A mPCI 3B */
	IPW2100_DEV_ID(0x2526),	/* IN 2100A mPCI Gen A3 */
	IPW2100_DEV_ID(0x2522),	/* IN 2100 mPCI 3B */
	IPW2100_DEV_ID(0x2523),	/* IN 2100 mPCI 3A */
	IPW2100_DEV_ID(0x2527),	/* IN 2100 mPCI 3B */
	IPW2100_DEV_ID(0x2528),	/* IN 2100 mPCI 3B */
	IPW2100_DEV_ID(0x2529),	/* IN 2100 mPCI 3B */
	IPW2100_DEV_ID(0x252B),	/* IN 2100 mPCI 3A */
	IPW2100_DEV_ID(0x252C),	/* IN 2100 mPCI 3A */
	IPW2100_DEV_ID(0x252D),	/* IN 2100 mPCI 3A */

	IPW2100_DEV_ID(0x2550),	/* IB 2100A mPCI 3B */
	IPW2100_DEV_ID(0x2551),	/* IB 2100 mPCI 3B */
	IPW2100_DEV_ID(0x2553),	/* IB 2100 mPCI 3B */
	IPW2100_DEV_ID(0x2554),	/* IB 2100 mPCI 3B */
	IPW2100_DEV_ID(0x2555),	/* IB 2100 mPCI 3B */

	IPW2100_DEV_ID(0x2560),	/* DE 2100A mPCI 3A */
	IPW2100_DEV_ID(0x2562),	/* DE 2100A mPCI 3A */
	IPW2100_DEV_ID(0x2563),	/* DE 2100A mPCI 3A */
	IPW2100_DEV_ID(0x2561),	/* DE 2100 mPCI 3A */
	IPW2100_DEV_ID(0x2565),	/* DE 2100 mPCI 3A */
	IPW2100_DEV_ID(0x2566),	/* DE 2100 mPCI 3A */
	IPW2100_DEV_ID(0x2567),	/* DE 2100 mPCI 3A */

	IPW2100_DEV_ID(0x2570),	/* GA 2100 mPCI 3B */

	IPW2100_DEV_ID(0x2580),	/* TO 2100A mPCI 3B */
	IPW2100_DEV_ID(0x2582),	/* TO 2100A mPCI 3B */
	IPW2100_DEV_ID(0x2583),	/* TO 2100A mPCI 3B */
	IPW2100_DEV_ID(0x2581),	/* TO 2100 mPCI 3B */
	IPW2100_DEV_ID(0x2585),	/* TO 2100 mPCI 3B */
	IPW2100_DEV_ID(0x2586),	/* TO 2100 mPCI 3B */
	IPW2100_DEV_ID(0x2587),	/* TO 2100 mPCI 3B */

	IPW2100_DEV_ID(0x2590),	/* SO 2100A mPCI 3B */
	IPW2100_DEV_ID(0x2592),	/* SO 2100A mPCI 3B */
	IPW2100_DEV_ID(0x2591),	/* SO 2100 mPCI 3B */
	IPW2100_DEV_ID(0x2593),	/* SO 2100 mPCI 3B */
	IPW2100_DEV_ID(0x2596),	/* SO 2100 mPCI 3B */
	IPW2100_DEV_ID(0x2598),	/* SO 2100 mPCI 3B */

	IPW2100_DEV_ID(0x25A0),	/* HP 2100 mPCI 3B */
	{0,},
};

MODULE_DEVICE_TABLE(pci, ipw2100_pci_id_table);

static struct pci_driver ipw2100_pci_driver = {
	.name = DRV_NAME,
	.id_table = ipw2100_pci_id_table,
	.probe = ipw2100_pci_init_one,
	.remove = ipw2100_pci_remove_one,
#ifdef CONFIG_PM
	.suspend = ipw2100_suspend,
	.resume = ipw2100_resume,
#endif
	.shutdown = ipw2100_shutdown,
};

/**
 * Initialize the ipw2100 driver/module
 *
 * @returns 0 if ok, < 0 errno node con error.
 *
 * Note: we cannot init the /proc stuff until the PCI driver is there,
 * or we risk an unlikely race condition on someone accessing
 * uninitialized data in the PCI dev struct through /proc.
 */
static int __init ipw2100_init(void)
{
	int ret;

	printk(KERN_INFO DRV_NAME ": %s, %s\n", DRV_DESCRIPTION, DRV_VERSION);
	printk(KERN_INFO DRV_NAME ": %s\n", DRV_COPYRIGHT);

	pm_qos_add_request(&ipw2100_pm_qos_req, PM_QOS_CPU_DMA_LATENCY,
			   PM_QOS_DEFAULT_VALUE);

	ret = pci_register_driver(&ipw2100_pci_driver);
	if (ret)
		goto out;

#ifdef CONFIG_IPW2100_DEBUG
	ipw2100_debug_level = debug;
	ret = driver_create_file(&ipw2100_pci_driver.driver,
				 &driver_attr_debug_level);
#endif

out:
	return ret;
}

/**
 * Cleanup ipw2100 driver registration
 */
static void __exit ipw2100_exit(void)
{
	/* FIXME: IPG: check that we have no instances of the devices open */
#ifdef CONFIG_IPW2100_DEBUG
	driver_remove_file(&ipw2100_pci_driver.driver,
			   &driver_attr_debug_level);
#endif
	pci_unregister_driver(&ipw2100_pci_driver);
	pm_qos_remove_request(&ipw2100_pm_qos_req);
}

module_init(ipw2100_init);
module_exit(ipw2100_exit);

static int ipw2100_wx_get_name(struct net_device *dev,
			       struct iw_request_info *info,
			       union iwreq_data *wrqu, char *extra)
{
	/*
	 * This can be called at any time.  No action lock required
	 */

	struct ipw2100_priv *priv = libipw_priv(dev);
	if (!(priv->status & STATUS_ASSOCIATED))
		strcpy(wrqu->name, "unassociated");
	else
		snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11b");

	IPW_DEBUG_WX("Name: %s\n", wrqu->name);
	return 0;
}

static int ipw2100_wx_set_freq(struct net_device *dev,
			       struct iw_request_info *info,
			       union iwreq_data *wrqu, char *extra)
{
	struct ipw2100_priv *priv = libipw_priv(dev);
	struct iw_freq *fwrq = &wrqu->freq;
	int err = 0;

	if (priv->ieee->iw_mode == IW_MODE_INFRA)
		return -EOPNOTSUPP;

	mutex_lock(&priv->action_mutex);
	if (!(priv->status & STATUS_INITIALIZED)) {
		err = -EIO;
		goto done;
	}

	/* if setting by freq convert to channel */
	if (fwrq->e == 1) {
		if ((fwrq->m >= (int)2.412e8 && fwrq->m <= (int)2.487e8)) {
			int f = fwrq->m / 100000;
			int c = 0;

			while ((c < REG_MAX_CHANNEL) &&
			       (f != ipw2100_frequencies[c]))
				c++;

			/* hack to fall through */
			fwrq->e = 0;
			fwrq->m = c + 1;
		}
	}

	if (fwrq->e > 0 || fwrq->m > 1000) {
		err = -EOPNOTSUPP;
		goto done;
	} else {		/* Set the channel */
		IPW_DEBUG_WX("SET Freq/Channel -> %d\n", fwrq->m);
		err = ipw2100_set_channel(priv, fwrq->m, 0);
	}

      done:
	mutex_unlock(&priv->action_mutex);
	return err;
}

static int ipw2100_wx_get_freq(struct net_device *dev,
			       struct iw_request_info *info,
			       union iwreq_data *wrqu, char *extra)
{
	/*
	 * This can be called at any time.  No action lock required
	 */

	struct ipw2100_priv *priv = libipw_priv(dev);

	wrqu->freq.e = 0;

	/* If we are associated, trying to associate, or have a statically
	 * configured CHANNEL then return that; otherwise return ANY */
	if (priv->config & CFG_STATIC_CHANNEL ||
	    priv->status & STATUS_ASSOCIATED)
		wrqu->freq.m = priv->channel;
	else
		wrqu->freq.m = 0;

	IPW_DEBUG_WX("GET Freq/Channel -> %d\n", priv->channel);
	return 0;

}

static int ipw2100_wx_set_mode(struct net_device *dev,
			       struct iw_request_info *info,
			       union iwreq_data *wrqu, char *extra)
{
	struct ipw2100_priv *priv = libipw_priv(dev);
	int err = 0;

	IPW_DEBUG_WX("SET Mode -> %d\n", wrqu->mode);

	if (wrqu->mode == priv->ieee->iw_mode)
		return 0;

	mutex_lock(&priv->action_mutex);
	if (!(priv->status & STATUS_INITIALIZED)) {
		err = -EIO;
		goto done;
	}

	switch (wrqu->mode) {
#ifdef CONFIG_IPW2100_MONITOR
	case IW_MODE_MONITOR:
		err = ipw2100_switch_mode(priv, IW_MODE_MONITOR);
		break;
#endif				/* CONFIG_IPW2100_MONITOR */
	case IW_MODE_ADHOC:
		err = ipw2100_switch_mode(priv, IW_MODE_ADHOC);
		break;
	case IW_MODE_INFRA:
	case IW_MODE_AUTO:
	default:
		err = ipw2100_switch_mode(priv, IW_MODE_INFRA);
		break;
	}

      done:
	mutex_unlock(&priv->action_mutex);
	return err;
}

static int ipw2100_wx_get_mode(struct net_device *dev,
			       struct iw_request_info *info,
			       union iwreq_data *wrqu, char *extra)
{
	/*
	 * This can be called at any time.  No action lock required
	 */

	struct ipw2100_priv *priv = libipw_priv(dev);

	wrqu->mode = priv->ieee->iw_mode;
	IPW_DEBUG_WX("GET Mode -> %d\n", wrqu->mode);

	return 0;
}

#define POWER_MODES 5

/* Values are in microsecond */
static const s32 timeout_duration[POWER_MODES] = {
	350000,
	250000,
	75000,
	37000,
	25000,
};

static const s32 period_duration[POWER_MODES] = {
	400000,
	700000,
	1000000,
	1000000,
	1000000
};

static int ipw2100_wx_get_range(struct net_device *dev,
				struct iw_request_info *info,
				union iwreq_data *wrqu, char *extra)
{
	/*
	 * This can be called at any time.  No action lock required
	 */

	struct ipw2100_priv *priv = libipw_priv(dev);
	struct iw_range *range = (struct iw_range *)extra;
	u16 val;
	int i, level;

	wrqu->data.length = sizeof(*range);
	memset(range, 0, sizeof(*range));

	/* Let's try to keep this struct in the same order as in
	 * linux/include/wireless.h
	 */

	/* TODO: See what values we can set, and remove the ones we can't
	 * set, or fill them with some default data.
	 */

	/* ~5 Mb/s real (802.11b) */
	range->throughput = 5 * 1000 * 1000;

//      range->sensitivity;     /* signal level threshold range */

	range->max_qual.qual = 100;
	/* TODO: Find real max RSSI and stick here */
	range->max_qual.level = 0;
	range->max_qual.noise = 0;
	range->max_qual.updated = 7;	/* Updated all three */

	range->avg_qual.qual = 70;	/* > 8% missed beacons is 'bad' */
	/* TODO: Find real 'good' to 'bad' threshold value for RSSI */
	range->avg_qual.level = 20 + IPW2100_RSSI_TO_DBM;
	range->avg_qual.noise = 0;
	range->avg_qual.updated = 7;	/* Updated all three */

	range->num_bitrates = RATE_COUNT;

	for (i = 0; i < RATE_COUNT && i < IW_MAX_BITRATES; i++) {
		range->bitrate[i] = ipw2100_bg_rates[i].bitrate * 100 * 1000;
	}

	range->min_rts = MIN_RTS_THRESHOLD;
	range->max_rts = MAX_RTS_THRESHOLD;
	range->min_frag = MIN_FRAG_THRESHOLD;
	range->max_frag = MAX_FRAG_THRESHOLD;

	range->min_pmp = period_duration[0];	/* Minimal PM period */
	range->max_pmp = period_duration[POWER_MODES - 1];	/* Maximal PM period */
	range->min_pmt = timeout_duration[POWER_MODES - 1];	/* Minimal PM timeout */
	range->max_pmt = timeout_duration[0];	/* Maximal PM timeout */

	/* How to decode max/min PM period */
	range->pmp_flags = IW_POWER_PERIOD;
	/* How to decode max/min PM period */
	range->pmt_flags = IW_POWER_TIMEOUT;
	/* What PM options are supported */
	range->pm_capa = IW_POWER_TIMEOUT | IW_POWER_PERIOD;

	range->encoding_size[0] = 5;
	range->encoding_size[1] = 13;	/* Different token sizes */
	range->num_encoding_sizes = 2;	/* Number of entry in the list */
	range->max_encoding_tokens = WEP_KEYS;	/* Max number of tokens */
//      range->encoding_login_index;            /* token index for login token */

	if (priv->ieee->iw_mode == IW_MODE_ADHOC) {
		range->txpower_capa = IW_TXPOW_DBM;
		range->num_txpower = IW_MAX_TXPOWER;
		for (i = 0, level = (IPW_TX_POWER_MAX_DBM * 16);
		     i < IW_MAX_TXPOWER;
		     i++, level -=
		     ((IPW_TX_POWER_MAX_DBM -
		       IPW_TX_POWER_MIN_DBM) * 16) / (IW_MAX_TXPOWER - 1))
			range->txpower[i] = level / 16;
	} else {
		range->txpower_capa = 0;
		range->num_txpower = 0;
	}

	/* Set the Wireless Extension versions */
	range->we_version_compiled = WIRELESS_EXT;
	range->we_version_source = 18;

//      range->retry_capa;      /* What retry options are supported */
//      range->retry_flags;     /* How to decode max/min retry limit */
//      range->r_time_flags;    /* How to decode max/min retry life */
//      range->min_retry;       /* Minimal number of retries */
//      range->max_retry;       /* Maximal number of retries */
//      range->min_r_time;      /* Minimal retry lifetime */
//      range->max_r_time;      /* Maximal retry lifetime */

	range->num_channels = FREQ_COUNT;

	val = 0;
	for (i = 0; i < FREQ_COUNT; i++) {
		// TODO: Include only legal frequencies for some countries
//              if (local->channel_mask & (1 << i)) {
		range->freq[val].i = i + 1;
		range->freq[val].m = ipw2100_frequencies[i] * 100000;
		range->freq[val].e = 1;
		val++;
//              }
		if (val == IW_MAX_FREQUENCIES)
			break;
	}
	range->num_frequency = val;

	/* Event capability (kernel + driver) */
	range->event_capa[0] = (IW_EVENT_CAPA_K_0 |
				IW_EVENT_CAPA_MASK(SIOCGIWAP));
	range->event_capa[1] = IW_EVENT_CAPA_K_1;

	range->enc_capa = IW_ENC_CAPA_WPA | IW_ENC_CAPA_WPA2 |
		IW_ENC_CAPA_CIPHER_TKIP | IW_ENC_CAPA_CIPHER_CCMP;

	IPW_DEBUG_WX("GET Range\n");

	return 0;
}

static int ipw2100_wx_set_wap(struct net_device *dev,
			      struct iw_request_info *info,
			      union iwreq_data *wrqu, char *extra)
{
	struct ipw2100_priv *priv = libipw_priv(dev);
	int err = 0;

	// sanity checks
	if (wrqu->ap_addr.sa_family != ARPHRD_ETHER)
		return -EINVAL;

	mutex_lock(&priv->action_mutex);
	if (!(priv->status & STATUS_INITIALIZED)) {
		err = -EIO;
		goto done;
	}

	if (is_broadcast_ether_addr(wrqu->ap_addr.sa_data) ||
	    is_zero_ether_addr(wrqu->ap_addr.sa_data)) {
		/* we disable mandatory BSSID association */
		IPW_DEBUG_WX("exit - disable mandatory BSSID\n");
		priv->config &= ~CFG_STATIC_BSSID;
		err = ipw2100_set_mandatory_bssid(priv, NULL, 0);
		goto done;
	}

	priv->config |= CFG_STATIC_BSSID;
	memcpy(priv->mandatory_bssid_mac, wrqu->ap_addr.sa_data, ETH_ALEN);

	err = ipw2100_set_mandatory_bssid(priv, wrqu->ap_addr.sa_data, 0);

	IPW_DEBUG_WX("SET BSSID -> %pM\n", wrqu->ap_addr.sa_data);

      done:
	mutex_unlock(&priv->action_mutex);
	return err;
}

static int ipw2100_wx_get_wap(struct net_device *dev,
			      struct iw_request_info *info,
			      union iwreq_data *wrqu, char *extra)
{
	/*
	 * This can be called at any time.  No action lock required
	 */

	struct ipw2100_priv *priv = libipw_priv(dev);

	/* If we are associated, trying to associate, or have a statically
	 * configured BSSID then return that; otherwise return ANY */
	if (priv->config & CFG_STATIC_BSSID || priv->status & STATUS_ASSOCIATED) {
		wrqu->ap_addr.sa_family = ARPHRD_ETHER;
		memcpy(wrqu->ap_addr.sa_data, priv->bssid, ETH_ALEN);
	} else
		eth_zero_addr(wrqu->ap_addr.sa_data);

	IPW_DEBUG_WX("Getting WAP BSSID: %pM\n", wrqu->ap_addr.sa_data);
	return 0;
}

static int ipw2100_wx_set_essid(struct net_device *dev,
				struct iw_request_info *info,
				union iwreq_data *wrqu, char *extra)
{
	struct ipw2100_priv *priv = libipw_priv(dev);
	char *essid = "";	/* ANY */
	int length = 0;
	int err = 0;

	mutex_lock(&priv->action_mutex);
	if (!(priv->status & STATUS_INITIALIZED)) {
		err = -EIO;
		goto done;
	}

	if (wrqu->essid.flags && wrqu->essid.length) {
		length = wrqu->essid.length;
		essid = extra;
	}

	if (length == 0) {
		IPW_DEBUG_WX("Setting ESSID to ANY\n");
		priv->config &= ~CFG_STATIC_ESSID;
		err = ipw2100_set_essid(priv, NULL, 0, 0);
		goto done;
	}

	length = min(length, IW_ESSID_MAX_SIZE);

	priv->config |= CFG_STATIC_ESSID;

	if (priv->essid_len == length && !memcmp(priv->essid, extra, length)) {
		IPW_DEBUG_WX("ESSID set to current ESSID.\n");
		err = 0;
		goto done;
	}

	IPW_DEBUG_WX("Setting ESSID: '%*pE' (%d)\n", length, essid, length);

	priv->essid_len = length;
	memcpy(priv->essid, essid, priv->essid_len);

	err = ipw2100_set_essid(priv, essid, length, 0);

      done:
	mutex_unlock(&priv->action_mutex);
	return err;
}

static int ipw2100_wx_get_essid(struct net_device *dev,
				struct iw_request_info *info,
				union iwreq_data *wrqu, char *extra)
{
	/*
	 * This can be called at any time.  No action lock required
	 */

	struct ipw2100_priv *priv = libipw_priv(dev);

	/* If we are associated, trying to associate, or have a statically
	 * configured ESSID then return that; otherwise return ANY */
	if (priv->config & CFG_STATIC_ESSID || priv->status & STATUS_ASSOCIATED) {
		IPW_DEBUG_WX("Getting essid: '%*pE'\n",
			     priv->essid_len, priv->essid);
		memcpy(extra, priv->essid, priv->essid_len);
		wrqu->essid.length = priv->essid_len;
		wrqu->essid.flags = 1;	/* active */
	} else {
		IPW_DEBUG_WX("Getting essid: ANY\n");
		wrqu->essid.length = 0;
		wrqu->essid.flags = 0;	/* active */
	}

	return 0;
}

static int ipw2100_wx_set_nick(struct net_device *dev,
			       struct iw_request_info *info,
			       union iwreq_data *wrqu, char *extra)
{
	/*
	 * This can be called at any time.  No action lock required
	 */

	struct ipw2100_priv *priv = libipw_priv(dev);

	if (wrqu->data.length > IW_ESSID_MAX_SIZE)
		return -E2BIG;

	wrqu->data.length = min_t(size_t, wrqu->data.length, sizeof(priv->nick));
	memset(priv->nick, 0, sizeof(priv->nick));
	memcpy(priv->nick, extra, wrqu->data.length);

	IPW_DEBUG_WX("SET Nickname -> %s\n", priv->nick);

	return 0;
}

static int ipw2100_wx_get_nick(struct net_device *dev,
			       struct iw_request_info *info,
			       union iwreq_data *wrqu, char *extra)
{
	/*
	 * This can be called at any time.  No action lock required
	 */

	struct ipw2100_priv *priv = libipw_priv(dev);

	wrqu->data.length = strlen(priv->nick);
	memcpy(extra, priv->nick, wrqu->data.length);
	wrqu->data.flags = 1;	/* active */

	IPW_DEBUG_WX("GET Nickname -> %s\n", extra);

	return 0;
}

static int ipw2100_wx_set_rate(struct net_device *dev,
			       struct iw_request_info *info,
			       union iwreq_data *wrqu, char *extra)
{
	struct ipw2100_priv *priv = libipw_priv(dev);
	u32 target_rate = wrqu->bitrate.value;
	u32 rate;
	int err = 0;

	mutex_lock(&priv->action_mutex);
	if (!(priv->status & STATUS_INITIALIZED)) {
		err = -EIO;
		goto done;
	}

	rate = 0;

	if (target_rate == 1000000 ||
	    (!wrqu->bitrate.fixed && target_rate > 1000000))
		rate |= TX_RATE_1_MBIT;
	if (target_rate == 2000000 ||
	    (!wrqu->bitrate.fixed && target_rate > 2000000))
		rate |= TX_RATE_2_MBIT;
	if (target_rate == 5500000 ||
	    (!wrqu->bitrate.fixed && target_rate > 5500000))
		rate |= TX_RATE_5_5_MBIT;
	if (target_rate == 11000000 ||
	    (!wrqu->bitrate.fixed && target_rate > 11000000))
		rate |= TX_RATE_11_MBIT;
	if (rate == 0)
		rate = DEFAULT_TX_RATES;

	err = ipw2100_set_tx_rates(priv, rate, 0);

	IPW_DEBUG_WX("SET Rate -> %04X\n", rate);
      done:
	mutex_unlock(&priv->action_mutex);
	return err;
}

static int ipw2100_wx_get_rate(struct net_device *dev,
			       struct iw_request_info *info,
			       union iwreq_data *wrqu, char *extra)
{
	struct ipw2100_priv *priv = libipw_priv(dev);
	int val;
	unsigned int len = sizeof(val);
	int err = 0;

	if (!(priv->status & STATUS_ENABLED) ||
	    priv->status & STATUS_RF_KILL_MASK ||
	    !(priv->status & STATUS_ASSOCIATED)) {
		wrqu->bitrate.value = 0;
		return 0;
	}

	mutex_lock(&priv->action_mutex);
	if (!(priv->status & STATUS_INITIALIZED)) {
		err = -EIO;
		goto done;
	}

	err = ipw2100_get_ordinal(priv, IPW_ORD_CURRENT_TX_RATE, &val, &len);
	if (err) {
		IPW_DEBUG_WX("failed querying ordinals.\n");
		goto done;
	}

	switch (val & TX_RATE_MASK) {
	case TX_RATE_1_MBIT:
		wrqu->bitrate.value = 1000000;
		break;
	case TX_RATE_2_MBIT:
		wrqu->bitrate.value = 2000000;
		break;
	case TX_RATE_5_5_MBIT:
		wrqu->bitrate.value = 5500000;
		break;
	case TX_RATE_11_MBIT:
		wrqu->bitrate.value = 11000000;
		break;
	default:
		wrqu->bitrate.value = 0;
	}

	IPW_DEBUG_WX("GET Rate -> %d\n", wrqu->bitrate.value);

      done:
	mutex_unlock(&priv->action_mutex);
	return err;
}

static int ipw2100_wx_set_rts(struct net_device *dev,
			      struct iw_request_info *info,
			      union iwreq_data *wrqu, char *extra)
{
	struct ipw2100_priv *priv = libipw_priv(dev);
	int value, err;

	/* Auto RTS not yet supported */
	if (wrqu->rts.fixed == 0)
		return -EINVAL;

	mutex_lock(&priv->action_mutex);
	if (!(priv->status & STATUS_INITIALIZED)) {
		err = -EIO;
		goto done;
	}

	if (wrqu->rts.disabled)
		value = priv->rts_threshold | RTS_DISABLED;
	else {
		if (wrqu->rts.value < 1 || wrqu->rts.value > 2304) {
			err = -EINVAL;
			goto done;
		}
		value = wrqu->rts.value;
	}

	err = ipw2100_set_rts_threshold(priv, value);

	IPW_DEBUG_WX("SET RTS Threshold -> 0x%08X\n", value);
      done:
	mutex_unlock(&priv->action_mutex);
	return err;
}

static int ipw2100_wx_get_rts(struct net_device *dev,
			      struct iw_request_info *info,
			      union iwreq_data *wrqu, char *extra)
{
	/*
	 * This can be called at any time.  No action lock required
	 */

	struct ipw2100_priv *priv = libipw_priv(dev);

	wrqu->rts.value = priv->rts_threshold & ~RTS_DISABLED;
	wrqu->rts.fixed = 1;	/* no auto select */

	/* If RTS is set to the default value, then it is disabled */
	wrqu->rts.disabled = (priv->rts_threshold & RTS_DISABLED) ? 1 : 0;

	IPW_DEBUG_WX("GET RTS Threshold -> 0x%08X\n", wrqu->rts.value);

	return 0;
}

static int ipw2100_wx_set_txpow(struct net_device *dev,
				struct iw_request_info *info,
				union iwreq_data *wrqu, char *extra)
{
	struct ipw2100_priv *priv = libipw_priv(dev);
	int err = 0, value;
	
	if (ipw_radio_kill_sw(priv, wrqu->txpower.disabled))
		return -EINPROGRESS;

	if (priv->ieee->iw_mode != IW_MODE_ADHOC)
		return 0;

	if ((wrqu->txpower.flags & IW_TXPOW_TYPE) != IW_TXPOW_DBM)
		return -EINVAL;

	if (wrqu->txpower.fixed == 0)
		value = IPW_TX_POWER_DEFAULT;
	else {
		if (wrqu->txpower.value < IPW_TX_POWER_MIN_DBM ||
		    wrqu->txpower.value > IPW_TX_POWER_MAX_DBM)
			return -EINVAL;

		value = wrqu->txpower.value;
	}

	mutex_lock(&priv->action_mutex);
	if (!(priv->status & STATUS_INITIALIZED)) {
		err = -EIO;
		goto done;
	}

	err = ipw2100_set_tx_power(priv, value);

	IPW_DEBUG_WX("SET TX Power -> %d\n", value);

      done:
	mutex_unlock(&priv->action_mutex);
	return err;
}

static int ipw2100_wx_get_txpow(struct net_device *dev,
				struct iw_request_info *info,
				union iwreq_data *wrqu, char *extra)
{
	/*
	 * This can be called at any time.  No action lock required
	 */

	struct ipw2100_priv *priv = libipw_priv(dev);

	wrqu->txpower.disabled = (priv->status & STATUS_RF_KILL_MASK) ? 1 : 0;

	if (priv->tx_power == IPW_TX_POWER_DEFAULT) {
		wrqu->txpower.fixed = 0;
		wrqu->txpower.value = IPW_TX_POWER_MAX_DBM;
	} else {
		wrqu->txpower.fixed = 1;
		wrqu->txpower.value = priv->tx_power;
	}

	wrqu->txpower.flags = IW_TXPOW_DBM;

	IPW_DEBUG_WX("GET TX Power -> %d\n", wrqu->txpower.value);

	return 0;
}

static int ipw2100_wx_set_frag(struct net_device *dev,
			       struct iw_request_info *info,
			       union iwreq_data *wrqu, char *extra)
{
	/*
	 * This can be called at any time.  No action lock required
	 */

	struct ipw2100_priv *priv = libipw_priv(dev);

	if (!wrqu->frag.fixed)
		return -EINVAL;

	if (wrqu->frag.disabled) {
		priv->frag_threshold |= FRAG_DISABLED;
		priv->ieee->fts = DEFAULT_FTS;
	} else {
		if (wrqu->frag.value < MIN_FRAG_THRESHOLD ||
		    wrqu->frag.value > MAX_FRAG_THRESHOLD)
			return -EINVAL;

		priv->ieee->fts = wrqu->frag.value & ~0x1;
		priv->frag_threshold = priv->ieee->fts;
	}

	IPW_DEBUG_WX("SET Frag Threshold -> %d\n", priv->ieee->fts);

	return 0;
}

static int ipw2100_wx_get_frag(struct net_device *dev,
			       struct iw_request_info *info,
			       union iwreq_data *wrqu, char *extra)
{
	/*
	 * This can be called at any time.  No action lock required
	 */

	struct ipw2100_priv *priv = libipw_priv(dev);
	wrqu->frag.value = priv->frag_threshold & ~FRAG_DISABLED;
	wrqu->frag.fixed = 0;	/* no auto select */
	wrqu->frag.disabled = (priv->frag_threshold & FRAG_DISABLED) ? 1 : 0;

	IPW_DEBUG_WX("GET Frag Threshold -> %d\n", wrqu->frag.value);

	return 0;
}

static int ipw2100_wx_set_retry(struct net_device *dev,
				struct iw_request_info *info,
				union iwreq_data *wrqu, char *extra)
{
	struct ipw2100_priv *priv = libipw_priv(dev);
	int err = 0;

	if (wrqu->retry.flags & IW_RETRY_LIFETIME || wrqu->retry.disabled)
		return -EINVAL;

	if (!(wrqu->retry.flags & IW_RETRY_LIMIT))
		return 0;

	mutex_lock(&priv->action_mutex);
	if (!(priv->status & STATUS_INITIALIZED)) {
		err = -EIO;
		goto done;
	}

	if (wrqu->retry.flags & IW_RETRY_SHORT) {
		err = ipw2100_set_short_retry(priv, wrqu->retry.value);
		IPW_DEBUG_WX("SET Short Retry Limit -> %d\n",
			     wrqu->retry.value);
		goto done;
	}

	if (wrqu->retry.flags & IW_RETRY_LONG) {
		err = ipw2100_set_long_retry(priv, wrqu->retry.value);
		IPW_DEBUG_WX("SET Long Retry Limit -> %d\n",
			     wrqu->retry.value);
		goto done;
	}

	err = ipw2100_set_short_retry(priv, wrqu->retry.value);
	if (!err)
		err = ipw2100_set_long_retry(priv, wrqu->retry.value);

	IPW_DEBUG_WX("SET Both Retry Limits -> %d\n", wrqu->retry.value);

      done:
	mutex_unlock(&priv->action_mutex);
	return err;
}

static int ipw2100_wx_get_retry(struct net_device *dev,
				struct iw_request_info *info,
				union iwreq_data *wrqu, char *extra)
{
	/*
	 * This can be called at any time.  No action lock required
	 */

	struct ipw2100_priv *priv = libipw_priv(dev);

	wrqu->retry.disabled = 0;	/* can't be disabled */

	if ((wrqu->retry.flags & IW_RETRY_TYPE) == IW_RETRY_LIFETIME)
		return -EINVAL;

	if (wrqu->retry.flags & IW_RETRY_LONG) {
		wrqu->retry.flags = IW_RETRY_LIMIT | IW_RETRY_LONG;
		wrqu->retry.value = priv->long_retry_limit;
	} else {
		wrqu->retry.flags =
		    (priv->short_retry_limit !=
		     priv->long_retry_limit) ?
		    IW_RETRY_LIMIT | IW_RETRY_SHORT : IW_RETRY_LIMIT;

		wrqu->retry.value = priv->short_retry_limit;
	}

	IPW_DEBUG_WX("GET Retry -> %d\n", wrqu->retry.value);

	return 0;
}

static int ipw2100_wx_set_scan(struct net_device *dev,
			       struct iw_request_info *info,
			       union iwreq_data *wrqu, char *extra)
{
	struct ipw2100_priv *priv = libipw_priv(dev);
	int err = 0;

	mutex_lock(&priv->action_mutex);
	if (!(priv->status & STATUS_INITIALIZED)) {
		err = -EIO;
		goto done;
	}

	IPW_DEBUG_WX("Initiating scan...\n");

	priv->user_requested_scan = 1;
	if (ipw2100_set_scan_options(priv) || ipw2100_start_scan(priv)) {
		IPW_DEBUG_WX("Start scan failed.\n");

		/* TODO: Mark a scan as pending so when hardware initialized
		 *       a scan starts */
	}

      done:
	mutex_unlock(&priv->action_mutex);
	return err;
}

static int ipw2100_wx_get_scan(struct net_device *dev,
			       struct iw_request_info *info,
			       union iwreq_data *wrqu, char *extra)
{
	/*
	 * This can be called at any time.  No action lock required
	 */

	struct ipw2100_priv *priv = libipw_priv(dev);
	return libipw_wx_get_scan(priv->ieee, info, wrqu, extra);
}

/*
 * Implementation based on code in hostap-driver v0.1.3 hostap_ioctl.c
 */
static int ipw2100_wx_set_encode(struct net_device *dev,
				 struct iw_request_info *info,
				 union iwreq_data *wrqu, char *key)
{
	/*
	 * No check of STATUS_INITIALIZED required
	 */

	struct ipw2100_priv *priv = libipw_priv(dev);
	return libipw_wx_set_encode(priv->ieee, info, wrqu, key);
}

static int ipw2100_wx_get_encode(struct net_device *dev,
				 struct iw_request_info *info,
				 union iwreq_data *wrqu, char *key)
{
	/*
	 * This can be called at any time.  No action lock required
	 */

	struct ipw2100_priv *priv = libipw_priv(dev);
	return libipw_wx_get_encode(priv->ieee, info, wrqu, key);
}

static int ipw2100_wx_set_power(struct net_device *dev,
				struct iw_request_info *info,
				union iwreq_data *wrqu, char *extra)
{
	struct ipw2100_priv *priv = libipw_priv(dev);
	int err = 0;

	mutex_lock(&priv->action_mutex);
	if (!(priv->status & STATUS_INITIALIZED)) {
		err = -EIO;
		goto done;
	}

	if (wrqu->power.disabled) {
		priv->power_mode = IPW_POWER_LEVEL(priv->power_mode);
		err = ipw2100_set_power_mode(priv, IPW_POWER_MODE_CAM);
		IPW_DEBUG_WX("SET Power Management Mode -> off\n");
		goto done;
	}

	switch (wrqu->power.flags & IW_POWER_MODE) {
	case IW_POWER_ON:	/* If not specified */
	case IW_POWER_MODE:	/* If set all mask */
	case IW_POWER_ALL_R:	/* If explicitly state all */
		break;
	default:		/* Otherwise we don't support it */
		IPW_DEBUG_WX("SET PM Mode: %X not supported.\n",
			     wrqu->power.flags);
		err = -EOPNOTSUPP;
		goto done;
	}

	/* If the user hasn't specified a power management mode yet, default
	 * to BATTERY */
	priv->power_mode = IPW_POWER_ENABLED | priv->power_mode;
	err = ipw2100_set_power_mode(priv, IPW_POWER_LEVEL(priv->power_mode));

	IPW_DEBUG_WX("SET Power Management Mode -> 0x%02X\n", priv->power_mode);

      done:
	mutex_unlock(&priv->action_mutex);
	return err;

}

static int ipw2100_wx_get_power(struct net_device *dev,
				struct iw_request_info *info,
				union iwreq_data *wrqu, char *extra)
{
	/*
	 * This can be called at any time.  No action lock required
	 */

	struct ipw2100_priv *priv = libipw_priv(dev);

	if (!(priv->power_mode & IPW_POWER_ENABLED))
		wrqu->power.disabled = 1;
	else {
		wrqu->power.disabled = 0;
		wrqu->power.flags = 0;
	}

	IPW_DEBUG_WX("GET Power Management Mode -> %02X\n", priv->power_mode);

	return 0;
}

/*
 * WE-18 WPA support
 */

/* SIOCSIWGENIE */
static int ipw2100_wx_set_genie(struct net_device *dev,
				struct iw_request_info *info,
				union iwreq_data *wrqu, char *extra)
{

	struct ipw2100_priv *priv = libipw_priv(dev);
	struct libipw_device *ieee = priv->ieee;
	u8 *buf;

	if (!ieee->wpa_enabled)
		return -EOPNOTSUPP;

	if (wrqu->data.length > MAX_WPA_IE_LEN ||
	    (wrqu->data.length && extra == NULL))
		return -EINVAL;

	if (wrqu->data.length) {
		buf = kmemdup(extra, wrqu->data.length, GFP_KERNEL);
		if (buf == NULL)
			return -ENOMEM;

		kfree(ieee->wpa_ie);
		ieee->wpa_ie = buf;
		ieee->wpa_ie_len = wrqu->data.length;
	} else {
		kfree(ieee->wpa_ie);
		ieee->wpa_ie = NULL;
		ieee->wpa_ie_len = 0;
	}

	ipw2100_wpa_assoc_frame(priv, ieee->wpa_ie, ieee->wpa_ie_len);

	return 0;
}

/* SIOCGIWGENIE */
static int ipw2100_wx_get_genie(struct net_device *dev,
				struct iw_request_info *info,
				union iwreq_data *wrqu, char *extra)
{
	struct ipw2100_priv *priv = libipw_priv(dev);
	struct libipw_device *ieee = priv->ieee;

	if (ieee->wpa_ie_len == 0 || ieee->wpa_ie == NULL) {
		wrqu->data.length = 0;
		return 0;
	}

	if (wrqu->data.length < ieee->wpa_ie_len)
		return -E2BIG;

	wrqu->data.length = ieee->wpa_ie_len;
	memcpy(extra, ieee->wpa_ie, ieee->wpa_ie_len);

	return 0;
}

/* SIOCSIWAUTH */
static int ipw2100_wx_set_auth(struct net_device *dev,
			       struct iw_request_info *info,
			       union iwreq_data *wrqu, char *extra)
{
	struct ipw2100_priv *priv = libipw_priv(dev);
	struct libipw_device *ieee = priv->ieee;
	struct iw_param *param = &wrqu->param;
	struct lib80211_crypt_data *crypt;
	unsigned long flags;
	int ret = 0;

	switch (param->flags & IW_AUTH_INDEX) {
	case IW_AUTH_WPA_VERSION:
	case IW_AUTH_CIPHER_PAIRWISE:
	case IW_AUTH_CIPHER_GROUP:
	case IW_AUTH_KEY_MGMT:
		/*
		 * ipw2200 does not use these parameters
		 */
		break;

	case IW_AUTH_TKIP_COUNTERMEASURES:
		crypt = priv->ieee->crypt_info.crypt[priv->ieee->crypt_info.tx_keyidx];
		if (!crypt || !crypt->ops->set_flags || !crypt->ops->get_flags)
			break;

		flags = crypt->ops->get_flags(crypt->priv);

		if (param->value)
			flags |= IEEE80211_CRYPTO_TKIP_COUNTERMEASURES;
		else
			flags &= ~IEEE80211_CRYPTO_TKIP_COUNTERMEASURES;

		crypt->ops->set_flags(flags, crypt->priv);

		break;

	case IW_AUTH_DROP_UNENCRYPTED:{
			/* HACK:
			 *
			 * wpa_supplicant calls set_wpa_enabled when the driver
			 * is loaded and unloaded, regardless of if WPA is being
			 * used.  No other calls are made which can be used to
			 * determine if encryption will be used or not prior to
			 * association being expected.  If encryption is not being
			 * used, drop_unencrypted is set to false, else true -- we
			 * can use this to determine if the CAP_PRIVACY_ON bit should
			 * be set.
			 */
			struct libipw_security sec = {
				.flags = SEC_ENABLED,
				.enabled = param->value,
			};
			priv->ieee->drop_unencrypted = param->value;
			/* We only change SEC_LEVEL for open mode. Others
			 * are set by ipw_wpa_set_encryption.
			 */
			if (!param->value) {
				sec.flags |= SEC_LEVEL;
				sec.level = SEC_LEVEL_0;
			} else {
				sec.flags |= SEC_LEVEL;
				sec.level = SEC_LEVEL_1;
			}
			if (priv->ieee->set_security)
				priv->ieee->set_security(priv->ieee->dev, &sec);
			break;
		}

	case IW_AUTH_80211_AUTH_ALG:
		ret = ipw2100_wpa_set_auth_algs(priv, param->value);
		break;

	case IW_AUTH_WPA_ENABLED:
		ret = ipw2100_wpa_enable(priv, param->value);
		break;

	case IW_AUTH_RX_UNENCRYPTED_EAPOL:
		ieee->ieee802_1x = param->value;
		break;

		//case IW_AUTH_ROAMING_CONTROL:
	case IW_AUTH_PRIVACY_INVOKED:
		ieee->privacy_invoked = param->value;
		break;

	default:
		return -EOPNOTSUPP;
	}
	return ret;
}

/* SIOCGIWAUTH */
static int ipw2100_wx_get_auth(struct net_device *dev,
			       struct iw_request_info *info,
			       union iwreq_data *wrqu, char *extra)
{
	struct ipw2100_priv *priv = libipw_priv(dev);
	struct libipw_device *ieee = priv->ieee;
	struct lib80211_crypt_data *crypt;
	struct iw_param *param = &wrqu->param;

	switch (param->flags & IW_AUTH_INDEX) {
	case IW_AUTH_WPA_VERSION:
	case IW_AUTH_CIPHER_PAIRWISE:
	case IW_AUTH_CIPHER_GROUP:
	case IW_AUTH_KEY_MGMT:
		/*
		 * wpa_supplicant will control these internally
		 */
		break;

	case IW_AUTH_TKIP_COUNTERMEASURES:
		crypt = priv->ieee->crypt_info.crypt[priv->ieee->crypt_info.tx_keyidx];
		if (!crypt || !crypt->ops->get_flags) {
			IPW_DEBUG_WARNING("Can't get TKIP countermeasures: "
					  "crypt not set!\n");
			break;
		}

		param->value = (crypt->ops->get_flags(crypt->priv) &
				IEEE80211_CRYPTO_TKIP_COUNTERMEASURES) ? 1 : 0;

		break;

	case IW_AUTH_DROP_UNENCRYPTED:
		param->value = ieee->drop_unencrypted;
		break;

	case IW_AUTH_80211_AUTH_ALG:
		param->value = priv->ieee->sec.auth_mode;
		break;

	case IW_AUTH_WPA_ENABLED:
		param->value = ieee->wpa_enabled;
		break;

	case IW_AUTH_RX_UNENCRYPTED_EAPOL:
		param->value = ieee->ieee802_1x;
		break;

	case IW_AUTH_ROAMING_CONTROL:
	case IW_AUTH_PRIVACY_INVOKED:
		param->value = ieee->privacy_invoked;
		break;

	default:
		return -EOPNOTSUPP;
	}
	return 0;
}

/* SIOCSIWENCODEEXT */
static int ipw2100_wx_set_encodeext(struct net_device *dev,
				    struct iw_request_info *info,
				    union iwreq_data *wrqu, char *extra)
{
	struct ipw2100_priv *priv = libipw_priv(dev);
	return libipw_wx_set_encodeext(priv->ieee, info, wrqu, extra);
}

/* SIOCGIWENCODEEXT */
static int ipw2100_wx_get_encodeext(struct net_device *dev,
				    struct iw_request_info *info,
				    union iwreq_data *wrqu, char *extra)
{
	struct ipw2100_priv *priv = libipw_priv(dev);
	return libipw_wx_get_encodeext(priv->ieee, info, wrqu, extra);
}

/* SIOCSIWMLME */
static int ipw2100_wx_set_mlme(struct net_device *dev,
			       struct iw_request_info *info,
			       union iwreq_data *wrqu, char *extra)
{
	struct ipw2100_priv *priv = libipw_priv(dev);
	struct iw_mlme *mlme = (struct iw_mlme *)extra;

	switch (mlme->cmd) {
	case IW_MLME_DEAUTH:
		// silently ignore
		break;

	case IW_MLME_DISASSOC:
		ipw2100_disassociate_bssid(priv);
		break;

	default:
		return -EOPNOTSUPP;
	}
	return 0;
}

/*
 *
 * IWPRIV handlers
 *
 */
#ifdef CONFIG_IPW2100_MONITOR
static int ipw2100_wx_set_promisc(struct net_device *dev,
				  struct iw_request_info *info,
				  union iwreq_data *wrqu, char *extra)
{
	struct ipw2100_priv *priv = libipw_priv(dev);
	int *parms = (int *)extra;
	int enable = (parms[0] > 0);
	int err = 0;

	mutex_lock(&priv->action_mutex);
	if (!(priv->status & STATUS_INITIALIZED)) {
		err = -EIO;
		goto done;
	}

	if (enable) {
		if (priv->ieee->iw_mode == IW_MODE_MONITOR) {
			err = ipw2100_set_channel(priv, parms[1], 0);
			goto done;
		}
		priv->channel = parms[1];
		err = ipw2100_switch_mode(priv, IW_MODE_MONITOR);
	} else {
		if (priv->ieee->iw_mode == IW_MODE_MONITOR)
			err = ipw2100_switch_mode(priv, priv->last_mode);
	}
      done:
	mutex_unlock(&priv->action_mutex);
	return err;
}

static int ipw2100_wx_reset(struct net_device *dev,
			    struct iw_request_info *info,
			    union iwreq_data *wrqu, char *extra)
{
	struct ipw2100_priv *priv = libipw_priv(dev);
	if (priv->status & STATUS_INITIALIZED)
		schedule_reset(priv);
	return 0;
}

#endif

static int ipw2100_wx_set_powermode(struct net_device *dev,
				    struct iw_request_info *info,
				    union iwreq_data *wrqu, char *extra)
{
	struct ipw2100_priv *priv = libipw_priv(dev);
	int err = 0, mode = *(int *)extra;

	mutex_lock(&priv->action_mutex);
	if (!(priv->status & STATUS_INITIALIZED)) {
		err = -EIO;
		goto done;
	}

	if ((mode < 0) || (mode > POWER_MODES))
		mode = IPW_POWER_AUTO;

	if (IPW_POWER_LEVEL(priv->power_mode) != mode)
		err = ipw2100_set_power_mode(priv, mode);
      done:
	mutex_unlock(&priv->action_mutex);
	return err;
}

#define MAX_POWER_STRING 80
static int ipw2100_wx_get_powermode(struct net_device *dev,
				    struct iw_request_info *info,
				    union iwreq_data *wrqu, char *extra)
{
	/*
	 * This can be called at any time.  No action lock required
	 */

	struct ipw2100_priv *priv = libipw_priv(dev);
	int level = IPW_POWER_LEVEL(priv->power_mode);
	s32 timeout, period;

	if (!(priv->power_mode & IPW_POWER_ENABLED)) {
		snprintf(extra, MAX_POWER_STRING,
			 "Power save level: %d (Off)", level);
	} else {
		switch (level) {
		case IPW_POWER_MODE_CAM:
			snprintf(extra, MAX_POWER_STRING,
				 "Power save level: %d (None)", level);
			break;
		case IPW_POWER_AUTO:
			snprintf(extra, MAX_POWER_STRING,
				 "Power save level: %d (Auto)", level);
			break;
		default:
			timeout = timeout_duration[level - 1] / 1000;
			period = period_duration[level - 1] / 1000;
			snprintf(extra, MAX_POWER_STRING,
				 "Power save level: %d "
				 "(Timeout %dms, Period %dms)",
				 level, timeout, period);
		}
	}

	wrqu->data.length = strlen(extra) + 1;

	return 0;
}

static int ipw2100_wx_set_preamble(struct net_device *dev,
				   struct iw_request_info *info,
				   union iwreq_data *wrqu, char *extra)
{
	struct ipw2100_priv *priv = libipw_priv(dev);
	int err, mode = *(int *)extra;

	mutex_lock(&priv->action_mutex);
	if (!(priv->status & STATUS_INITIALIZED)) {
		err = -EIO;
		goto done;
	}

	if (mode == 1)
		priv->config |= CFG_LONG_PREAMBLE;
	else if (mode == 0)
		priv->config &= ~CFG_LONG_PREAMBLE;
	else {
		err = -EINVAL;
		goto done;
	}

	err = ipw2100_system_config(priv, 0);

      done:
	mutex_unlock(&priv->action_mutex);
	return err;
}

static int ipw2100_wx_get_preamble(struct net_device *dev,
				   struct iw_request_info *info,
				   union iwreq_data *wrqu, char *extra)
{
	/*
	 * This can be called at any time.  No action lock required
	 */

	struct ipw2100_priv *priv = libipw_priv(dev);

	if (priv->config & CFG_LONG_PREAMBLE)
		snprintf(wrqu->name, IFNAMSIZ, "long (1)");
	else
		snprintf(wrqu->name, IFNAMSIZ, "auto (0)");

	return 0;
}

#ifdef CONFIG_IPW2100_MONITOR
static int ipw2100_wx_set_crc_check(struct net_device *dev,
				    struct iw_request_info *info,
				    union iwreq_data *wrqu, char *extra)
{
	struct ipw2100_priv *priv = libipw_priv(dev);
	int err, mode = *(int *)extra;

	mutex_lock(&priv->action_mutex);
	if (!(priv->status & STATUS_INITIALIZED)) {
		err = -EIO;
		goto done;
	}

	if (mode == 1)
		priv->config |= CFG_CRC_CHECK;
	else if (mode == 0)
		priv->config &= ~CFG_CRC_CHECK;
	else {
		err = -EINVAL;
		goto done;
	}
	err = 0;

      done:
	mutex_unlock(&priv->action_mutex);
	return err;
}

static int ipw2100_wx_get_crc_check(struct net_device *dev,
				    struct iw_request_info *info,
				    union iwreq_data *wrqu, char *extra)
{
	/*
	 * This can be called at any time.  No action lock required
	 */

	struct ipw2100_priv *priv = libipw_priv(dev);

	if (priv->config & CFG_CRC_CHECK)
		snprintf(wrqu->name, IFNAMSIZ, "CRC checked (1)");
	else
		snprintf(wrqu->name, IFNAMSIZ, "CRC ignored (0)");

	return 0;
}
#endif				/* CONFIG_IPW2100_MONITOR */

static iw_handler ipw2100_wx_handlers[] = {
	IW_HANDLER(SIOCGIWNAME, ipw2100_wx_get_name),
	IW_HANDLER(SIOCSIWFREQ, ipw2100_wx_set_freq),
	IW_HANDLER(SIOCGIWFREQ, ipw2100_wx_get_freq),
	IW_HANDLER(SIOCSIWMODE, ipw2100_wx_set_mode),
	IW_HANDLER(SIOCGIWMODE, ipw2100_wx_get_mode),
	IW_HANDLER(SIOCGIWRANGE, ipw2100_wx_get_range),
	IW_HANDLER(SIOCSIWAP, ipw2100_wx_set_wap),
	IW_HANDLER(SIOCGIWAP, ipw2100_wx_get_wap),
	IW_HANDLER(SIOCSIWMLME, ipw2100_wx_set_mlme),
	IW_HANDLER(SIOCSIWSCAN, ipw2100_wx_set_scan),
	IW_HANDLER(SIOCGIWSCAN, ipw2100_wx_get_scan),
	IW_HANDLER(SIOCSIWESSID, ipw2100_wx_set_essid),
	IW_HANDLER(SIOCGIWESSID, ipw2100_wx_get_essid),
	IW_HANDLER(SIOCSIWNICKN, ipw2100_wx_set_nick),
	IW_HANDLER(SIOCGIWNICKN, ipw2100_wx_get_nick),
	IW_HANDLER(SIOCSIWRATE, ipw2100_wx_set_rate),
	IW_HANDLER(SIOCGIWRATE, ipw2100_wx_get_rate),
	IW_HANDLER(SIOCSIWRTS, ipw2100_wx_set_rts),
	IW_HANDLER(SIOCGIWRTS, ipw2100_wx_get_rts),
	IW_HANDLER(SIOCSIWFRAG, ipw2100_wx_set_frag),
	IW_HANDLER(SIOCGIWFRAG, ipw2100_wx_get_frag),
	IW_HANDLER(SIOCSIWTXPOW, ipw2100_wx_set_txpow),
	IW_HANDLER(SIOCGIWTXPOW, ipw2100_wx_get_txpow),
	IW_HANDLER(SIOCSIWRETRY, ipw2100_wx_set_retry),
	IW_HANDLER(SIOCGIWRETRY, ipw2100_wx_get_retry),
	IW_HANDLER(SIOCSIWENCODE, ipw2100_wx_set_encode),
	IW_HANDLER(SIOCGIWENCODE, ipw2100_wx_get_encode),
	IW_HANDLER(SIOCSIWPOWER, ipw2100_wx_set_power),
	IW_HANDLER(SIOCGIWPOWER, ipw2100_wx_get_power),
	IW_HANDLER(SIOCSIWGENIE, ipw2100_wx_set_genie),
	IW_HANDLER(SIOCGIWGENIE, ipw2100_wx_get_genie),
	IW_HANDLER(SIOCSIWAUTH, ipw2100_wx_set_auth),
	IW_HANDLER(SIOCGIWAUTH, ipw2100_wx_get_auth),
	IW_HANDLER(SIOCSIWENCODEEXT, ipw2100_wx_set_encodeext),
	IW_HANDLER(SIOCGIWENCODEEXT, ipw2100_wx_get_encodeext),
};

#define IPW2100_PRIV_SET_MONITOR	SIOCIWFIRSTPRIV
#define IPW2100_PRIV_RESET		SIOCIWFIRSTPRIV+1
#define IPW2100_PRIV_SET_POWER		SIOCIWFIRSTPRIV+2
#define IPW2100_PRIV_GET_POWER		SIOCIWFIRSTPRIV+3
#define IPW2100_PRIV_SET_LONGPREAMBLE	SIOCIWFIRSTPRIV+4
#define IPW2100_PRIV_GET_LONGPREAMBLE	SIOCIWFIRSTPRIV+5
#define IPW2100_PRIV_SET_CRC_CHECK	SIOCIWFIRSTPRIV+6
#define IPW2100_PRIV_GET_CRC_CHECK	SIOCIWFIRSTPRIV+7

static const struct iw_priv_args ipw2100_private_args[] = {

#ifdef CONFIG_IPW2100_MONITOR
	{
	 IPW2100_PRIV_SET_MONITOR,
	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, 0, "monitor"},
	{
	 IPW2100_PRIV_RESET,
	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 0, 0, "reset"},
#endif				/* CONFIG_IPW2100_MONITOR */

	{
	 IPW2100_PRIV_SET_POWER,
	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "set_power"},
	{
	 IPW2100_PRIV_GET_POWER,
	 0, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | MAX_POWER_STRING,
	 "get_power"},
	{
	 IPW2100_PRIV_SET_LONGPREAMBLE,
	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "set_preamble"},
	{
	 IPW2100_PRIV_GET_LONGPREAMBLE,
	 0, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | IFNAMSIZ, "get_preamble"},
#ifdef CONFIG_IPW2100_MONITOR
	{
	 IPW2100_PRIV_SET_CRC_CHECK,
	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "set_crc_check"},
	{
	 IPW2100_PRIV_GET_CRC_CHECK,
	 0, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | IFNAMSIZ, "get_crc_check"},
#endif				/* CONFIG_IPW2100_MONITOR */
};

static iw_handler ipw2100_private_handler[] = {
#ifdef CONFIG_IPW2100_MONITOR
	ipw2100_wx_set_promisc,
	ipw2100_wx_reset,
#else				/* CONFIG_IPW2100_MONITOR */
	NULL,
	NULL,
#endif				/* CONFIG_IPW2100_MONITOR */
	ipw2100_wx_set_powermode,
	ipw2100_wx_get_powermode,
	ipw2100_wx_set_preamble,
	ipw2100_wx_get_preamble,
#ifdef CONFIG_IPW2100_MONITOR
	ipw2100_wx_set_crc_check,
	ipw2100_wx_get_crc_check,
#else				/* CONFIG_IPW2100_MONITOR */
	NULL,
	NULL,
#endif				/* CONFIG_IPW2100_MONITOR */
};

/*
 * Get wireless statistics.
 * Called by /proc/net/wireless
 * Also called by SIOCGIWSTATS
 */
static struct iw_statistics *ipw2100_wx_wireless_stats(struct net_device *dev)
{
	enum {
		POOR = 30,
		FAIR = 60,
		GOOD = 80,
		VERY_GOOD = 90,
		EXCELLENT = 95,
		PERFECT = 100
	};
	int rssi_qual;
	int tx_qual;
	int beacon_qual;
	int quality;

	struct ipw2100_priv *priv = libipw_priv(dev);
	struct iw_statistics *wstats;
	u32 rssi, tx_retries, missed_beacons, tx_failures;
	u32 ord_len = sizeof(u32);

	if (!priv)
		return (struct iw_statistics *)NULL;

	wstats = &priv->wstats;

	/* if hw is disabled, then ipw2100_get_ordinal() can't be called.
	 * ipw2100_wx_wireless_stats seems to be called before fw is
	 * initialized.  STATUS_ASSOCIATED will only be set if the hw is up
	 * and associated; if not associcated, the values are all meaningless
	 * anyway, so set them all to NULL and INVALID */
	if (!(priv->status & STATUS_ASSOCIATED)) {
		wstats->miss.beacon = 0;
		wstats->discard.retries = 0;
		wstats->qual.qual = 0;
		wstats->qual.level = 0;
		wstats->qual.noise = 0;
		wstats->qual.updated = 7;
		wstats->qual.updated |= IW_QUAL_NOISE_INVALID |
		    IW_QUAL_QUAL_INVALID | IW_QUAL_LEVEL_INVALID;
		return wstats;
	}

	if (ipw2100_get_ordinal(priv, IPW_ORD_STAT_PERCENT_MISSED_BCNS,
				&missed_beacons, &ord_len))
		goto fail_get_ordinal;

	/* If we don't have a connection the quality and level is 0 */
	if (!(priv->status & STATUS_ASSOCIATED)) {
		wstats->qual.qual = 0;
		wstats->qual.level = 0;
	} else {
		if (ipw2100_get_ordinal(priv, IPW_ORD_RSSI_AVG_CURR,
					&rssi, &ord_len))
			goto fail_get_ordinal;
		wstats->qual.level = rssi + IPW2100_RSSI_TO_DBM;
		if (rssi < 10)
			rssi_qual = rssi * POOR / 10;
		else if (rssi < 15)
			rssi_qual = (rssi - 10) * (FAIR - POOR) / 5 + POOR;
		else if (rssi < 20)
			rssi_qual = (rssi - 15) * (GOOD - FAIR) / 5 + FAIR;
		else if (rssi < 30)
			rssi_qual = (rssi - 20) * (VERY_GOOD - GOOD) /
			    10 + GOOD;
		else
			rssi_qual = (rssi - 30) * (PERFECT - VERY_GOOD) /
			    10 + VERY_GOOD;

		if (ipw2100_get_ordinal(priv, IPW_ORD_STAT_PERCENT_RETRIES,
					&tx_retries, &ord_len))
			goto fail_get_ordinal;

		if (tx_retries > 75)
			tx_qual = (90 - tx_retries) * POOR / 15;
		else if (tx_retries > 70)
			tx_qual = (75 - tx_retries) * (FAIR - POOR) / 5 + POOR;
		else if (tx_retries > 65)
			tx_qual = (70 - tx_retries) * (GOOD - FAIR) / 5 + FAIR;
		else if (tx_retries > 50)
			tx_qual = (65 - tx_retries) * (VERY_GOOD - GOOD) /
			    15 + GOOD;
		else
			tx_qual = (50 - tx_retries) *
			    (PERFECT - VERY_GOOD) / 50 + VERY_GOOD;

		if (missed_beacons > 50)
			beacon_qual = (60 - missed_beacons) * POOR / 10;
		else if (missed_beacons > 40)
			beacon_qual = (50 - missed_beacons) * (FAIR - POOR) /
			    10 + POOR;
		else if (missed_beacons > 32)
			beacon_qual = (40 - missed_beacons) * (GOOD - FAIR) /
			    18 + FAIR;
		else if (missed_beacons > 20)
			beacon_qual = (32 - missed_beacons) *
			    (VERY_GOOD - GOOD) / 20 + GOOD;
		else
			beacon_qual = (20 - missed_beacons) *
			    (PERFECT - VERY_GOOD) / 20 + VERY_GOOD;

		quality = min(tx_qual, rssi_qual);
		quality = min(beacon_qual, quality);

#ifdef CONFIG_IPW2100_DEBUG
		if (beacon_qual == quality)
			IPW_DEBUG_WX("Quality clamped by Missed Beacons\n");
		else if (tx_qual == quality)
			IPW_DEBUG_WX("Quality clamped by Tx Retries\n");
		else if (quality != 100)
			IPW_DEBUG_WX("Quality clamped by Signal Strength\n");
		else
			IPW_DEBUG_WX("Quality not clamped.\n");
#endif

		wstats->qual.qual = quality;
		wstats->qual.level = rssi + IPW2100_RSSI_TO_DBM;
	}

	wstats->qual.noise = 0;
	wstats->qual.updated = 7;
	wstats->qual.updated |= IW_QUAL_NOISE_INVALID;

	/* FIXME: this is percent and not a # */
	wstats->miss.beacon = missed_beacons;

	if (ipw2100_get_ordinal(priv, IPW_ORD_STAT_TX_FAILURES,
				&tx_failures, &ord_len))
		goto fail_get_ordinal;
	wstats->discard.retries = tx_failures;

	return wstats;

      fail_get_ordinal:
	IPW_DEBUG_WX("failed querying ordinals.\n");

	return (struct iw_statistics *)NULL;
}

static const struct iw_handler_def ipw2100_wx_handler_def = {
	.standard = ipw2100_wx_handlers,
	.num_standard = ARRAY_SIZE(ipw2100_wx_handlers),
	.num_private = ARRAY_SIZE(ipw2100_private_handler),
	.num_private_args = ARRAY_SIZE(ipw2100_private_args),
	.private = (iw_handler *) ipw2100_private_handler,
	.private_args = (struct iw_priv_args *)ipw2100_private_args,
	.get_wireless_stats = ipw2100_wx_wireless_stats,
};

static void ipw2100_wx_event_work(struct work_struct *work)
{
	struct ipw2100_priv *priv =
		container_of(work, struct ipw2100_priv, wx_event_work.work);
	union iwreq_data wrqu;
	unsigned int len = ETH_ALEN;

	if (priv->status & STATUS_STOPPING)
		return;

	mutex_lock(&priv->action_mutex);

	IPW_DEBUG_WX("enter\n");

	mutex_unlock(&priv->action_mutex);

	wrqu.ap_addr.sa_family = ARPHRD_ETHER;

	/* Fetch BSSID from the hardware */
	if (!(priv->status & (STATUS_ASSOCIATING | STATUS_ASSOCIATED)) ||
	    priv->status & STATUS_RF_KILL_MASK ||
	    ipw2100_get_ordinal(priv, IPW_ORD_STAT_ASSN_AP_BSSID,
				&priv->bssid, &len)) {
		eth_zero_addr(wrqu.ap_addr.sa_data);
	} else {
		/* We now have the BSSID, so can finish setting to the full
		 * associated state */
		memcpy(wrqu.ap_addr.sa_data, priv->bssid, ETH_ALEN);
		memcpy(priv->ieee->bssid, priv->bssid, ETH_ALEN);
		priv->status &= ~STATUS_ASSOCIATING;
		priv->status |= STATUS_ASSOCIATED;
		netif_carrier_on(priv->net_dev);
		netif_wake_queue(priv->net_dev);
	}

	if (!(priv->status & STATUS_ASSOCIATED)) {
		IPW_DEBUG_WX("Configuring ESSID\n");
		mutex_lock(&priv->action_mutex);
		/* This is a disassociation event, so kick the firmware to
		 * look for another AP */
		if (priv->config & CFG_STATIC_ESSID)
			ipw2100_set_essid(priv, priv->essid, priv->essid_len,
					  0);
		else
			ipw2100_set_essid(priv, NULL, 0, 0);
		mutex_unlock(&priv->action_mutex);
	}

	wireless_send_event(priv->net_dev, SIOCGIWAP, &wrqu, NULL);
}

#define IPW2100_FW_MAJOR_VERSION 1
#define IPW2100_FW_MINOR_VERSION 3

#define IPW2100_FW_MINOR(x) ((x & 0xff) >> 8)
#define IPW2100_FW_MAJOR(x) (x & 0xff)

#define IPW2100_FW_VERSION ((IPW2100_FW_MINOR_VERSION << 8) | \
                             IPW2100_FW_MAJOR_VERSION)

#define IPW2100_FW_PREFIX "ipw2100-" __stringify(IPW2100_FW_MAJOR_VERSION) \
"." __stringify(IPW2100_FW_MINOR_VERSION)

#define IPW2100_FW_NAME(x) IPW2100_FW_PREFIX "" x ".fw"

/*

BINARY FIRMWARE HEADER FORMAT

offset      length   desc
0           2        version
2           2        mode == 0:BSS,1:IBSS,2:MONITOR
4           4        fw_len
8           4        uc_len
C           fw_len   firmware data
12 + fw_len uc_len   microcode data

*/

struct ipw2100_fw_header {
	short version;
	short mode;
	unsigned int fw_size;
	unsigned int uc_size;
} __packed;

static int ipw2100_mod_firmware_load(struct ipw2100_fw *fw)
{
	struct ipw2100_fw_header *h =
	    (struct ipw2100_fw_header *)fw->fw_entry->data;

	if (IPW2100_FW_MAJOR(h->version) != IPW2100_FW_MAJOR_VERSION) {
		printk(KERN_WARNING DRV_NAME ": Firmware image not compatible "
		       "(detected version id of %u). "
		       "See Documentation/networking/device_drivers/intel/ipw2100.txt\n",
		       h->version);
		return 1;
	}

	fw->version = h->version;
	fw->fw.data = fw->fw_entry->data + sizeof(struct ipw2100_fw_header);
	fw->fw.size = h->fw_size;
	fw->uc.data = fw->fw.data + h->fw_size;
	fw->uc.size = h->uc_size;

	return 0;
}

static int ipw2100_get_firmware(struct ipw2100_priv *priv,
				struct ipw2100_fw *fw)
{
	char *fw_name;
	int rc;

	IPW_DEBUG_INFO("%s: Using hotplug firmware load.\n",
		       priv->net_dev->name);

	switch (priv->ieee->iw_mode) {
	case IW_MODE_ADHOC:
		fw_name = IPW2100_FW_NAME("-i");
		break;
#ifdef CONFIG_IPW2100_MONITOR
	case IW_MODE_MONITOR:
		fw_name = IPW2100_FW_NAME("-p");
		break;
#endif
	case IW_MODE_INFRA:
	default:
		fw_name = IPW2100_FW_NAME("");
		break;
	}

	rc = request_firmware(&fw->fw_entry, fw_name, &priv->pci_dev->dev);

	if (rc < 0) {
		printk(KERN_ERR DRV_NAME ": "
		       "%s: Firmware '%s' not available or load failed.\n",
		       priv->net_dev->name, fw_name);
		return rc;
	}
	IPW_DEBUG_INFO("firmware data %p size %zd\n", fw->fw_entry->data,
		       fw->fw_entry->size);

	ipw2100_mod_firmware_load(fw);

	return 0;
}

MODULE_FIRMWARE(IPW2100_FW_NAME("-i"));
#ifdef CONFIG_IPW2100_MONITOR
MODULE_FIRMWARE(IPW2100_FW_NAME("-p"));
#endif
MODULE_FIRMWARE(IPW2100_FW_NAME(""));

static void ipw2100_release_firmware(struct ipw2100_priv *priv,
				     struct ipw2100_fw *fw)
{
	fw->version = 0;
	release_firmware(fw->fw_entry);
	fw->fw_entry = NULL;
}

static int ipw2100_get_fwversion(struct ipw2100_priv *priv, char *buf,
				 size_t max)
{
	char ver[MAX_FW_VERSION_LEN];
	u32 len = MAX_FW_VERSION_LEN;
	u32 tmp;
	int i;
	/* firmware version is an ascii string (max len of 14) */
	if (ipw2100_get_ordinal(priv, IPW_ORD_STAT_FW_VER_NUM, ver, &len))
		return -EIO;
	tmp = max;
	if (len >= max)
		len = max - 1;
	for (i = 0; i < len; i++)
		buf[i] = ver[i];
	buf[i] = '\0';
	return tmp;
}

static int ipw2100_get_ucodeversion(struct ipw2100_priv *priv, char *buf,
				    size_t max)
{
	u32 ver;
	u32 len = sizeof(ver);
	/* microcode version is a 32 bit integer */
	if (ipw2100_get_ordinal(priv, IPW_ORD_UCODE_VERSION, &ver, &len))
		return -EIO;
	return snprintf(buf, max, "%08X", ver);
}

/*
 * On exit, the firmware will have been freed from the fw list
 */
static int ipw2100_fw_download(struct ipw2100_priv *priv, struct ipw2100_fw *fw)
{
	/* firmware is constructed of N contiguous entries, each entry is
	 * structured as:
	 *
	 * offset    sie         desc
	 * 0         4           address to write to
	 * 4         2           length of data run
	 * 6         length      data
	 */
	unsigned int addr;
	unsigned short len;

	const unsigned char *firmware_data = fw->fw.data;
	unsigned int firmware_data_left = fw->fw.size;

	while (firmware_data_left > 0) {
		addr = *(u32 *) (firmware_data);
		firmware_data += 4;
		firmware_data_left -= 4;

		len = *(u16 *) (firmware_data);
		firmware_data += 2;
		firmware_data_left -= 2;

		if (len > 32) {
			printk(KERN_ERR DRV_NAME ": "
			       "Invalid firmware run-length of %d bytes\n",
			       len);
			return -EINVAL;
		}

		write_nic_memory(priv->net_dev, addr, len, firmware_data);
		firmware_data += len;
		firmware_data_left -= len;
	}

	return 0;
}

struct symbol_alive_response {
	u8 cmd_id;
	u8 seq_num;
	u8 ucode_rev;
	u8 eeprom_valid;
	u16 valid_flags;
	u8 IEEE_addr[6];
	u16 flags;
	u16 pcb_rev;
	u16 clock_settle_time;	// 1us LSB
	u16 powerup_settle_time;	// 1us LSB
	u16 hop_settle_time;	// 1us LSB
	u8 date[3];		// month, day, year
	u8 time[2];		// hours, minutes
	u8 ucode_valid;
};

static int ipw2100_ucode_download(struct ipw2100_priv *priv,
				  struct ipw2100_fw *fw)
{
	struct net_device *dev = priv->net_dev;
	const unsigned char *microcode_data = fw->uc.data;
	unsigned int microcode_data_left = fw->uc.size;
	void __iomem *reg = priv->ioaddr;

	struct symbol_alive_response response;
	int i, j;
	u8 data;

	/* Symbol control */
	write_nic_word(dev, IPW2100_CONTROL_REG, 0x703);
	readl(reg);
	write_nic_word(dev, IPW2100_CONTROL_REG, 0x707);
	readl(reg);

	/* HW config */
	write_nic_byte(dev, 0x210014, 0x72);	/* fifo width =16 */
	readl(reg);
	write_nic_byte(dev, 0x210014, 0x72);	/* fifo width =16 */
	readl(reg);

	/* EN_CS_ACCESS bit to reset control store pointer */
	write_nic_byte(dev, 0x210000, 0x40);
	readl(reg);
	write_nic_byte(dev, 0x210000, 0x0);
	readl(reg);
	write_nic_byte(dev, 0x210000, 0x40);
	readl(reg);

	/* copy microcode from buffer into Symbol */

	while (microcode_data_left > 0) {
		write_nic_byte(dev, 0x210010, *microcode_data++);
		write_nic_byte(dev, 0x210010, *microcode_data++);
		microcode_data_left -= 2;
	}

	/* EN_CS_ACCESS bit to reset the control store pointer */
	write_nic_byte(dev, 0x210000, 0x0);
	readl(reg);

	/* Enable System (Reg 0)
	 * first enable causes garbage in RX FIFO */
	write_nic_byte(dev, 0x210000, 0x0);
	readl(reg);
	write_nic_byte(dev, 0x210000, 0x80);
	readl(reg);

	/* Reset External Baseband Reg */
	write_nic_word(dev, IPW2100_CONTROL_REG, 0x703);
	readl(reg);
	write_nic_word(dev, IPW2100_CONTROL_REG, 0x707);
	readl(reg);

	/* HW Config (Reg 5) */
	write_nic_byte(dev, 0x210014, 0x72);	// fifo width =16
	readl(reg);
	write_nic_byte(dev, 0x210014, 0x72);	// fifo width =16
	readl(reg);

	/* Enable System (Reg 0)
	 * second enable should be OK */
	write_nic_byte(dev, 0x210000, 0x00);	// clear enable system
	readl(reg);
	write_nic_byte(dev, 0x210000, 0x80);	// set enable system

	/* check Symbol is enabled - upped this from 5 as it wasn't always
	 * catching the update */
	for (i = 0; i < 10; i++) {
		udelay(10);

		/* check Dino is enabled bit */
		read_nic_byte(dev, 0x210000, &data);
		if (data & 0x1)
			break;
	}

	if (i == 10) {
		printk(KERN_ERR DRV_NAME ": %s: Error initializing Symbol\n",
		       dev->name);
		return -EIO;
	}

	/* Get Symbol alive response */
	for (i = 0; i < 30; i++) {
		/* Read alive response structure */
		for (j = 0;
		     j < (sizeof(struct symbol_alive_response) >> 1); j++)
			read_nic_word(dev, 0x210004, ((u16 *) & response) + j);

		if ((response.cmd_id == 1) && (response.ucode_valid == 0x1))
			break;
		udelay(10);
	}

	if (i == 30) {
		printk(KERN_ERR DRV_NAME
		       ": %s: No response from Symbol - hw not alive\n",
		       dev->name);
		printk_buf(IPW_DL_ERROR, (u8 *) & response, sizeof(response));
		return -EIO;
	}

	return 0;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
 *  Player - One Hell of a Robot Server
 *  Copyright (C) 2000  Brian Gerkey   &  Kasper Stoy
 *                      gerkey@usc.edu    kaspers@robotics.usc.edu
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

#include <queue>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include "amcl/map/map.h"

class CellData
{
  public:
    map_t* map_;
    unsigned int i_, j_;
    unsigned int src_i_, src_j_;
};

class CachedDistanceMap
{
  public:
    CachedDistanceMap(double scale, double max_dist) : 
      distances_(NULL), scale_(scale), max_dist_(max_dist) 
    {
      cell_radius_ = max_dist / scale;
      distances_ = new double *[cell_radius_+2];
      for(int i=0; i<=cell_radius_+1; i++)
      {
	distances_[i] = new double[cell_radius_+2];
        for(int j=0; j<=cell_radius_+1; j++)
	{
	  distances_[i][j] = sqrt(i*i + j*j);
	}
      }
    }
    ~CachedDistanceMap()
    {
      if(distances_)
      {
	for(int i=0; i<=cell_radius_+1; i++)
	  delete[] distances_[i];
	delete[] distances_;
      }
    }
    double** distances_;
    double scale_;
    double max_dist_;
    int cell_radius_;
};


bool operator<(const CellData& a, const CellData& b)
{
  return a.map_->cells[MAP_INDEX(a.map_, a.i_, a.j_)].occ_dist > a.map_->cells[MAP_INDEX(b.map_, b.i_, b.j_)].occ_dist;
}

CachedDistanceMap*
get_distance_map(double scale, double max_dist)
{
  static CachedDistanceMap* cdm = NULL;

  if(!cdm || (cdm->scale_ != scale) || (cdm->max_dist_ != max_dist))
  {
    if(cdm)
      delete cdm;
    cdm = new CachedDistanceMap(scale, max_dist);
  }

  return cdm;
}

void enqueue(map_t* map, int i, int j,
	     int src_i, int src_j,
	     std::priority_queue<CellData>& Q,
	     CachedDistanceMap* cdm,
	     unsigned char* marked)
{
  if(marked[MAP_INDEX(map, i, j)])
    return;

  int di = abs(i - src_i);
  int dj = abs(j - src_j);
  double distance = cdm->distances_[di][dj];

  if(distance > cdm->cell_radius_)
    return;

  map->cells[MAP_INDEX(map, i, j)].occ_dist = distance * map->scale;

  CellData cell;
  cell.map_ = map;
  cell.i_ = i;
  cell.j_ = j;
  cell.src_i_ = src_i;
  cell.src_j_ = src_j;

  Q.push(cell);

  marked[MAP_INDEX(map, i, j)] = 1;
}

// Update the cspace distance values
void map_update_cspace(map_t *map, double max_occ_dist)
{
  unsigned char* marked;
  std::priority_queue<CellData> Q;

  marked = new unsigned char[map->size_x*map->size_y];
  memset(marked, 0, sizeof(unsigned char) * map->size_x*map->size_y);

  map->max_occ_dist = max_occ_dist;

  CachedDistanceMap* cdm = get_distance_map(map->scale, map->max_occ_dist);

  // Enqueue all the obstacle cells
  CellData cell;
  cell.map_ = map;
  for(int i=0; i<map->size_x; i++)
  {
    cell.src_i_ = cell.i_ = i;
    for(int j=0; j<map->size_y; j++)
    {
      if(map->cells[MAP_INDEX(map, i, j)].occ_state == +1)
      {
	map->cells[MAP_INDEX(map, i, j)].occ_dist = 0.0;
	cell.src_j_ = cell.j_ = j;
	marked[MAP_INDEX(map, i, j)] = 1;
	Q.push(cell);
      }
      else
	map->cells[MAP_INDEX(map, i, j)].occ_dist = max_occ_dist;
    }
  }

  while(!Q.empty())
  {
    CellData current_cell = Q.top();
    if(current_cell.i_ > 0)
      enqueue(map, current_cell.i_-1, current_cell.j_, 
	      current_cell.src_i_, current_cell.src_j_,
	      Q, cdm, marked);
    if(current_cell.j_ > 0)
      enqueue(map, current_cell.i_, current_cell.j_-1, 
	      current_cell.src_i_, current_cell.src_j_,
	      Q, cdm, marked);
    if((int)current_cell.i_ < map->size_x - 1)
      enqueue(map, current_cell.i_+1, current_cell.j_, 
	      current_cell.src_i_, current_cell.src_j_,
	      Q, cdm, marked);
    if((int)current_cell.j_ < map->size_y - 1)
      enqueue(map, current_cell.i_, current_cell.j_+1, 
	      current_cell.src_i_, current_cell.src_j_,
	      Q, cdm, marked);

    Q.pop();
  }

  delete[] marked;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><title>Python: module telemetry.internal.browser.browser_finder</title>
<meta charset="utf-8">
</head><body bgcolor="#f0f0f8">

<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="heading">
<tr bgcolor="#7799ee">
<td valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial">&nbsp;<br><big><big><strong><a href="telemetry.html"><font color="#ffffff">telemetry</font></a>.<a href="telemetry.internal.html"><font color="#ffffff">internal</font></a>.<a href="telemetry.internal.browser.html"><font color="#ffffff">browser</font></a>.browser_finder</strong></big></big></font></td
><td align=right valign=bottom
><font color="#ffffff" face="helvetica, arial"><a href=".">index</a><br><a href="../telemetry/internal/browser/browser_finder.py">telemetry/internal/browser/browser_finder.py</a></font></td></tr></table>
    <p><tt>Finds&nbsp;browsers&nbsp;that&nbsp;can&nbsp;be&nbsp;controlled&nbsp;by&nbsp;telemetry.</tt></p>
<p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#aa55cc">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Modules</strong></big></font></td></tr>
    
<tr><td bgcolor="#aa55cc"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><table width="100%" summary="list"><tr><td width="25%" valign=top><a href="telemetry.internal.backends.chrome.android_browser_finder.html">telemetry.internal.backends.chrome.android_browser_finder</a><br>
<a href="telemetry.internal.backends.mandoline.android_mandoline_finder.html">telemetry.internal.backends.mandoline.android_mandoline_finder</a><br>
<a href="telemetry.internal.browser.browser_finder_exceptions.html">telemetry.internal.browser.browser_finder_exceptions</a><br>
</td><td width="25%" valign=top><a href="telemetry.internal.backends.chrome.cros_browser_finder.html">telemetry.internal.backends.chrome.cros_browser_finder</a><br>
<a href="telemetry.decorators.html">telemetry.decorators</a><br>
<a href="telemetry.internal.backends.chrome.desktop_browser_finder.html">telemetry.internal.backends.chrome.desktop_browser_finder</a><br>
</td><td width="25%" valign=top><a href="telemetry.internal.backends.mandoline.desktop_mandoline_finder.html">telemetry.internal.backends.mandoline.desktop_mandoline_finder</a><br>
<a href="telemetry.internal.platform.device_finder.html">telemetry.internal.platform.device_finder</a><br>
<a href="telemetry.internal.backends.chrome.ios_browser_finder.html">telemetry.internal.backends.chrome.ios_browser_finder</a><br>
</td><td width="25%" valign=top><a href="logging.html">logging</a><br>
<a href="operator.html">operator</a><br>
<a href="telemetry.internal.backends.remote.trybot_browser_finder.html">telemetry.internal.backends.remote.trybot_browser_finder</a><br>
</td></tr></table></td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#eeaa77">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Functions</strong></big></font></td></tr>
    
<tr><td bgcolor="#eeaa77"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl><dt><a name="-FindAllBrowserTypes"><strong>FindAllBrowserTypes</strong></a>(options)</dt></dl>
 <dl><dt><a name="-FindBrowser"><strong>FindBrowser</strong></a>(*args, **kwargs)</dt><dd><tt>Finds&nbsp;the&nbsp;best&nbsp;PossibleBrowser&nbsp;object&nbsp;given&nbsp;a&nbsp;BrowserOptions&nbsp;object.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;A&nbsp;BrowserOptions&nbsp;object.<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;A&nbsp;PossibleBrowser&nbsp;object.<br>
&nbsp;<br>
Raises:<br>
&nbsp;&nbsp;BrowserFinderException:&nbsp;Options&nbsp;improperly&nbsp;set,&nbsp;or&nbsp;an&nbsp;error&nbsp;occurred.</tt></dd></dl>
 <dl><dt><a name="-GetAllAvailableBrowserTypes"><strong>GetAllAvailableBrowserTypes</strong></a>(*args, **kwargs)</dt><dd><tt>Returns&nbsp;a&nbsp;list&nbsp;of&nbsp;available&nbsp;browser&nbsp;types.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;options:&nbsp;A&nbsp;BrowserOptions&nbsp;object.<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;A&nbsp;list&nbsp;of&nbsp;browser&nbsp;type&nbsp;strings.<br>
&nbsp;<br>
Raises:<br>
&nbsp;&nbsp;BrowserFinderException:&nbsp;Options&nbsp;are&nbsp;improperly&nbsp;set,&nbsp;or&nbsp;an&nbsp;error&nbsp;occurred.</tt></dd></dl>
 <dl><dt><a name="-GetAllAvailableBrowsers"><strong>GetAllAvailableBrowsers</strong></a>(*args, **kwargs)</dt><dd><tt>Returns&nbsp;a&nbsp;list&nbsp;of&nbsp;available&nbsp;browsers&nbsp;on&nbsp;the&nbsp;device.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;options:&nbsp;A&nbsp;BrowserOptions&nbsp;object.<br>
&nbsp;&nbsp;device:&nbsp;The&nbsp;target&nbsp;device,&nbsp;which&nbsp;can&nbsp;be&nbsp;None.<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;A&nbsp;list&nbsp;of&nbsp;browser&nbsp;instances.<br>
&nbsp;<br>
Raises:<br>
&nbsp;&nbsp;BrowserFinderException:&nbsp;Options&nbsp;are&nbsp;improperly&nbsp;set,&nbsp;or&nbsp;an&nbsp;error&nbsp;occurred.</tt></dd></dl>
</td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#55aa55">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Data</strong></big></font></td></tr>
    
<tr><td bgcolor="#55aa55"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><strong>BROWSER_FINDERS</strong> = [&lt;module 'telemetry.internal.backends.chrome.desk...rnal/backends/chrome/desktop_browser_finder.pyc'&gt;, &lt;module 'telemetry.internal.backends.chrome.andr...rnal/backends/chrome/android_browser_finder.pyc'&gt;, &lt;module 'telemetry.internal.backends.chrome.cros...nternal/backends/chrome/cros_browser_finder.pyc'&gt;, &lt;module 'telemetry.internal.backends.chrome.ios_...internal/backends/chrome/ios_browser_finder.pyc'&gt;, &lt;module 'telemetry.internal.backends.remote.tryb...ernal/backends/remote/trybot_browser_finder.pyc'&gt;, &lt;module 'telemetry.internal.backends.mandoline.d...backends/mandoline/desktop_mandoline_finder.pyc'&gt;, &lt;module 'telemetry.internal.backends.mandoline.a...backends/mandoline/android_mandoline_finder.pyc'&gt;]</td></tr></table>
</body></html>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           // Generated by gencpp from file std_msgs/Char.msg
// DO NOT EDIT!


#ifndef STD_MSGS_MESSAGE_CHAR_H
#define STD_MSGS_MESSAGE_CHAR_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace std_msgs
{
template <class ContainerAllocator>
struct Char_
{
  typedef Char_<ContainerAllocator> Type;

  Char_()
    : data(0)  {
    }
  Char_(const ContainerAllocator& _alloc)
    : data(0)  {
  (void)_alloc;
    }



   typedef uint8_t _data_type;
  _data_type data;





  typedef boost::shared_ptr< ::std_msgs::Char_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::std_msgs::Char_<ContainerAllocator> const> ConstPtr;

}; // struct Char_

typedef ::std_msgs::Char_<std::allocator<void> > Char;

typedef boost::shared_ptr< ::std_msgs::Char > CharPtr;
typedef boost::shared_ptr< ::std_msgs::Char const> CharConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::std_msgs::Char_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::std_msgs::Char_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace std_msgs

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': True, 'IsMessage': True, 'HasHeader': False}
// {'std_msgs': ['/tmp/binarydeb/ros-kinetic-std-msgs-0.5.11/msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::std_msgs::Char_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::std_msgs::Char_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::std_msgs::Char_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::std_msgs::Char_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::std_msgs::Char_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::std_msgs::Char_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::std_msgs::Char_<ContainerAllocator> >
{
  static const char* value()
  {
    return "1bf77f25acecdedba0e224b162199717";
  }

  static const char* value(const ::std_msgs::Char_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x1bf77f25acecdedbULL;
  static const uint64_t static_value2 = 0xa0e224b162199717ULL;
};

template<class ContainerAllocator>
struct DataType< ::std_msgs::Char_<ContainerAllocator> >
{
  static const char* value()
  {
    return "std_msgs/Char";
  }

  static const char* value(const ::std_msgs::Char_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::std_msgs::Char_<ContainerAllocator> >
{
  static const char* value()
  {
    return "char data\n\
";
  }

  static const char* value(const ::std_msgs::Char_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::std_msgs::Char_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.data);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct Char_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::std_msgs::Char_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::std_msgs::Char_<ContainerAllocator>& v)
  {
    s << indent << "data: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.data);
  }
};

} // namespace message_operations
} // namespace ros

#endif // STD_MSGS_MESSAGE_CHAR_H
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #ifndef NOMINMAX
#define NOMINMAX
#endif
#include <glad/glad.h>

#include "ux-window.h"

#include "model-views.h"
#include "os.h"

// We use STB image to load the splash-screen from memory
#define STB_IMAGE_IMPLEMENTATION
#include <stb_image.h>
// int-rs-splash.hpp contains the PNG image from res/int-rs-splash.png
#include "res/int-rs-splash.hpp"
#include "res/icon.h"

#include "ux-alignment.h"

#include <opengl3.h>

#include <iostream>

namespace rs2
{
    void prepare_config_file()
    {
        config_file::instance().set_default(configurations::update::allow_rc_firmware, false);
        config_file::instance().set_default(configurations::update::recommend_calibration, true);
        config_file::instance().set_default(configurations::update::recommend_updates, true);

        config_file::instance().set_default(configurations::window::is_fullscreen, false);
        config_file::instance().set_default(configurations::window::saved_pos, false);
        config_file::instance().set_default(configurations::window::saved_size, false);

        config_file::instance().set_default(configurations::viewer::log_filename, get_folder_path(special_folder::user_documents) + "librealsense.log");
        config_file::instance().set_default(configurations::viewer::log_to_console, true);
        config_file::instance().set_default(configurations::viewer::log_to_file, false);
        config_file::instance().set_default(configurations::viewer::log_severity, 2);
        config_file::instance().set_default(configurations::viewer::metric_system, true);

        config_file::instance().set_default(configurations::record::compression_mode, 2); // Let the device decide
        config_file::instance().set_default(configurations::record::default_path, get_folder_path(special_folder::user_documents));
        config_file::instance().set_default(configurations::record::file_save_mode, 0); // Auto-select name

        config_file::instance().set_default(configurations::performance::show_fps, false);
        config_file::instance().set_default(configurations::performance::vsync, true);

        config_file::instance().set_default(configurations::ply::mesh, true);
        config_file::instance().set_default(configurations::ply::use_normals, false);
        config_file::instance().set_default(configurations::ply::encoding, configurations::ply::binary);

#ifdef __APPLE__
        config_file::instance().set_default(configurations::performance::font_oversample, 8);
        config_file::instance().set_default(configurations::performance::enable_msaa, true);
        config_file::instance().set_default(configurations::performance::msaa_samples, 4);
        // On Mac-OS, mixing OpenGL 2 with OpenGL 3 is not supported by the driver
        // while this can be worked-around, this will take more development time,
        // so for now Macs should not use the GLSL stuff
        config_file::instance().set_default(configurations::performance::glsl_for_processing, false);
        config_file::instance().set_default(configurations::performance::glsl_for_rendering, false);
#else
        auto vendor = (const char*)glGetString(GL_VENDOR);
        auto renderer = (const char*)glGetString(GL_RENDERER);
        auto version = (const char*)glGetString(GL_VERSION);
        auto glsl = (const char*)glGetString(GL_SHADING_LANGUAGE_VERSION);

        bool use_glsl = false;

        // Absolutely arbitrary list of manufacturers that are likely to benefit from GLSL optimisation
        if (starts_with(to_lower(vendor), "intel") ||
            starts_with(to_lower(vendor), "ati") ||
            starts_with(to_lower(vendor), "nvidia"))
        {
            use_glsl = true;
        }

        // Double-check that GLSL 1.3+ is supported
        if (starts_with(to_lower(vendor), "1.1") || starts_with(to_lower(vendor), "1.2"))
        {
            use_glsl = false;
        }

        if (use_glsl)
        {
            config_file::instance().set_default(configurations::performance::font_oversample, 2);
            config_file::instance().set_default(configurations::performance::enable_msaa, false);
            config_file::instance().set_default(configurations::performance::msaa_samples, 2);
            config_file::instance().set_default(configurations::performance::glsl_for_processing, true);
            config_file::instance().set_default(configurations::performance::glsl_for_rendering, true);
        }
        else
        {
            config_file::instance().set_default(configurations::performance::font_oversample, 1);
            config_file::instance().set_default(configurations::performance::enable_msaa, false);
            config_file::instance().set_default(configurations::performance::msaa_samples, 2);
            config_file::instance().set_default(configurations::performance::glsl_for_processing, false);
            config_file::instance().set_default(configurations::performance::glsl_for_rendering, false);
        }
#endif
    }

    void ux_window::reload()
    {
        _reload = true;
    }

    void ux_window::refresh()
    {
        if (_use_glsl_proc) rs2::gl::shutdown_processing();
        rs2::gl::shutdown_rendering();

        _use_glsl_render = config_file::instance().get(configurations::performance::glsl_for_rendering);
        _use_glsl_proc = config_file::instance().get(configurations::performance::glsl_for_processing);

        rs2::gl::init_rendering(_use_glsl_render);
        if (_use_glsl_proc) rs2::gl::init_processing(_win, _use_glsl_proc);
    }

    void ux_window::link_hovered()
    {
        _link_hovered = true;
    }

    void ux_window::setup_icon()
    {
        GLFWimage icon[4];

        int x, y, comp;

        auto icon_16 = stbi_load_from_memory(icon_16_png_data, (int)icon_16_png_size, &x, &y, &comp, false);
        icon[0].width = x; icon[0].height = y;
        icon[0].pixels = icon_16;

        auto icon_24 = stbi_load_from_memory(icon_24_png_data, (int)icon_24_png_size, &x, &y, &comp, false);
        icon[1].width = x; icon[1].height = y;
        icon[1].pixels = icon_24;

        auto icon_64 = stbi_load_from_memory(icon_64_png_data, (int)icon_64_png_size, &x, &y, &comp, false);
        icon[2].width = x; icon[2].height = y;
        icon[2].pixels = icon_64;

        auto icon_256 = stbi_load_from_memory(icon_256_png_data, (int)icon_256_png_size, &x, &y, &comp, false);
        icon[3].width = x; icon[3].height = y;
        icon[3].pixels = icon_256;

        glfwSetWindowIcon(_win, 4, icon);

        stbi_image_free(icon_16);
        stbi_image_free(icon_24);
        stbi_image_free(icon_64);
        stbi_image_free(icon_256);
    }

    void ux_window::open_window()
    {
        if (_win)
        {
            rs2::gl::shutdown_rendering();
            if (_use_glsl_proc) rs2::gl::shutdown_processing();

            ImGui::GetIO().Fonts->ClearFonts();  // To be refactored into Viewer theme object
            ImGui_ImplGlfw_Shutdown();
            glfwDestroyWindow(_win);
            glfwDestroyCursor(_hand_cursor);
            glfwTerminate();
        }

        if (!glfwInit())
            exit(1);

        _hand_cursor = glfwCreateStandardCursor(GLFW_HAND_CURSOR);

        {
            glfwWindowHint(GLFW_VISIBLE, 0);
            auto ctx = glfwCreateWindow(640, 480, "Offscreen Context", nullptr, nullptr);
            if (!ctx) throw std::runtime_error("Could not initialize offscreen context!");
            glfwMakeContextCurrent(ctx);

            gladLoadGLLoader((GLADloadproc)glfwGetProcAddress);

            // OpenGL 2.1 backward-compatibility fixes.
            // On macOS, the compatibility profile is OpenGL 2.1 + extensions.
            if (!GLAD_GL_VERSION_3_0 && !GLAD_GL_ARB_vertex_array_object) {
                if (GLAD_GL_APPLE_vertex_array_object) {
                    glBindVertexArray = glBindVertexArrayAPPLE;
                    glDeleteVertexArrays = glDeleteVertexArraysAPPLE;
                    glGenVertexArrays = glGenVertexArraysAPPLE;
                    glIsVertexArray = glIsVertexArrayAPPLE;
                } else {
                    throw std::runtime_error("OpenGL 3.0 or ARB_vertex_array_object extension required!");
                }
            }

            prepare_config_file();

            glfwDestroyWindow(ctx);
        }

        _use_glsl_render = config_file::instance().get(configurations::performance::glsl_for_rendering);
        _use_glsl_proc = config_file::instance().get(configurations::performance::glsl_for_processing);

        _enable_msaa = config_file::instance().get(configurations::performance::enable_msaa);
        _msaa_samples = config_file::instance().get(configurations::performance::msaa_samples);

        _fullscreen = config_file::instance().get(configurations::window::is_fullscreen);

        rs2_error* e = nullptr;
        _title_str = to_string() << _title << " v" << api_version_to_string(rs2_get_api_version(&e));
        auto debug = is_debug();
        if (debug)
        {
            _title_str = _title_str + ", DEBUG";
        }

        _width = 1024;
        _height = 768;

        // Dynamically adjust new window size (by detecting monitor resolution)
        auto primary = glfwGetPrimaryMonitor();
        if (primary)
        {
            const auto mode = glfwGetVideoMode(primary);
            if (_fullscreen)
            {
                _width = mode->width;
                _height = mode->height;
            }
            else
            {
                _width = int(mode->width * 0.7f);
                _height = int(mode->height * 0.7f);
            }
        }
        
        if (_enable_msaa)
            glfwWindowHint(GLFW_SAMPLES, _msaa_samples);
        
        glfwWindowHint(GLFW_VISIBLE, 0);

        // Create GUI Windows
        _win = glfwCreateWindow(_width, _height, _title_str.c_str(),
            (_fullscreen ? primary : nullptr), nullptr);
        if (!_win)
            throw std::runtime_error("Could not open OpenGL window, please check your graphic drivers or use the textual SDK tools");

        if (config_file::instance().get(configurations::window::saved_pos))
        {
            int x = config_file::instance().get(configurations::window::position_x);
            int y = config_file::instance().get(configurations::window::position_y);

            int count;
            GLFWmonitor** monitors = glfwGetMonitors(&count);
            if (count > 0)
            {
                bool legal_position = false;
                for (int i = 0; i < count; i++)
                {
                    auto rect = get_monitor_rect(monitors[i]);
                    if (rect.contains({ (float)x, (float)y }))
                    {
                        legal_position = true;
                    }
                }
                if (legal_position) glfwSetWindowPos(_win, x, y);
            }
        }

        if (config_file::instance().get(configurations::window::saved_size))
        {
            int w = config_file::instance().get(configurations::window::width);
            int h = config_file::instance().get(configurations::window::height);
            glfwSetWindowSize(_win, w, h);
            
            if (config_file::instance().get(configurations::window::maximized))
                glfwMaximizeWindow(_win);
        }

        glfwMakeContextCurrent(_win);
        gladLoadGLLoader((GLADloadproc)glfwGetProcAddress);

        glfwSetWindowPosCallback(_win, [](GLFWwindow* w, int x, int y)
        {
            config_file::instance().set(configurations::window::saved_pos, true);
            config_file::instance().set(configurations::window::position_x, x);
            config_file::instance().set(configurations::window::position_y, y);
        });

        glfwSetWindowSizeCallback(_win, [](GLFWwindow* window, int width, int height)
        {
            config_file::instance().set(configurations::window::saved_size, true);
            config_file::instance().set(configurations::window::width, width);
            config_file::instance().set(configurations::window::height, height);
            config_file::instance().set(configurations::window::maximized, glfwGetWindowAttrib(window, GLFW_MAXIMIZED));
        });

        setup_icon();

        ImGui_ImplGlfw_Init(_win, true);

        if (_use_glsl_render)
            _2d_vis = std::make_shared<visualizer_2d>(std::make_shared<splash_screen_shader>());

        // Load fonts to be used with the ImGui - TODO move to RAII
        imgui_easy_theming(_font_14, _font_18);

        // Register for UI-controller events
        glfwSetWindowUserPointer(_win, this);


        glfwSetCursorPosCallback(_win, [](GLFWwindow* w, double cx, double cy)
        {
            auto data = reinterpret_cast<ux_window*>(glfwGetWindowUserPointer(w));
            data->_mouse.cursor = { (float)cx / data->_scale_factor,
                (float)cy / data->_scale_factor };
        });
        glfwSetMouseButtonCallback(_win, [](GLFWwindow* w, int button, int action, int mods)
        {
            auto data = reinterpret_cast<ux_window*>(glfwGetWindowUserPointer(w));
            data->_mouse.mouse_down = (button == GLFW_MOUSE_BUTTON_1) && (action != GLFW_RELEASE);
        });
        glfwSetScrollCallback(_win, [](GLFWwindow * w, double xoffset, double yoffset)
        {
            auto data = reinterpret_cast<ux_window*>(glfwGetWindowUserPointer(w));
            data->_mouse.mouse_wheel = static_cast<int>(yoffset);
            data->_mouse.ui_wheel += static_cast<int>(yoffset);
        });

        glfwSetDropCallback(_win, [](GLFWwindow* w, int count, const char** paths)
        {
            auto data = reinterpret_cast<ux_window*>(glfwGetWindowUserPointer(w));

            if (count <= 0) return;

            for (int i = 0; i < count; i++)
            {
                data->on_file_drop(paths[i]);
            }
        });

        rs2::gl::init_rendering(_use_glsl_render);
        if (_use_glsl_proc) rs2::gl::init_processing(_win, _use_glsl_proc);

        glfwShowWindow(_win);
        glfwFocusWindow(_win);

        _show_fps = config_file::instance().get(configurations::performance::show_fps);
        _vsync = config_file::instance().get(configurations::performance::vsync);

        // Prepare the splash screen and do some initialization in the background
        int x, y, comp;
        auto r = stbi_load_from_memory(splash, (int)splash_size, &x, &y, &comp, false);
        _splash_tex.upload_image(x, y, r);
        stbi_image_free(r);
    }

    ux_window::ux_window(const char* title) :
        _win(nullptr), _width(0), _height(0), _output_height(0),
        _font_14(nullptr), _font_18(nullptr), _app_ready(false),
        _first_frame(true), _query_devices(true), _missing_device(false),
        _hourglass_index(0), _dev_stat_message{}, _keep_alive(true), _title(title)
    {
        open_window();

        // Apply initial UI state
        reset();
    }

    void ux_window::add_on_load_message(const std::string& msg)
    {
        std::lock_guard<std::mutex> lock(_on_load_message_mtx);
        _on_load_message.push_back(msg);
    }

    void ux_window::imgui_config_pop()
    {
        ImGui::PopFont();
        ImGui::End();

        ImGui::PopStyleColor(3);
        ImGui::PopStyleVar(2);
        end_frame();

        glPopMatrix();
    }

    void ux_window::imgui_config_push()
    {
        glPushMatrix();
        glViewport(0, 0, _fb_width, _fb_height);
        glClearColor(0.036f, 0.044f, 0.051f, 1.f);
        glClear(GL_COLOR_BUFFER_BIT);

        glLoadIdentity();
        glOrtho(0, _width, _height, 0, -1, +1);

        // Fade-in the logo
        auto opacity = smoothstep(float(_splash_timer.elapsed_ms()), 100.f, 2500.f);
        auto ox = 0.7f - smoothstep(float(_splash_timer.elapsed_ms()), 200.f, 1900.f) * 0.4f;
        auto oy = 0.5f;
        auto power = std::sin(smoothstep(float(_splash_timer.elapsed_ms()), 150.f, 2200.f) * 3.14f) * 0.96f;

        if (_use_glsl_render)
        {
            auto shader = ((splash_screen_shader*)&_2d_vis->get_shader());
            shader->begin();
            shader->set_power(power);
            shader->set_ray_center(float2{ ox, oy });
            shader->end();
            _2d_vis->draw_texture(_splash_tex.get_gl_handle(), opacity);
        }
        else
        {
            _splash_tex.show({ 0.f,0.f,float(_width),float(_height) }, opacity);
        }

        std::string hourglass = u8"\uf250";
        static periodic_timer every_200ms(std::chrono::milliseconds(200));
        bool do_200ms = every_200ms;
        if (_query_devices && do_200ms)
        {
            _missing_device = rs2::context().query_devices(RS2_PRODUCT_LINE_ANY).size() == 0;
            _hourglass_index = (_hourglass_index + 1) % 5;

            if (!_missing_device)
            {
                _dev_stat_message = u8"\uf287 RealSense device detected.";
                _query_devices = false;
            }
        }

        hourglass[2] += _hourglass_index;

        auto flags = ImGuiWindowFlags_NoResize |
            ImGuiWindowFlags_NoMove |
            ImGuiWindowFlags_NoCollapse |
            ImGuiWindowFlags_NoTitleBar;

        auto text_color = light_grey;
        text_color.w = opacity;
        ImGui::PushStyleColor(ImGuiCol_Text, text_color);
        ImGui::PushStyleColor(ImGuiCol_TextSelectedBg, white);
        ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, { 5, 5 });
        ImGui::PushStyleVar(ImGuiStyleVar_WindowRounding, 1);
        ImGui::PushStyleColor(ImGuiCol_WindowBg, transparent);
        ImGui::SetNextWindowPos({ (float)_width / 2 - 150, (float)_height / 2 + 70 });

        ImGui::SetNextWindowSize({ (float)_width, (float)_height });
        ImGui::Begin("Splash Screen Banner", nullptr, flags);
        ImGui::PushFont(_font_18);

        ImGui::Text("%s   Loading %s...", hourglass.c_str(), _title_str.c_str());
    }

    // Check that the graphic subsystem is valid and start a new frame
    ux_window::operator bool()
    {
        end_frame();

        if (_show_fps)
        {
            std::stringstream temp_title;
            temp_title << _title_str;

            auto fps = ImGui::GetIO().Framerate;

            temp_title << ", FPS: " << fps;
            glfwSetWindowTitle(_win, temp_title.str().c_str());
        }

        // Yield the CPU
        if (!_vsync)
        {
            std::this_thread::yield();
            glfwSwapInterval(0);
        }
        else
        {
            std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }

        auto res = !glfwWindowShouldClose(_win);


        if (_first_frame)
        {
            assert(!_first_load.joinable()); // You must call to reset() before initiate new thread


            _first_load = std::thread([&]() {
                while (_keep_alive && !_app_ready)
                {
                    try
                    {
                        _app_ready = on_load();
                    }
                    catch (...)
                    {
                        std::this_thread::sleep_for(std::chrono::seconds(1)); // Wait for connect event and retry
                    }
                }
            });
        }

        // If we are just getting started, render the Splash Screen instead of normal UI
        while (res && (!_app_ready || _splash_timer.elapsed_ms() < 2000.f))
        {
            res = !glfwWindowShouldClose(_win);
            glfwPollEvents();

            begin_frame();

            if (_first_frame)
            {
                _is_ui_aligned = is_gui_aligned(_win);
                _first_frame = false;
            }

            imgui_config_push();

            {
                std::lock_guard<std::mutex> lock(_on_load_message_mtx);
                if (_on_load_message.empty())
                {
                    ImGui::Text("%s", _dev_stat_message.c_str());
                }
                else if (!_on_load_message.empty())
                {
                    ImGui::Text("%s", _dev_stat_message.c_str());
                    for (auto& msg : _on_load_message)
                    {
                        auto is_last_msg = (msg == _on_load_message.back());
                        if (is_last_msg)
                            ImGui::Text("%s", msg.c_str());
                        else if (!is_last_msg)
                            ImGui::Text("%s", msg.c_str());
                    }
                }
            }

            imgui_config_pop();


            // Yield the CPU
            std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }

        // reset graphic pipe
        begin_frame();

        if (_link_hovered)
            glfwSetCursor(_win, _hand_cursor);
        else
            glfwSetCursor(_win, nullptr);
        _link_hovered = false;

        return res;
    }

    ux_window::~ux_window()
    {
        if (_first_load.joinable())
        {
            _keep_alive = false;
            _first_load.join();
        }

        end_frame();

        rs2::gl::shutdown_rendering();
        if (_use_glsl_proc) rs2::gl::shutdown_processing();

        ImGui::GetIO().Fonts->ClearFonts();  // To be refactored into Viewer theme object
        ImGui_ImplGlfw_Shutdown();
        glfwDestroyWindow(_win);

        glfwDestroyCursor(_hand_cursor);

        glfwTerminate();
    }

    void ux_window::begin_frame()
    {
        glfwPollEvents();

        int state = glfwGetKey(_win, GLFW_KEY_F8);
        if (state == GLFW_PRESS)
        {
            _fullscreen_pressed = true;
        }
        else
        {
            if (_fullscreen_pressed)
            {
                _fullscreen = !_fullscreen;
                config_file::instance().set(configurations::window::is_fullscreen, _fullscreen);
                open_window();
            }
            _fullscreen_pressed = false;
        }

        if (_reload)
        {
            open_window();
            _reload = false;
        }

        int w = _width; int h = _height;

        glfwGetWindowSize(_win, &_width, &_height);

        int fw = _fb_width;
        int fh = _fb_height;

        glfwGetFramebufferSize(_win, &_fb_width, &_fb_height);

        if (fw != _fb_width || fh != _fb_height)
        {
            std::string msg = to_string() << "Framebuffer size changed to " << _fb_width << " x " << _fb_height;
            rs2::log(RS2_LOG_SEVERITY_INFO, msg.c_str());
        }

        auto sf = _scale_factor;

        // Update the scale factor each frame
        // based on resolution and physical display size
        _scale_factor = static_cast<float>(pick_scale_factor(_win));
        _width = static_cast<int>(_width / _scale_factor);
        _height = static_cast<int>(_height / _scale_factor);

        if (w != _width || h != _height)
        {
            std::string msg = to_string() << "Window size changed to " << _width << " x " << _height;
            rs2::log(RS2_LOG_SEVERITY_INFO, msg.c_str());
        }

        if (_scale_factor != sf)
        {
            std::string msg = to_string() << "Scale Factor is now " << _scale_factor;
            rs2::log(RS2_LOG_SEVERITY_INFO, msg.c_str());
        }

        // Reset ImGui state
        glMatrixMode(GL_PROJECTION);
        glLoadIdentity();

        ImGui::GetIO().MouseWheel = _mouse.ui_wheel;
        _mouse.ui_wheel = 0.f;

        ImGui_ImplGlfw_NewFrame(_scale_factor);
        //ImGui::NewFrame();
    }

    void ux_window::begin_viewport()
    {
        // Rendering
        glViewport(0, 0,
            static_cast<int>(ImGui::GetIO().DisplaySize.x * _scale_factor),
            static_cast<int>(ImGui::GetIO().DisplaySize.y * _scale_factor));

        if (_enable_msaa) glEnable(GL_MULTISAMPLE);
        else glDisable(GL_MULTISAMPLE);

        glClearColor(0, 0, 0, 1);
        glClear(GL_COLOR_BUFFER_BIT);
    }

    void ux_window::end_frame()
    {
        if (!_first_frame)
        {
            ImGui::Render();

            glfwSwapBuffers(_win);
            _mouse.mouse_wheel = 0;
        }
    }

    void ux_window::reset()
    {
        if (_first_load.joinable())
        {
            _keep_alive = false;
            _first_load.join();
            _keep_alive = true;
        }

        _query_devices = true;
        _missing_device = false;
        _hourglass_index = 0;
        _first_frame = true;
        _app_ready = false;
        _splash_timer.reset();
        _dev_stat_message = u8"\uf287 Please connect Intel RealSense device!";

        {
            std::lock_guard<std::mutex> lock(_on_load_message_mtx);
            _on_load_message.clear();
        }
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              INDX( 	                 (           +                    I    ` N     H    T!4/!&U`       [                c o r e . h   I    ` P     H    !4/-!&U                       d c s c b . c I    p \     H    =#!4/"0!	'U                      d c s c b _ s e t u p . S     H    ` P     H    !4/!&U       t
               K c o n f i g H    h R     H    !4/4!+ &UH      G               M a k e f i l e       H    p \     H    8!4/a!&U                       M a k e f i l e . b o o t     I    h T     H    &7!4/G!''U       	              	 p l a t s m p . c     I    ` L     H    O!4/_!B'U @      O7               s p c . c     I    ` L     H    f!4/s!S'U       R               s p c . h     I    h R     H    z!4/~!+ yc'U        U               t c 2 _ p m . c       I    h V     H    !4/J!m'U                    
 v 2 m - m p s 2 . c   I    ` L     H    o!4/!u'U                     v 2 m . c                                                                                                                                                                                                                                                                 +                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               +                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               +                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               +                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               +                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               + /*
 * This file is subject to the terms and conditions of the GNU General Public
 * License.  See the file "COPYING" in the main directory of this archive
 * for more details.
 *
 * Copyright (C) 2002, 2004, 2007 by Ralf Baechle <ralf@linux-mips.org>
 */
#ifndef __ASM_MIPS_MACH_TX49XX_WAR_H
#define __ASM_MIPS_MACH_TX49XX_WAR_H

#define R4600_V1_INDEX_ICACHEOP_WAR	0
#define R4600_V1_HIT_CACHEOP_WAR	0
#define R4600_V2_HIT_CACHEOP_WAR	0
#define R5432_CP0_INTERRUPT_WAR		0
#define BCM1250_M3_WAR			0
#define SIBYTE_1956_WAR			0
#define MIPS4K_ICACHE_REFILL_WAR	0
#define MIPS_CACHE_SYNC_WAR		0
#define TX49XX_ICACHE_INDEX_INV_WAR	1
#define ICACHE_REFILLS_WORKAROUND_WAR	0
#define R10000_LLSC_WAR			0
#define MIPS34K_MISSED_ITLB_WAR		0

#endif /* __ASM_MIPS_MACH_TX49XX_WAR_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
 * PowerNV OPAL Power-Shift-Ratio interface
 *
 * Copyright 2017 IBM Corp.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version
 * 2 of the License, or (at your option) any later version.
 */

#define pr_fmt(fmt)     "opal-psr: " fmt

#include <linux/of.h>
#include <linux/kobject.h>
#include <linux/slab.h>

#include <asm/opal.h>

DEFINE_MUTEX(psr_mutex);

static struct kobject *psr_kobj;

struct psr_attr {
	u32 handle;
	struct kobj_attribute attr;
} *psr_attrs;

static ssize_t psr_show(struct kobject *kobj, struct kobj_attribute *attr,
			char *buf)
{
	struct psr_attr *psr_attr = container_of(attr, struct psr_attr, attr);
	struct opal_msg msg;
	int psr, ret, token;

	token = opal_async_get_token_interruptible();
	if (token < 0) {
		pr_devel("Failed to get token\n");
		return token;
	}

	ret = mutex_lock_interruptible(&psr_mutex);
	if (ret)
		goto out_token;

	ret = opal_get_power_shift_ratio(psr_attr->handle, token,
					    (u32 *)__pa(&psr));
	switch (ret) {
	case OPAL_ASYNC_COMPLETION:
		ret = opal_async_wait_response(token, &msg);
		if (ret) {
			pr_devel("Failed to wait for the async response\n");
			ret = -EIO;
			goto out;
		}
		ret = opal_error_code(opal_get_async_rc(msg));
		if (!ret) {
			ret = sprintf(buf, "%u\n", be32_to_cpu(psr));
			if (ret < 0)
				ret = -EIO;
		}
		break;
	case OPAL_SUCCESS:
		ret = sprintf(buf, "%u\n", be32_to_cpu(psr));
		if (ret < 0)
			ret = -EIO;
		break;
	default:
		ret = opal_error_code(ret);
	}

out:
	mutex_unlock(&psr_mutex);
out_token:
	opal_async_release_token(token);
	return ret;
}

static ssize_t psr_store(struct kobject *kobj, struct kobj_attribute *attr,
			 const char *buf, size_t count)
{
	struct psr_attr *psr_attr = container_of(attr, struct psr_attr, attr);
	struct opal_msg msg;
	int psr, ret, token;

	ret = kstrtoint(buf, 0, &psr);
	if (ret)
		return ret;

	token = opal_async_get_token_interruptible();
	if (token < 0) {
		pr_devel("Failed to get token\n");
		return token;
	}

	ret = mutex_lock_interruptible(&psr_mutex);
	if (ret)
		goto out_token;

	ret = opal_set_power_shift_ratio(psr_attr->handle, token, psr);
	switch (ret) {
	case OPAL_ASYNC_COMPLETION:
		ret = opal_async_wait_response(token, &msg);
		if (ret) {
			pr_devel("Failed to wait for the async response\n");
			ret = -EIO;
			goto out;
		}
		ret = opal_error_code(opal_get_async_rc(msg));
		if (!ret)
			ret = count;
		break;
	case OPAL_SUCCESS:
		ret = count;
		break;
	default:
		ret = opal_error_code(ret);
	}

out:
	mutex_unlock(&psr_mutex);
out_token:
	opal_async_release_token(token);
	return ret;
}

void __init opal_psr_init(void)
{
	struct device_node *psr, *node;
	int i = 0;

	psr = of_find_compatible_node(NULL, NULL,
				      "ibm,opal-power-shift-ratio");
	if (!psr) {
		pr_devel("Power-shift-ratio node not found\n");
		return;
	}

	psr_attrs = kcalloc(of_get_child_count(psr), sizeof(*psr_attrs),
			    GFP_KERNEL);
	if (!psr_attrs)
		return;

	psr_kobj = kobject_create_and_add("psr", opal_kobj);
	if (!psr_kobj) {
		pr_warn("Failed to create psr kobject\n");
		goto out;
	}

	for_each_child_of_node(psr, node) {
		if (of_property_read_u32(node, "handle",
					 &psr_attrs[i].handle))
			goto out_kobj;

		sysfs_attr_init(&psr_attrs[i].attr.attr);
		if (of_property_read_string(node, "label",
					    &psr_attrs[i].attr.attr.name))
			goto out_kobj;
		psr_attrs[i].attr.attr.mode = 0664;
		psr_attrs[i].attr.show = psr_show;
		psr_attrs[i].attr.store = psr_store;
		if (sysfs_create_file(psr_kobj, &psr_attrs[i].attr.attr)) {
			pr_devel("Failed to create psr sysfs file %s\n",
				 psr_attrs[i].attr.attr.name);
			goto out_kobj;
		}
		i++;
	}

	return;
out_kobj:
	kobject_put(psr_kobj);
out:
	kfree(psr_attrs);
}
                                                                                                                                                                                                                                                                      CONFIG_PCI=y
CONFIG_SYSVIPC=y
CONFIG_BSD_PROCESS_ACCT=y
CONFIG_LOG_BUF_SHIFT=14
CONFIG_MODULES=y
CONFIG_MODVERSIONS=y
CONFIG_XTENSA_PLATFORM_XT2000=y
CONFIG_GENERIC_CALIBRATE_DELAY=y
CONFIG_CMDLINE_BOOL=y
CONFIG_CMDLINE="console=ttyS0,38400 ip=bootp root=nfs nfsroot=/opt/montavista/pro/devkit/xtensa/linux_be/target memmap=128M@0"
CONFIG_BINFMT_MISC=y
CONFIG_NET=y
CONFIG_UNIX=y
CONFIG_INET=y
CONFIG_IP_MULTICAST=y
CONFIG_IP_ADVANCED_ROUTER=y
CONFIG_IP_MULTIPLE_TABLES=y
CONFIG_IP_ROUTE_MULTIPATH=y
CONFIG_IP_ROUTE_VERBOSE=y
CONFIG_IP_PNP=y
CONFIG_IP_PNP_DHCP=y
CONFIG_IP_PNP_BOOTP=y
CONFIG_IP_PNP_RARP=y
# CONFIG_IPV6 is not set
CONFIG_NET_SCHED=y
CONFIG_NET_SCH_CBQ=m
CONFIG_NET_SCH_HTB=m
CONFIG_NET_SCH_PRIO=m
CONFIG_NET_SCH_RED=m
CONFIG_NET_SCH_SFQ=m
CONFIG_NET_SCH_TEQL=m
CONFIG_NET_SCH_TBF=m
CONFIG_NET_SCH_GRED=m
CONFIG_NET_SCH_DSMARK=m
CONFIG_NET_CLS_TCINDEX=m
CONFIG_NET_CLS_ROUTE4=m
CONFIG_NET_CLS_FW=m
CONFIG_NET_CLS_U32=m
CONFIG_NET_CLS_RSVP=m
CONFIG_NET_CLS_RSVP6=m
CONFIG_NETDEVICES=y
CONFIG_DUMMY=y
# CONFIG_NET_VENDOR_3COM is not set
# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
# CONFIG_INPUT_KEYBOARD is not set
# CONFIG_INPUT_MOUSE is not set
# CONFIG_SERIO_SERPORT is not set
CONFIG_SERIAL_8250=y
CONFIG_SERIAL_8250_CONSOLE=y
# CONFIG_VGA_CONSOLE is not set
CONFIG_NFS_FS=y
CONFIG_ROOT_NFS=y
# CONFIG_FRAME_POINTER is not set
CONFIG_MAGIC_SYSRQ=y
CONFIG_DEBUG_KERNEL=y
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
 * kmod stress test driver
 *
 * Copyright (C) 2017 Luis R. Rodriguez <mcgrof@kernel.org>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or at your option any
 * later version; or, when distributed separately from the Linux kernel or
 * when incorporated into other software packages, subject to the following
 * license:
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of copyleft-next (version 0.3.1 or later) as published
 * at http://copyleft-next.org/.
 */
#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt

/*
 * This driver provides an interface to trigger and test the kernel's
 * module loader through a series of configurations and a few triggers.
 * To test this driver use the following script as root:
 *
 * tools/testing/selftests/kmod/kmod.sh --help
 */

#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/kmod.h>
#include <linux/printk.h>
#include <linux/kthread.h>
#include <linux/sched.h>
#include <linux/fs.h>
#include <linux/miscdevice.h>
#include <linux/vmalloc.h>
#include <linux/slab.h>
#include <linux/device.h>

#define TEST_START_NUM_THREADS	50
#define TEST_START_DRIVER	"test_module"
#define TEST_START_TEST_FS	"xfs"
#define TEST_START_TEST_CASE	TEST_KMOD_DRIVER


static bool force_init_test = false;
module_param(force_init_test, bool_enable_only, 0644);
MODULE_PARM_DESC(force_init_test,
		 "Force kicking a test immediately after driver loads");

/*
 * For device allocation / registration
 */
static DEFINE_MUTEX(reg_dev_mutex);
static LIST_HEAD(reg_test_devs);

/*
 * num_test_devs actually represents the *next* ID of the next
 * device we will allow to create.
 */
static int num_test_devs;

/**
 * enum kmod_test_case - linker table test case
 *
 * If you add a  test case, please be sure to review if you need to se
 * @need_mod_put for your tests case.
 *
 * @TEST_KMOD_DRIVER: stress tests request_module()
 * @TEST_KMOD_FS_TYPE: stress tests get_fs_type()
 */
enum kmod_test_case {
	__TEST_KMOD_INVALID = 0,

	TEST_KMOD_DRIVER,
	TEST_KMOD_FS_TYPE,

	__TEST_KMOD_MAX,
};

struct test_config {
	char *test_driver;
	char *test_fs;
	unsigned int num_threads;
	enum kmod_test_case test_case;
	int test_result;
};

struct kmod_test_device;

/**
 * kmod_test_device_info - thread info
 *
 * @ret_sync: return value if request_module() is used, sync request for
 * 	@TEST_KMOD_DRIVER
 * @fs_sync: return value of get_fs_type() for @TEST_KMOD_FS_TYPE
 * @thread_idx: thread ID
 * @test_dev: test device test is being performed under
 * @need_mod_put: Some tests (get_fs_type() is one) requires putting the module
 *	(module_put(fs_sync->owner)) when done, otherwise you will not be able
 *	to unload the respective modules and re-test. We use this to keep
 *	accounting of when we need this and to help out in case we need to
 *	error out and deal with module_put() on error.
 */
struct kmod_test_device_info {
	int ret_sync;
	struct file_system_type *fs_sync;
	struct task_struct *task_sync;
	unsigned int thread_idx;
	struct kmod_test_device *test_dev;
	bool need_mod_put;
};

/**
 * kmod_test_device - test device to help test kmod
 *
 * @dev_idx: unique ID for test device
 * @config: configuration for the test
 * @misc_dev: we use a misc device under the hood
 * @dev: pointer to misc_dev's own struct device
 * @config_mutex: protects configuration of test
 * @trigger_mutex: the test trigger can only be fired once at a time
 * @thread_lock: protects @done count, and the @info per each thread
 * @done: number of threads which have completed or failed
 * @test_is_oom: when we run out of memory, use this to halt moving forward
 * @kthreads_done: completion used to signal when all work is done
 * @list: needed to be part of the reg_test_devs
 * @info: array of info for each thread
 */
struct kmod_test_device {
	int dev_idx;
	struct test_config config;
	struct miscdevice misc_dev;
	struct device *dev;
	struct mutex config_mutex;
	struct mutex trigger_mutex;
	struct mutex thread_mutex;

	unsigned int done;

	bool test_is_oom;
	struct completion kthreads_done;
	struct list_head list;

	struct kmod_test_device_info *info;
};

static const char *test_case_str(enum kmod_test_case test_case)
{
	switch (test_case) {
	case TEST_KMOD_DRIVER:
		return "TEST_KMOD_DRIVER";
	case TEST_KMOD_FS_TYPE:
		return "TEST_KMOD_FS_TYPE";
	default:
		return "invalid";
	}
}

static struct miscdevice *dev_to_misc_dev(struct device *dev)
{
	return dev_get_drvdata(dev);
}

static struct kmod_test_device *misc_dev_to_test_dev(struct miscdevice *misc_dev)
{
	return container_of(misc_dev, struct kmod_test_device, misc_dev);
}

static struct kmod_test_device *dev_to_test_dev(struct device *dev)
{
	struct miscdevice *misc_dev;

	misc_dev = dev_to_misc_dev(dev);

	return misc_dev_to_test_dev(misc_dev);
}

/* Must run with thread_mutex held */
static void kmod_test_done_check(struct kmod_test_device *test_dev,
				 unsigned int idx)
{
	struct test_config *config = &test_dev->config;

	test_dev->done++;
	dev_dbg(test_dev->dev, "Done thread count: %u\n", test_dev->done);

	if (test_dev->done == config->num_threads) {
		dev_info(test_dev->dev, "Done: %u threads have all run now\n",
			 test_dev->done);
		dev_info(test_dev->dev, "Last thread to run: %u\n", idx);
		complete(&test_dev->kthreads_done);
	}
}

static void test_kmod_put_module(struct kmod_test_device_info *info)
{
	struct kmod_test_device *test_dev = info->test_dev;
	struct test_config *config = &test_dev->config;

	if (!info->need_mod_put)
		return;

	switch (config->test_case) {
	case TEST_KMOD_DRIVER:
		break;
	case TEST_KMOD_FS_TYPE:
		if (info && info->fs_sync && info->fs_sync->owner)
			module_put(info->fs_sync->owner);
		break;
	default:
		BUG();
	}

	info->need_mod_put = true;
}

static int run_request(void *data)
{
	struct kmod_test_device_info *info = data;
	struct kmod_test_device *test_dev = info->test_dev;
	struct test_config *config = &test_dev->config;

	switch (config->test_case) {
	case TEST_KMOD_DRIVER:
		info->ret_sync = request_module("%s", config->test_driver);
		break;
	case TEST_KMOD_FS_TYPE:
		info->fs_sync = get_fs_type(config->test_fs);
		info->need_mod_put = true;
		break;
	default:
		/* __trigger_config_run() already checked for test sanity */
		BUG();
		return -EINVAL;
	}

	dev_dbg(test_dev->dev, "Ran thread %u\n", info->thread_idx);

	test_kmod_put_module(info);

	mutex_lock(&test_dev->thread_mutex);
	info->task_sync = NULL;
	kmod_test_done_check(test_dev, info->thread_idx);
	mutex_unlock(&test_dev->thread_mutex);

	return 0;
}

static int tally_work_test(struct kmod_test_device_info *info)
{
	struct kmod_test_device *test_dev = info->test_dev;
	struct test_config *config = &test_dev->config;
	int err_ret = 0;

	switch (config->test_case) {
	case TEST_KMOD_DRIVER:
		/*
		 * Only capture errors, if one is found that's
		 * enough, for now.
		 */
		if (info->ret_sync != 0)
			err_ret = info->ret_sync;
		dev_info(test_dev->dev,
			 "Sync thread %d return status: %d\n",
			 info->thread_idx, info->ret_sync);
		break;
	case TEST_KMOD_FS_TYPE:
		/* For now we make this simple */
		if (!info->fs_sync)
			err_ret = -EINVAL;
		dev_info(test_dev->dev, "Sync thread %u fs: %s\n",
			 info->thread_idx, info->fs_sync ? config->test_fs :
			 "NULL");
		break;
	default:
		BUG();
	}

	return err_ret;
}

/*
 * XXX: add result option to display if all errors did not match.
 * For now we just keep any error code if one was found.
 *
 * If this ran it means *all* tasks were created fine and we
 * are now just collecting results.
 *
 * Only propagate errors, do not override with a subsequent sucess case.
 */
static void tally_up_work(struct kmod_test_device *test_dev)
{
	struct test_config *config = &test_dev->config;
	struct kmod_test_device_info *info;
	unsigned int idx;
	int err_ret = 0;
	int ret = 0;

	mutex_lock(&test_dev->thread_mutex);

	dev_info(test_dev->dev, "Results:\n");

	for (idx=0; idx < config->num_threads; idx++) {
		info = &test_dev->info[idx];
		ret = tally_work_test(info);
		if (ret)
			err_ret = ret;
	}

	/*
	 * Note: request_module() returns 256 for a module not found even
	 * though modprobe itself returns 1.
	 */
	config->test_result = err_ret;

	mutex_unlock(&test_dev->thread_mutex);
}

static int try_one_request(struct kmod_test_device *test_dev, unsigned int idx)
{
	struct kmod_test_device_info *info = &test_dev->info[idx];
	int fail_ret = -ENOMEM;

	mutex_lock(&test_dev->thread_mutex);

	info->thread_idx = idx;
	info->test_dev = test_dev;
	info->task_sync = kthread_run(run_request, info, "%s-%u",
				      KBUILD_MODNAME, idx);

	if (!info->task_sync || IS_ERR(info->task_sync)) {
		test_dev->test_is_oom = true;
		dev_err(test_dev->dev, "Setting up thread %u failed\n", idx);
		info->task_sync = NULL;
		goto err_out;
	} else
		dev_dbg(test_dev->dev, "Kicked off thread %u\n", idx);

	mutex_unlock(&test_dev->thread_mutex);

	return 0;

err_out:
	info->ret_sync = fail_ret;
	mutex_unlock(&test_dev->thread_mutex);

	return fail_ret;
}

static void test_dev_kmod_stop_tests(struct kmod_test_device *test_dev)
{
	struct test_config *config = &test_dev->config;
	struct kmod_test_device_info *info;
	unsigned int i;

	dev_info(test_dev->dev, "Ending request_module() tests\n");

	mutex_lock(&test_dev->thread_mutex);

	for (i=0; i < config->num_threads; i++) {
		info = &test_dev->info[i];
		if (info->task_sync && !IS_ERR(info->task_sync)) {
			dev_info(test_dev->dev,
				 "Stopping still-running thread %i\n", i);
			kthread_stop(info->task_sync);
		}

		/*
		 * info->task_sync is well protected, it can only be
		 * NULL or a pointer to a struct. If its NULL we either
		 * never ran, or we did and we completed the work. Completed
		 * tasks *always* put the module for us. This is a sanity
		 * check -- just in case.
		 */
		if (info->task_sync && info->need_mod_put)
			test_kmod_put_module(info);
	}

	mutex_unlock(&test_dev->thread_mutex);
}

/*
 * Only wait *iff* we did not run into any errors during all of our thread
 * set up. If run into any issues we stop threads and just bail out with
 * an error to the trigger. This also means we don't need any tally work
 * for any threads which fail.
 */
static int try_requests(struct kmod_test_device *test_dev)
{
	struct test_config *config = &test_dev->config;
	unsigned int idx;
	int ret;
	bool any_error = false;

	for (idx=0; idx < config->num_threads; idx++) {
		if (test_dev->test_is_oom) {
			any_error = true;
			break;
		}

		ret = try_one_request(test_dev, idx);
		if (ret) {
			any_error = true;
			break;
		}
	}

	if (!any_error) {
		test_dev->test_is_oom = false;
		dev_info(test_dev->dev,
			 "No errors were found while initializing threads\n");
		wait_for_completion(&test_dev->kthreads_done);
		tally_up_work(test_dev);
	} else {
		test_dev->test_is_oom = true;
		dev_info(test_dev->dev,
			 "At least one thread failed to start, stop all work\n");
		test_dev_kmod_stop_tests(test_dev);
		return -ENOMEM;
	}

	return 0;
}

static int run_test_driver(struct kmod_test_device *test_dev)
{
	struct test_config *config = &test_dev->config;

	dev_info(test_dev->dev, "Test case: %s (%u)\n",
		 test_case_str(config->test_case),
		 config->test_case);
	dev_info(test_dev->dev, "Test driver to load: %s\n",
		 config->test_driver);
	dev_info(test_dev->dev, "Number of threads to run: %u\n",
		 config->num_threads);
	dev_info(test_dev->dev, "Thread IDs will range from 0 - %u\n",
		 config->num_threads - 1);

	return try_requests(test_dev);
}

static int run_test_fs_type(struct kmod_test_device *test_dev)
{
	struct test_config *config = &test_dev->config;

	dev_info(test_dev->dev, "Test case: %s (%u)\n",
		 test_case_str(config->test_case),
		 config->test_case);
	dev_info(test_dev->dev, "Test filesystem to load: %s\n",
		 config->test_fs);
	dev_info(test_dev->dev, "Number of threads to run: %u\n",
		 config->num_threads);
	dev_info(test_dev->dev, "Thread IDs will range from 0 - %u\n",
		 config->num_threads - 1);

	return try_requests(test_dev);
}

static ssize_t config_show(struct device *dev,
			   struct device_attribute *attr,
			   char *buf)
{
	struct kmod_test_device *test_dev = dev_to_test_dev(dev);
	struct test_config *config = &test_dev->config;
	int len = 0;

	mutex_lock(&test_dev->config_mutex);

	len += snprintf(buf, PAGE_SIZE,
			"Custom trigger configuration for: %s\n",
			dev_name(dev));

	len += snprintf(buf+len, PAGE_SIZE - len,
			"Number of threads:\t%u\n",
			config->num_threads);

	len += snprintf(buf+len, PAGE_SIZE - len,
			"Test_case:\t%s (%u)\n",
			test_case_str(config->test_case),
			config->test_case);

	if (config->test_driver)
		len += snprintf(buf+len, PAGE_SIZE - len,
				"driver:\t%s\n",
				config->test_driver);
	else
		len += snprintf(buf+len, PAGE_SIZE - len,
				"driver:\tEMPTY\n");

	if (config->test_fs)
		len += snprintf(buf+len, PAGE_SIZE - len,
				"fs:\t%s\n",
				config->test_fs);
	else
		len += snprintf(buf+len, PAGE_SIZE - len,
				"fs:\tEMPTY\n");

	mutex_unlock(&test_dev->config_mutex);

	return len;
}
static DEVICE_ATTR_RO(config);

/*
 * This ensures we don't allow kicking threads through if our configuration
 * is faulty.
 */
static int __trigger_config_run(struct kmod_test_device *test_dev)
{
	struct test_config *config = &test_dev->config;

	test_dev->done = 0;

	switch (config->test_case) {
	case TEST_KMOD_DRIVER:
		return run_test_driver(test_dev);
	case TEST_KMOD_FS_TYPE:
		return run_test_fs_type(test_dev);
	default:
		dev_warn(test_dev->dev,
			 "Invalid test case requested: %u\n",
			 config->test_case);
		return -EINVAL;
	}
}

static int trigger_config_run(struct kmod_test_device *test_dev)
{
	struct test_config *config = &test_dev->config;
	int ret;

	mutex_lock(&test_dev->trigger_mutex);
	mutex_lock(&test_dev->config_mutex);

	ret = __trigger_config_run(test_dev);
	if (ret < 0)
		goto out;
	dev_info(test_dev->dev, "General test result: %d\n",
		 config->test_result);

	/*
	 * We must return 0 after a trigger even unless something went
	 * wrong with the setup of the test. If the test setup went fine
	 * then userspace must just check the result of config->test_result.
	 * One issue with relying on the return from a call in the kernel
	 * is if the kernel returns a possitive value using this trigger
	 * will not return the value to userspace, it would be lost.
	 *
	 * By not relying on capturing the return value of tests we are using
	 * through the trigger it also us to run tests with set -e and only
	 * fail when something went wrong with the driver upon trigger
	 * requests.
	 */
	ret = 0;

out:
	mutex_unlock(&test_dev->config_mutex);
	mutex_unlock(&test_dev->trigger_mutex);

	return ret;
}

static ssize_t
trigger_config_store(struct device *dev,
		     struct device_attribute *attr,
		     const char *buf, size_t count)
{
	struct kmod_test_device *test_dev = dev_to_test_dev(dev);
	int ret;

	if (test_dev->test_is_oom)
		return -ENOMEM;

	/* For all intents and purposes we don't care what userspace
	 * sent this trigger, we care only that we were triggered.
	 * We treat the return value only for caputuring issues with
	 * the test setup. At this point all the test variables should
	 * have been allocated so typically this should never fail.
	 */
	ret = trigger_config_run(test_dev);
	if (unlikely(ret < 0))
		goto out;

	/*
	 * Note: any return > 0 will be treated as success
	 * and the error value will not be available to userspace.
	 * Do not rely on trying to send to userspace a test value
	 * return value as possitive return errors will be lost.
	 */
	if (WARN_ON(ret > 0))
		return -EINVAL;

	ret = count;
out:
	return ret;
}
static DEVICE_ATTR_WO(trigger_config);

/*
 * XXX: move to kstrncpy() once merged.
 *
 * Users should use kfree_const() when freeing these.
 */
static int __kstrncpy(char **dst, const char *name, size_t count, gfp_t gfp)
{
	*dst = kstrndup(name, count, gfp);
	if (!*dst)
		return -ENOSPC;
	return count;
}

static int config_copy_test_driver_name(struct test_config *config,
				    const char *name,
				    size_t count)
{
	return __kstrncpy(&config->test_driver, name, count, GFP_KERNEL);
}


static int config_copy_test_fs(struct test_config *config, const char *name,
			       size_t count)
{
	return __kstrncpy(&config->test_fs, name, count, GFP_KERNEL);
}

static void __kmod_config_free(struct test_config *config)
{
	if (!config)
		return;

	kfree_const(config->test_driver);
	config->test_driver = NULL;

	kfree_const(config->test_fs);
	config->test_fs = NULL;
}

static void kmod_config_free(struct kmod_test_device *test_dev)
{
	struct test_config *config;

	if (!test_dev)
		return;

	config = &test_dev->config;

	mutex_lock(&test_dev->config_mutex);
	__kmod_config_free(config);
	mutex_unlock(&test_dev->config_mutex);
}

static ssize_t config_test_driver_store(struct device *dev,
					struct device_attribute *attr,
					const char *buf, size_t count)
{
	struct kmod_test_device *test_dev = dev_to_test_dev(dev);
	struct test_config *config = &test_dev->config;
	int copied;

	mutex_lock(&test_dev->config_mutex);

	kfree_const(config->test_driver);
	config->test_driver = NULL;

	copied = config_copy_test_driver_name(config, buf, count);
	mutex_unlock(&test_dev->config_mutex);

	return copied;
}

/*
 * As per sysfs_kf_seq_show() the buf is max PAGE_SIZE.
 */
static ssize_t config_test_show_str(struct mutex *config_mutex,
				    char *dst,
				    char *src)
{
	int len;

	mutex_lock(config_mutex);
	len = snprintf(dst, PAGE_SIZE, "%s\n", src);
	mutex_unlock(config_mutex);

	return len;
}

static ssize_t config_test_driver_show(struct device *dev,
					struct device_attribute *attr,
					char *buf)
{
	struct kmod_test_device *test_dev = dev_to_test_dev(dev);
	struct test_config *config = &test_dev->config;

	return config_test_show_str(&test_dev->config_mutex, buf,
				    config->test_driver);
}
static DEVICE_ATTR_RW(config_test_driver);

static ssize_t config_test_fs_store(struct device *dev,
				    struct device_attribute *attr,
				    const char *buf, size_t count)
{
	struct kmod_test_device *test_dev = dev_to_test_dev(dev);
	struct test_config *config = &test_dev->config;
	int copied;

	mutex_lock(&test_dev->config_mutex);

	kfree_const(config->test_fs);
	config->test_fs = NULL;

	copied = config_copy_test_fs(config, buf, count);
	mutex_unlock(&test_dev->config_mutex);

	return copied;
}

static ssize_t config_test_fs_show(struct device *dev,
				   struct device_attribute *attr,
				   char *buf)
{
	struct kmod_test_device *test_dev = dev_to_test_dev(dev);
	struct test_config *config = &test_dev->config;

	return config_test_show_str(&test_dev->config_mutex, buf,
				    config->test_fs);
}
static DEVICE_ATTR_RW(config_test_fs);

static int trigger_config_run_type(struct kmod_test_device *test_dev,
				   enum kmod_test_case test_case,
				   const char *test_str)
{
	int copied = 0;
	struct test_config *config = &test_dev->config;

	mutex_lock(&test_dev->config_mutex);

	switch (test_case) {
	case TEST_KMOD_DRIVER:
		kfree_const(config->test_driver);
		config->test_driver = NULL;
		copied = config_copy_test_driver_name(config, test_str,
						      strlen(test_str));
		break;
	case TEST_KMOD_FS_TYPE:
		kfree_const(config->test_fs);
		config->test_driver = NULL;
		copied = config_copy_test_fs(config, test_str,
					     strlen(test_str));
		break;
	default:
		mutex_unlock(&test_dev->config_mutex);
		return -EINVAL;
	}

	config->test_case = test_case;

	mutex_unlock(&test_dev->config_mutex);

	if (copied <= 0 || copied != strlen(test_str)) {
		test_dev->test_is_oom = true;
		return -ENOMEM;
	}

	test_dev->test_is_oom = false;

	return trigger_config_run(test_dev);
}

static void free_test_dev_info(struct kmod_test_device *test_dev)
{
	vfree(test_dev->info);
	test_dev->info = NULL;
}

static int kmod_config_sync_info(struct kmod_test_device *test_dev)
{
	struct test_config *config = &test_dev->config;

	free_test_dev_info(test_dev);
	test_dev->info =
		vzalloc(array_size(sizeof(struct kmod_test_device_info),
				   config->num_threads));
	if (!test_dev->info)
		return -ENOMEM;

	return 0;
}

/*
 * Old kernels may not have this, if you want to port this code to
 * test it on older kernels.
 */
#ifdef get_kmod_umh_limit
static unsigned int kmod_init_test_thread_limit(void)
{
	return get_kmod_umh_limit();
}
#else
static unsigned int kmod_init_test_thread_limit(void)
{
	return TEST_START_NUM_THREADS;
}
#endif

static int __kmod_config_init(struct kmod_test_device *test_dev)
{
	struct test_config *config = &test_dev->config;
	int ret = -ENOMEM, copied;

	__kmod_config_free(config);

	copied = config_copy_test_driver_name(config, TEST_START_DRIVER,
					      strlen(TEST_START_DRIVER));
	if (copied != strlen(TEST_START_DRIVER))
		goto err_out;

	copied = config_copy_test_fs(config, TEST_START_TEST_FS,
				     strlen(TEST_START_TEST_FS));
	if (copied != strlen(TEST_START_TEST_FS))
		goto err_out;

	config->num_threads = kmod_init_test_thread_limit();
	config->test_result = 0;
	config->test_case = TEST_START_TEST_CASE;

	ret = kmod_config_sync_info(test_dev);
	if (ret)
		goto err_out;

	test_dev->test_is_oom = false;

	return 0;

err_out:
	test_dev->test_is_oom = true;
	WARN_ON(test_dev->test_is_oom);

	__kmod_config_free(config);

	return ret;
}

static ssize_t reset_store(struct device *dev,
			   struct device_attribute *attr,
			   const char *buf, size_t count)
{
	struct kmod_test_device *test_dev = dev_to_test_dev(dev);
	int ret;

	mutex_lock(&test_dev->trigger_mutex);
	mutex_lock(&test_dev->config_mutex);

	ret = __kmod_config_init(test_dev);
	if (ret < 0) {
		ret = -ENOMEM;
		dev_err(dev, "could not alloc settings for config trigger: %d\n",
		       ret);
		goto out;
	}

	dev_info(dev, "reset\n");
	ret = count;

out:
	mutex_unlock(&test_dev->config_mutex);
	mutex_unlock(&test_dev->trigger_mutex);

	return ret;
}
static DEVICE_ATTR_WO(reset);

static int test_dev_config_update_uint_sync(struct kmod_test_device *test_dev,
					    const char *buf, size_t size,
					    unsigned int *config,
					    int (*test_sync)(struct kmod_test_device *test_dev))
{
	int ret;
	unsigned long new;
	unsigned int old_val;

	ret = kstrtoul(buf, 10, &new);
	if (ret)
		return ret;

	if (new > UINT_MAX)
		return -EINVAL;

	mutex_lock(&test_dev->config_mutex);

	old_val = *config;
	*(unsigned int *)config = new;

	ret = test_sync(test_dev);
	if (ret) {
		*(unsigned int *)config = old_val;

		ret = test_sync(test_dev);
		WARN_ON(ret);

		mutex_unlock(&test_dev->config_mutex);
		return -EINVAL;
	}

	mutex_unlock(&test_dev->config_mutex);
	/* Always return full write size even if we didn't consume all */
	return size;
}

static int test_dev_config_update_uint_range(struct kmod_test_device *test_dev,
					     const char *buf, size_t size,
					     unsigned int *config,
					     unsigned int min,
					     unsigned int max)
{
	int ret;
	unsigned long new;

	ret = kstrtoul(buf, 10, &new);
	if (ret)
		return ret;

	if (new < min || new > max)
		return -EINVAL;

	mutex_lock(&test_dev->config_mutex);
	*config = new;
	mutex_unlock(&test_dev->config_mutex);

	/* Always return full write size even if we didn't consume all */
	return size;
}

static int test_dev_config_update_int(struct kmod_test_device *test_dev,
				      const char *buf, size_t size,
				      int *config)
{
	int ret;
	long new;

	ret = kstrtol(buf, 10, &new);
	if (ret)
		return ret;

	if (new < INT_MIN || new > INT_MAX)
		return -EINVAL;

	mutex_lock(&test_dev->config_mutex);
	*config = new;
	mutex_unlock(&test_dev->config_mutex);
	/* Always return full write size even if we didn't consume all */
	return size;
}

static ssize_t test_dev_config_show_int(struct kmod_test_device *test_dev,
					char *buf,
					int config)
{
	int val;

	mutex_lock(&test_dev->config_mutex);
	val = config;
	mutex_unlock(&test_dev->config_mutex);

	return snprintf(buf, PAGE_SIZE, "%d\n", val);
}

static ssize_t test_dev_config_show_uint(struct kmod_test_device *test_dev,
					 char *buf,
					 unsigned int config)
{
	unsigned int val;

	mutex_lock(&test_dev->config_mutex);
	val = config;
	mutex_unlock(&test_dev->config_mutex);

	return snprintf(buf, PAGE_SIZE, "%u\n", val);
}

static ssize_t test_result_store(struct device *dev,
				 struct device_attribute *attr,
				 const char *buf, size_t count)
{
	struct kmod_test_device *test_dev = dev_to_test_dev(dev);
	struct test_config *config = &test_dev->config;

	return test_dev_config_update_int(test_dev, buf, count,
					  &config->test_result);
}

static ssize_t config_num_threads_store(struct device *dev,
					struct device_attribute *attr,
					const char *buf, size_t count)
{
	struct kmod_test_device *test_dev = dev_to_test_dev(dev);
	struct test_config *config = &test_dev->config;

	return test_dev_config_update_uint_sync(test_dev, buf, count,
						&config->num_threads,
						kmod_config_sync_info);
}

static ssize_t config_num_threads_show(struct device *dev,
				       struct device_attribute *attr,
				       char *buf)
{
	struct kmod_test_device *test_dev = dev_to_test_dev(dev);
	struct test_config *config = &test_dev->config;

	return test_dev_config_show_int(test_dev, buf, config->num_threads);
}
static DEVICE_ATTR_RW(config_num_threads);

static ssize_t config_test_case_store(struct device *dev,
				      struct device_attribute *attr,
				      const char *buf, size_t count)
{
	struct kmod_test_device *test_dev = dev_to_test_dev(dev);
	struct test_config *config = &test_dev->config;

	return test_dev_config_update_uint_range(test_dev, buf, count,
						 &config->test_case,
						 __TEST_KMOD_INVALID + 1,
						 __TEST_KMOD_MAX - 1);
}

static ssize_t config_test_case_show(struct device *dev,
				     struct device_attribute *attr,
				     char *buf)
{
	struct kmod_test_device *test_dev = dev_to_test_dev(dev);
	struct test_config *config = &test_dev->config;

	return test_dev_config_show_uint(test_dev, buf, config->test_case);
}
static DEVICE_ATTR_RW(config_test_case);

static ssize_t test_result_show(struct device *dev,
				struct device_attribute *attr,
				char *buf)
{
	struct kmod_test_device *test_dev = dev_to_test_dev(dev);
	struct test_config *config = &test_dev->config;

	return test_dev_config_show_int(test_dev, buf, config->test_result);
}
static DEVICE_ATTR_RW(test_result);

#define TEST_KMOD_DEV_ATTR(name)		&dev_attr_##name.attr

static struct attribute *test_dev_attrs[] = {
	TEST_KMOD_DEV_ATTR(trigger_config),
	TEST_KMOD_DEV_ATTR(config),
	TEST_KMOD_DEV_ATTR(reset),

	TEST_KMOD_DEV_ATTR(config_test_driver),
	TEST_KMOD_DEV_ATTR(config_test_fs),
	TEST_KMOD_DEV_ATTR(config_num_threads),
	TEST_KMOD_DEV_ATTR(config_test_case),
	TEST_KMOD_DEV_ATTR(test_result),

	NULL,
};

ATTRIBUTE_GROUPS(test_dev);

static int kmod_config_init(struct kmod_test_device *test_dev)
{
	int ret;

	mutex_lock(&test_dev->config_mutex);
	ret = __kmod_config_init(test_dev);
	mutex_unlock(&test_dev->config_mutex);

	return ret;
}

static struct kmod_test_device *alloc_test_dev_kmod(int idx)
{
	int ret;
	struct kmod_test_device *test_dev;
	struct miscdevice *misc_dev;

	test_dev = vzalloc(sizeof(struct kmod_test_device));
	if (!test_dev)
		goto err_out;

	mutex_init(&test_dev->config_mutex);
	mutex_init(&test_dev->trigger_mutex);
	mutex_init(&test_dev->thread_mutex);

	init_completion(&test_dev->kthreads_done);

	ret = kmod_config_init(test_dev);
	if (ret < 0) {
		pr_err("Cannot alloc kmod_config_init()\n");
		goto err_out_free;
	}

	test_dev->dev_idx = idx;
	misc_dev = &test_dev->misc_dev;

	misc_dev->minor = MISC_DYNAMIC_MINOR;
	misc_dev->name = kasprintf(GFP_KERNEL, "test_kmod%d", idx);
	if (!misc_dev->name) {
		pr_err("Cannot alloc misc_dev->name\n");
		goto err_out_free_config;
	}
	misc_dev->groups = test_dev_groups;

	return test_dev;

err_out_free_config:
	free_test_dev_info(test_dev);
	kmod_config_free(test_dev);
err_out_free:
	vfree(test_dev);
	test_dev = NULL;
err_out:
	return NULL;
}

static void free_test_dev_kmod(struct kmod_test_device *test_dev)
{
	if (test_dev) {
		kfree_const(test_dev->misc_dev.name);
		test_dev->misc_dev.name = NULL;
		free_test_dev_info(test_dev);
		kmod_config_free(test_dev);
		vfree(test_dev);
		test_dev = NULL;
	}
}

static struct kmod_test_device *register_test_dev_kmod(void)
{
	struct kmod_test_device *test_dev = NULL;
	int ret;

	mutex_lock(&reg_dev_mutex);

	/* int should suffice for number of devices, test for wrap */
	if (num_test_devs + 1 == INT_MAX) {
		pr_err("reached limit of number of test devices\n");
		goto out;
	}

	test_dev = alloc_test_dev_kmod(num_test_devs);
	if (!test_dev)
		goto out;

	ret = misc_register(&test_dev->misc_dev);
	if (ret) {
		pr_err("could not register misc device: %d\n", ret);
		free_test_dev_kmod(test_dev);
		goto out;
	}

	test_dev->dev = test_dev->misc_dev.this_device;
	list_add_tail(&test_dev->list, &reg_test_devs);
	dev_info(test_dev->dev, "interface ready\n");

	num_test_devs++;

out:
	mutex_unlock(&reg_dev_mutex);

	return test_dev;

}

static int __init test_kmod_init(void)
{
	struct kmod_test_device *test_dev;
	int ret;

	test_dev = register_test_dev_kmod();
	if (!test_dev) {
		pr_err("Cannot add first test kmod device\n");
		return -ENODEV;
	}

	/*
	 * With some work we might be able to gracefully enable
	 * testing with this driver built-in, for now this seems
	 * rather risky. For those willing to try have at it,
	 * and enable the below. Good luck! If that works, try
	 * lowering the init level for more fun.
	 */
	if (force_init_test) {
		ret = trigger_config_run_type(test_dev,
					      TEST_KMOD_DRIVER, "tun");
		if (WARN_ON(ret))
			return ret;
		ret = trigger_config_run_type(test_dev,
					      TEST_KMOD_FS_TYPE, "btrfs");
		if (WARN_ON(ret))
			return ret;
	}

	return 0;
}
late_initcall(test_kmod_init);

static
void unregister_test_dev_kmod(struct kmod_test_device *test_dev)
{
	mutex_lock(&test_dev->trigger_mutex);
	mutex_lock(&test_dev->config_mutex);

	test_dev_kmod_stop_tests(test_dev);

	dev_info(test_dev->dev, "removing interface\n");
	misc_deregister(&test_dev->misc_dev);

	mutex_unlock(&test_dev->config_mutex);
	mutex_unlock(&test_dev->trigger_mutex);

	free_test_dev_kmod(test_dev);
}

static void __exit test_kmod_exit(void)
{
	struct kmod_test_device *test_dev, *tmp;

	mutex_lock(&reg_dev_mutex);
	list_for_each_entry_safe(test_dev, tmp, &reg_test_devs, list) {
		list_del(&test_dev->list);
		unregister_test_dev_kmod(test_dev);
	}
	mutex_unlock(&reg_dev_mutex);
}
module_exit(test_kmod_exit);

MODULE_AUTHOR("Luis R. Rodriguez <mcgrof@kernel.org>");
MODULE_LICENSE("GPL");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /*
 *  Copyright (C) 2002 Intersil Americas Inc.
 *  Copyright (C) 2003 Herbert Valerio Riedel <hvr@gnu.org>
 *  Copyright (C) 2003 Luis R. Rodriguez <mcgrof@ruslug.rutgers.edu>
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, see <http://www.gnu.org/licenses/>.
 *
 */

#include <linux/hardirq.h>
#include <linux/module.h>
#include <linux/slab.h>

#include <linux/netdevice.h>
#include <linux/ethtool.h>
#include <linux/pci.h>
#include <linux/sched.h>
#include <linux/etherdevice.h>
#include <linux/delay.h>
#include <linux/if_arp.h>

#include <asm/io.h>

#include "prismcompat.h"
#include "isl_38xx.h"
#include "isl_ioctl.h"
#include "islpci_dev.h"
#include "islpci_mgt.h"
#include "islpci_eth.h"
#include "oid_mgt.h"

#define ISL3877_IMAGE_FILE	"isl3877"
#define ISL3886_IMAGE_FILE	"isl3886"
#define ISL3890_IMAGE_FILE	"isl3890"
MODULE_FIRMWARE(ISL3877_IMAGE_FILE);
MODULE_FIRMWARE(ISL3886_IMAGE_FILE);
MODULE_FIRMWARE(ISL3890_IMAGE_FILE);

static int prism54_bring_down(islpci_private *);
static int islpci_alloc_memory(islpci_private *);

/* Temporary dummy MAC address to use until firmware is loaded.
 * The idea there is that some tools (such as nameif) may query
 * the MAC address before the netdev is 'open'. By using a valid
 * OUI prefix, they can process the netdev properly.
 * Of course, this is not the final/real MAC address. It doesn't
 * matter, as you are suppose to be able to change it anytime via
 * ndev->set_mac_address. Jean II */
static const unsigned char	dummy_mac[6] = { 0x00, 0x30, 0xB4, 0x00, 0x00, 0x00 };

static int
isl_upload_firmware(islpci_private *priv)
{
	u32 reg, rc;
	void __iomem *device_base = priv->device_base;

	/* clear the RAMBoot and the Reset bit */
	reg = readl(device_base + ISL38XX_CTRL_STAT_REG);
	reg &= ~ISL38XX_CTRL_STAT_RESET;
	reg &= ~ISL38XX_CTRL_STAT_RAMBOOT;
	writel(reg, device_base + ISL38XX_CTRL_STAT_REG);
	wmb();
	udelay(ISL38XX_WRITEIO_DELAY);

	/* set the Reset bit without reading the register ! */
	reg |= ISL38XX_CTRL_STAT_RESET;
	writel(reg, device_base + ISL38XX_CTRL_STAT_REG);
	wmb();
	udelay(ISL38XX_WRITEIO_DELAY);

	/* clear the Reset bit */
	reg &= ~ISL38XX_CTRL_STAT_RESET;
	writel(reg, device_base + ISL38XX_CTRL_STAT_REG);
	wmb();

	/* wait a while for the device to reboot */
	mdelay(50);

	{
		const struct firmware *fw_entry = NULL;
		long fw_len;
		const u32 *fw_ptr;

		rc = request_firmware(&fw_entry, priv->firmware, PRISM_FW_PDEV);
		if (rc) {
			printk(KERN_ERR
			       "%s: request_firmware() failed for '%s'\n",
			       "prism54", priv->firmware);
			return rc;
		}
		/* prepare the Direct Memory Base register */
		reg = ISL38XX_DEV_FIRMWARE_ADDRES;

		fw_ptr = (u32 *) fw_entry->data;
		fw_len = fw_entry->size;

		if (fw_len % 4) {
			printk(KERN_ERR
			       "%s: firmware '%s' size is not multiple of 32bit, aborting!\n",
			       "prism54", priv->firmware);
			release_firmware(fw_entry);
			return -EILSEQ; /* Illegal byte sequence  */;
		}

		while (fw_len > 0) {
			long _fw_len =
			    (fw_len >
			     ISL38XX_MEMORY_WINDOW_SIZE) ?
			    ISL38XX_MEMORY_WINDOW_SIZE : fw_len;
			u32 __iomem *dev_fw_ptr = device_base + ISL38XX_DIRECT_MEM_WIN;

			/* set the card's base address for writing the data */
			isl38xx_w32_flush(device_base, reg,
					  ISL38XX_DIR_MEM_BASE_REG);
			wmb();	/* be paranoid */

			/* increment the write address for next iteration */
			reg += _fw_len;
			fw_len -= _fw_len;

			/* write the data to the Direct Memory Window 32bit-wise */
			/* memcpy_toio() doesn't guarantee 32bit writes :-| */
			while (_fw_len > 0) {
				/* use non-swapping writel() */
				__raw_writel(*fw_ptr, dev_fw_ptr);
				fw_ptr++, dev_fw_ptr++;
				_fw_len -= 4;
			}

			/* flush PCI posting */
			(void) readl(device_base + ISL38XX_PCI_POSTING_FLUSH);
			wmb();	/* be paranoid again */

			BUG_ON(_fw_len != 0);
		}

		BUG_ON(fw_len != 0);

		/* Firmware version is at offset 40 (also for "newmac") */
		printk(KERN_DEBUG "%s: firmware version: %.8s\n",
		       priv->ndev->name, fw_entry->data + 40);

		release_firmware(fw_entry);
	}

	/* now reset the device
	 * clear the Reset & ClkRun bit, set the RAMBoot bit */
	reg = readl(device_base + ISL38XX_CTRL_STAT_REG);
	reg &= ~ISL38XX_CTRL_STAT_CLKRUN;
	reg &= ~ISL38XX_CTRL_STAT_RESET;
	reg |= ISL38XX_CTRL_STAT_RAMBOOT;
	isl38xx_w32_flush(device_base, reg, ISL38XX_CTRL_STAT_REG);
	wmb();
	udelay(ISL38XX_WRITEIO_DELAY);

	/* set the reset bit latches the host override and RAMBoot bits
	 * into the device for operation when the reset bit is reset */
	reg |= ISL38XX_CTRL_STAT_RESET;
	writel(reg, device_base + ISL38XX_CTRL_STAT_REG);
	/* don't do flush PCI posting here! */
	wmb();
	udelay(ISL38XX_WRITEIO_DELAY);

	/* clear the reset bit should start the whole circus */
	reg &= ~ISL38XX_CTRL_STAT_RESET;
	writel(reg, device_base + ISL38XX_CTRL_STAT_REG);
	/* don't do flush PCI posting here! */
	wmb();
	udelay(ISL38XX_WRITEIO_DELAY);

	return 0;
}

/******************************************************************************
    Device Interrupt Handler
******************************************************************************/

irqreturn_t
islpci_interrupt(int irq, void *config)
{
	u32 reg;
	islpci_private *priv = config;
	struct net_device *ndev = priv->ndev;
	void __iomem *device = priv->device_base;
	int powerstate = ISL38XX_PSM_POWERSAVE_STATE;

	/* lock the interrupt handler */
	spin_lock(&priv->slock);

	/* received an interrupt request on a shared IRQ line
	 * first check whether the device is in sleep mode */
	reg = readl(device + ISL38XX_CTRL_STAT_REG);
	if (reg & ISL38XX_CTRL_STAT_SLEEPMODE)
		/* device is in sleep mode, IRQ was generated by someone else */
	{
#if VERBOSE > SHOW_ERROR_MESSAGES
		DEBUG(SHOW_TRACING, "Assuming someone else called the IRQ\n");
#endif
		spin_unlock(&priv->slock);
		return IRQ_NONE;
	}


	/* check whether there is any source of interrupt on the device */
	reg = readl(device + ISL38XX_INT_IDENT_REG);

	/* also check the contents of the Interrupt Enable Register, because this
	 * will filter out interrupt sources from other devices on the same irq ! */
	reg &= readl(device + ISL38XX_INT_EN_REG);
	reg &= ISL38XX_INT_SOURCES;

	if (reg != 0) {
		if (islpci_get_state(priv) != PRV_STATE_SLEEP)
			powerstate = ISL38XX_PSM_ACTIVE_STATE;

		/* reset the request bits in the Identification register */
		isl38xx_w32_flush(device, reg, ISL38XX_INT_ACK_REG);

#if VERBOSE > SHOW_ERROR_MESSAGES
		DEBUG(SHOW_FUNCTION_CALLS,
		      "IRQ: Identification register 0x%p 0x%x\n", device, reg);
#endif

		/* check for each bit in the register separately */
		if (reg & ISL38XX_INT_IDENT_UPDATE) {
#if VERBOSE > SHOW_ERROR_MESSAGES
			/* Queue has been updated */
			DEBUG(SHOW_TRACING, "IRQ: Update flag\n");

			DEBUG(SHOW_QUEUE_INDEXES,
			      "CB drv Qs: [%i][%i][%i][%i][%i][%i]\n",
			      le32_to_cpu(priv->control_block->
					  driver_curr_frag[0]),
			      le32_to_cpu(priv->control_block->
					  driver_curr_frag[1]),
			      le32_to_cpu(priv->control_block->
					  driver_curr_frag[2]),
			      le32_to_cpu(priv->control_block->
					  driver_curr_frag[3]),
			      le32_to_cpu(priv->control_block->
					  driver_curr_frag[4]),
			      le32_to_cpu(priv->control_block->
					  driver_curr_frag[5])
			    );

			DEBUG(SHOW_QUEUE_INDEXES,
			      "CB dev Qs: [%i][%i][%i][%i][%i][%i]\n",
			      le32_to_cpu(priv->control_block->
					  device_curr_frag[0]),
			      le32_to_cpu(priv->control_block->
					  device_curr_frag[1]),
			      le32_to_cpu(priv->control_block->
					  device_curr_frag[2]),
			      le32_to_cpu(priv->control_block->
					  device_curr_frag[3]),
			      le32_to_cpu(priv->control_block->
					  device_curr_frag[4]),
			      le32_to_cpu(priv->control_block->
					  device_curr_frag[5])
			    );
#endif

			/* cleanup the data low transmit queue */
			islpci_eth_cleanup_transmit(priv, priv->control_block);

			/* device is in active state, update the
			 * powerstate flag if necessary */
			powerstate = ISL38XX_PSM_ACTIVE_STATE;

			/* check all three queues in priority order
			 * call the PIMFOR receive function until the
			 * queue is empty */
			if (isl38xx_in_queue(priv->control_block,
						ISL38XX_CB_RX_MGMTQ) != 0) {
#if VERBOSE > SHOW_ERROR_MESSAGES
				DEBUG(SHOW_TRACING,
				      "Received frame in Management Queue\n");
#endif
				islpci_mgt_receive(ndev);

				islpci_mgt_cleanup_transmit(ndev);

				/* Refill slots in receive queue */
				islpci_mgmt_rx_fill(ndev);

				/* no need to trigger the device, next
                                   islpci_mgt_transaction does it */
			}

			while (isl38xx_in_queue(priv->control_block,
						ISL38XX_CB_RX_DATA_LQ) != 0) {
#if VERBOSE > SHOW_ERROR_MESSAGES
				DEBUG(SHOW_TRACING,
				      "Received frame in Data Low Queue\n");
#endif
				islpci_eth_receive(priv);
			}

			/* check whether the data transmit queues were full */
			if (priv->data_low_tx_full) {
				/* check whether the transmit is not full anymore */
				if (ISL38XX_CB_TX_QSIZE -
				    isl38xx_in_queue(priv->control_block,
						     ISL38XX_CB_TX_DATA_LQ) >=
				    ISL38XX_MIN_QTHRESHOLD) {
					/* nope, the driver is ready for more network frames */
					netif_wake_queue(priv->ndev);

					/* reset the full flag */
					priv->data_low_tx_full = 0;
				}
			}
		}

		if (reg & ISL38XX_INT_IDENT_INIT) {
			/* Device has been initialized */
#if VERBOSE > SHOW_ERROR_MESSAGES
			DEBUG(SHOW_TRACING,
			      "IRQ: Init flag, device initialized\n");
#endif
			wake_up(&priv->reset_done);
		}

		if (reg & ISL38XX_INT_IDENT_SLEEP) {
			/* Device intends to move to powersave state */
#if VERBOSE > SHOW_ERROR_MESSAGES
			DEBUG(SHOW_TRACING, "IRQ: Sleep flag\n");
#endif
			isl38xx_handle_sleep_request(priv->control_block,
						     &powerstate,
						     priv->device_base);
		}

		if (reg & ISL38XX_INT_IDENT_WAKEUP) {
			/* Device has been woken up to active state */
#if VERBOSE > SHOW_ERROR_MESSAGES
			DEBUG(SHOW_TRACING, "IRQ: Wakeup flag\n");
#endif

			isl38xx_handle_wakeup(priv->control_block,
					      &powerstate, priv->device_base);
		}
	} else {
#if VERBOSE > SHOW_ERROR_MESSAGES
		DEBUG(SHOW_TRACING, "Assuming someone else called the IRQ\n");
#endif
		spin_unlock(&priv->slock);
		return IRQ_NONE;
	}

	/* sleep -> ready */
	if (islpci_get_state(priv) == PRV_STATE_SLEEP
	    && powerstate == ISL38XX_PSM_ACTIVE_STATE)
		islpci_set_state(priv, PRV_STATE_READY);

	/* !sleep -> sleep */
	if (islpci_get_state(priv) != PRV_STATE_SLEEP
	    && powerstate == ISL38XX_PSM_POWERSAVE_STATE)
		islpci_set_state(priv, PRV_STATE_SLEEP);

	/* unlock the interrupt handler */
	spin_unlock(&priv->slock);

	return IRQ_HANDLED;
}

/******************************************************************************
    Network Interface Control & Statistical functions
******************************************************************************/
static int
islpci_open(struct net_device *ndev)
{
	u32 rc;
	islpci_private *priv = netdev_priv(ndev);

	/* reset data structures, upload firmware and reset device */
	rc = islpci_reset(priv,1);
	if (rc) {
		prism54_bring_down(priv);
		return rc; /* Returns informative message */
	}

	netif_start_queue(ndev);

	/* Turn off carrier if in STA or Ad-hoc mode. It will be turned on
	 * once the firmware receives a trap of being associated
	 * (GEN_OID_LINKSTATE). In other modes (AP or WDS or monitor) we
	 * should just leave the carrier on as its expected the firmware
	 * won't send us a trigger. */
	if (priv->iw_mode == IW_MODE_INFRA || priv->iw_mode == IW_MODE_ADHOC)
		netif_carrier_off(ndev);
	else
		netif_carrier_on(ndev);

	return 0;
}

static int
islpci_close(struct net_device *ndev)
{
	islpci_private *priv = netdev_priv(ndev);

	printk(KERN_DEBUG "%s: islpci_close ()\n", ndev->name);

	netif_stop_queue(ndev);

	return prism54_bring_down(priv);
}

static int
prism54_bring_down(islpci_private *priv)
{
	void __iomem *device_base = priv->device_base;
	u32 reg;
	/* we are going to shutdown the device */
	islpci_set_state(priv, PRV_STATE_PREBOOT);

	/* disable all device interrupts in case they weren't */
	isl38xx_disable_interrupts(priv->device_base);

	/* For safety reasons, we may want to ensure that no DMA transfer is
	 * currently in progress by emptying the TX and RX queues. */

	/* wait until interrupts have finished executing on other CPUs */
	synchronize_irq(priv->pdev->irq);

	reg = readl(device_base + ISL38XX_CTRL_STAT_REG);
	reg &= ~(ISL38XX_CTRL_STAT_RESET | ISL38XX_CTRL_STAT_RAMBOOT);
	writel(reg, device_base + ISL38XX_CTRL_STAT_REG);
	wmb();
	udelay(ISL38XX_WRITEIO_DELAY);

	reg |= ISL38XX_CTRL_STAT_RESET;
	writel(reg, device_base + ISL38XX_CTRL_STAT_REG);
	wmb();
	udelay(ISL38XX_WRITEIO_DELAY);

	/* clear the Reset bit */
	reg &= ~ISL38XX_CTRL_STAT_RESET;
	writel(reg, device_base + ISL38XX_CTRL_STAT_REG);
	wmb();

	/* wait a while for the device to reset */
	schedule_timeout_uninterruptible(msecs_to_jiffies(50));

	return 0;
}

static int
islpci_upload_fw(islpci_private *priv)
{
	islpci_state_t old_state;
	u32 rc;

	old_state = islpci_set_state(priv, PRV_STATE_BOOT);

	printk(KERN_DEBUG "%s: uploading firmware...\n", priv->ndev->name);

	rc = isl_upload_firmware(priv);
	if (rc) {
		/* error uploading the firmware */
		printk(KERN_ERR "%s: could not upload firmware ('%s')\n",
		       priv->ndev->name, priv->firmware);

		islpci_set_state(priv, old_state);
		return rc;
	}

	printk(KERN_DEBUG "%s: firmware upload complete\n",
	       priv->ndev->name);

	islpci_set_state(priv, PRV_STATE_POSTBOOT);

	return 0;
}

static int
islpci_reset_if(islpci_private *priv)
{
	long remaining;
	int result = -ETIME;
	int count;

	DEFINE_WAIT(wait);
	prepare_to_wait(&priv->reset_done, &wait, TASK_UNINTERRUPTIBLE);

	/* now the last step is to reset the interface */
	isl38xx_interface_reset(priv->device_base, priv->device_host_address);
	islpci_set_state(priv, PRV_STATE_PREINIT);

        for(count = 0; count < 2 && result; count++) {
		/* The software reset acknowledge needs about 220 msec here.
		 * Be conservative and wait for up to one second. */

		remaining = schedule_timeout_uninterruptible(HZ);

		if(remaining > 0) {
			result = 0;
			break;
		}

		/* If we're here it's because our IRQ hasn't yet gone through.
		 * Retry a bit more...
		 */
		printk(KERN_ERR "%s: no 'reset complete' IRQ seen - retrying\n",
			priv->ndev->name);
	}

	finish_wait(&priv->reset_done, &wait);

	if (result) {
		printk(KERN_ERR "%s: interface reset failure\n", priv->ndev->name);
		return result;
	}

	islpci_set_state(priv, PRV_STATE_INIT);

	/* Now that the device is 100% up, let's allow
	 * for the other interrupts --
	 * NOTE: this is not *yet* true since we've only allowed the
	 * INIT interrupt on the IRQ line. We can perhaps poll
	 * the IRQ line until we know for sure the reset went through */
	isl38xx_enable_common_interrupts(priv->device_base);

	down_write(&priv->mib_sem);
	result = mgt_commit(priv);
	if (result) {
		printk(KERN_ERR "%s: interface reset failure\n", priv->ndev->name);
		up_write(&priv->mib_sem);
		return result;
	}
	up_write(&priv->mib_sem);

	islpci_set_state(priv, PRV_STATE_READY);

	printk(KERN_DEBUG "%s: interface reset complete\n", priv->ndev->name);
	return 0;
}

int
islpci_reset(islpci_private *priv, int reload_firmware)
{
	isl38xx_control_block *cb =    /* volatile not needed */
		(isl38xx_control_block *) priv->control_block;
	unsigned counter;
	int rc;

	if (reload_firmware)
		islpci_set_state(priv, PRV_STATE_PREBOOT);
	else
		islpci_set_state(priv, PRV_STATE_POSTBOOT);

	printk(KERN_DEBUG "%s: resetting device...\n", priv->ndev->name);

	/* disable all device interrupts in case they weren't */
	isl38xx_disable_interrupts(priv->device_base);

	/* flush all management queues */
	priv->index_mgmt_tx = 0;
	priv->index_mgmt_rx = 0;

	/* clear the indexes in the frame pointer */
	for (counter = 0; counter < ISL38XX_CB_QCOUNT; counter++) {
		cb->driver_curr_frag[counter] = cpu_to_le32(0);
		cb->device_curr_frag[counter] = cpu_to_le32(0);
	}

	/* reset the mgmt receive queue */
	for (counter = 0; counter < ISL38XX_CB_MGMT_QSIZE; counter++) {
		isl38xx_fragment *frag = &cb->rx_data_mgmt[counter];
		frag->size = cpu_to_le16(MGMT_FRAME_SIZE);
		frag->flags = 0;
		frag->address = cpu_to_le32(priv->mgmt_rx[counter].pci_addr);
	}

	for (counter = 0; counter < ISL38XX_CB_RX_QSIZE; counter++) {
		cb->rx_data_low[counter].address =
		    cpu_to_le32((u32) priv->pci_map_rx_address[counter]);
	}

	/* since the receive queues are filled with empty fragments, now we can
	 * set the corresponding indexes in the Control Block */
	priv->control_block->driver_curr_frag[ISL38XX_CB_RX_DATA_LQ] =
	    cpu_to_le32(ISL38XX_CB_RX_QSIZE);
	priv->control_block->driver_curr_frag[ISL38XX_CB_RX_MGMTQ] =
	    cpu_to_le32(ISL38XX_CB_MGMT_QSIZE);

	/* reset the remaining real index registers and full flags */
	priv->free_data_rx = 0;
	priv->free_data_tx = 0;
	priv->data_low_tx_full = 0;

	if (reload_firmware) { /* Should we load the firmware ? */
	/* now that the data structures are cleaned up, upload
	 * firmware and reset interface */
		rc = islpci_upload_fw(priv);
		if (rc) {
			printk(KERN_ERR "%s: islpci_reset: failure\n",
				priv->ndev->name);
			return rc;
		}
	}

	/* finally reset interface */
	rc = islpci_reset_if(priv);
	if (rc)
		printk(KERN_ERR "prism54: Your card/socket may be faulty, or IRQ line too busy :(\n");
	return rc;
}

/******************************************************************************
    Network device configuration functions
******************************************************************************/
static int
islpci_alloc_memory(islpci_private *priv)
{
	int counter;

#if VERBOSE > SHOW_ERROR_MESSAGES
	printk(KERN_DEBUG "islpci_alloc_memory\n");
#endif

	/* remap the PCI device base address to accessible */
	if (!(priv->device_base =
	      ioremap(pci_resource_start(priv->pdev, 0),
		      ISL38XX_PCI_MEM_SIZE))) {
		/* error in remapping the PCI device memory address range */
		printk(KERN_ERR "PCI memory remapping failed\n");
		return -1;
	}

	/* memory layout for consistent DMA region:
	 *
	 * Area 1: Control Block for the device interface
	 * Area 2: Power Save Mode Buffer for temporary frame storage. Be aware that
	 *         the number of supported stations in the AP determines the minimal
	 *         size of the buffer !
	 */

	/* perform the allocation */
	priv->driver_mem_address = pci_alloc_consistent(priv->pdev,
							HOST_MEM_BLOCK,
							&priv->
							device_host_address);

	if (!priv->driver_mem_address) {
		/* error allocating the block of PCI memory */
		printk(KERN_ERR "%s: could not allocate DMA memory, aborting!",
		       "prism54");
		return -1;
	}

	/* assign the Control Block to the first address of the allocated area */
	priv->control_block =
	    (isl38xx_control_block *) priv->driver_mem_address;

	/* set the Power Save Buffer pointer directly behind the CB */
	priv->device_psm_buffer =
		priv->device_host_address + CONTROL_BLOCK_SIZE;

	/* make sure all buffer pointers are initialized */
	for (counter = 0; counter < ISL38XX_CB_QCOUNT; counter++) {
		priv->control_block->driver_curr_frag[counter] = cpu_to_le32(0);
		priv->control_block->device_curr_frag[counter] = cpu_to_le32(0);
	}

	priv->index_mgmt_rx = 0;
	memset(priv->mgmt_rx, 0, sizeof(priv->mgmt_rx));
	memset(priv->mgmt_tx, 0, sizeof(priv->mgmt_tx));

	/* allocate rx queue for management frames */
	if (islpci_mgmt_rx_fill(priv->ndev) < 0)
		goto out_free;

	/* now get the data rx skb's */
	memset(priv->data_low_rx, 0, sizeof (priv->data_low_rx));
	memset(priv->pci_map_rx_address, 0, sizeof (priv->pci_map_rx_address));

	for (counter = 0; counter < ISL38XX_CB_RX_QSIZE; counter++) {
		struct sk_buff *skb;

		/* allocate an sk_buff for received data frames storage
		 * each frame on receive size consists of 1 fragment
		 * include any required allignment operations */
		if (!(skb = dev_alloc_skb(MAX_FRAGMENT_SIZE_RX + 2))) {
			/* error allocating an sk_buff structure elements */
			printk(KERN_ERR "Error allocating skb.\n");
			skb = NULL;
			goto out_free;
		}
		skb_reserve(skb, (4 - (long) skb->data) & 0x03);
		/* add the new allocated sk_buff to the buffer array */
		priv->data_low_rx[counter] = skb;

		/* map the allocated skb data area to pci */
		priv->pci_map_rx_address[counter] =
		    pci_map_single(priv->pdev, (void *) skb->data,
				   MAX_FRAGMENT_SIZE_RX + 2,
				   PCI_DMA_FROMDEVICE);
		if (pci_dma_mapping_error(priv->pdev,
					  priv->pci_map_rx_address[counter])) {
			priv->pci_map_rx_address[counter] = 0;
			/* error mapping the buffer to device
			   accessible memory address */
			printk(KERN_ERR "failed to map skb DMA'able\n");
			goto out_free;
		}
	}

	prism54_acl_init(&priv->acl);
	prism54_wpa_bss_ie_init(priv);
	if (mgt_init(priv))
		goto out_free;

	return 0;
 out_free:
	islpci_free_memory(priv);
	return -1;
}

int
islpci_free_memory(islpci_private *priv)
{
	int counter;

	if (priv->device_base)
		iounmap(priv->device_base);
	priv->device_base = NULL;

	/* free consistent DMA area... */
	if (priv->driver_mem_address)
		pci_free_consistent(priv->pdev, HOST_MEM_BLOCK,
				    priv->driver_mem_address,
				    priv->device_host_address);

	/* clear some dangling pointers */
	priv->driver_mem_address = NULL;
	priv->device_host_address = 0;
	priv->device_psm_buffer = 0;
	priv->control_block = NULL;

        /* clean up mgmt rx buffers */
        for (counter = 0; counter < ISL38XX_CB_MGMT_QSIZE; counter++) {
		struct islpci_membuf *buf = &priv->mgmt_rx[counter];
		if (buf->pci_addr)
			pci_unmap_single(priv->pdev, buf->pci_addr,
					 buf->size, PCI_DMA_FROMDEVICE);
		buf->pci_addr = 0;
		kfree(buf->mem);
		buf->size = 0;
		buf->mem = NULL;
        }

	/* clean up data rx buffers */
	for (counter = 0; counter < ISL38XX_CB_RX_QSIZE; counter++) {
		if (priv->pci_map_rx_address[counter])
			pci_unmap_single(priv->pdev,
					 priv->pci_map_rx_address[counter],
					 MAX_FRAGMENT_SIZE_RX + 2,
					 PCI_DMA_FROMDEVICE);
		priv->pci_map_rx_address[counter] = 0;

		if (priv->data_low_rx[counter])
			dev_kfree_skb(priv->data_low_rx[counter]);
		priv->data_low_rx[counter] = NULL;
	}

	/* Free the access control list and the WPA list */
	prism54_acl_clean(&priv->acl);
	prism54_wpa_bss_ie_clean(priv);
	mgt_clean(priv);

	return 0;
}

#if 0
static void
islpci_set_multicast_list(struct net_device *dev)
{
	/* put device into promisc mode and let network layer handle it */
}
#endif

static void islpci_ethtool_get_drvinfo(struct net_device *dev,
                                       struct ethtool_drvinfo *info)
{
	strlcpy(info->driver, DRV_NAME, sizeof(info->driver));
	strlcpy(info->version, DRV_VERSION, sizeof(info->version));
}

static const struct ethtool_ops islpci_ethtool_ops = {
	.get_drvinfo = islpci_ethtool_get_drvinfo,
};

static const struct net_device_ops islpci_netdev_ops = {
	.ndo_open 		= islpci_open,
	.ndo_stop		= islpci_close,
	.ndo_start_xmit		= islpci_eth_transmit,
	.ndo_tx_timeout		= islpci_eth_tx_timeout,
	.ndo_set_mac_address 	= prism54_set_mac_address,
	.ndo_validate_addr	= eth_validate_addr,
};

static struct device_type wlan_type = {
	.name	= "wlan",
};

struct net_device *
islpci_setup(struct pci_dev *pdev)
{
	islpci_private *priv;
	struct net_device *ndev = alloc_etherdev(sizeof (islpci_private));

	if (!ndev)
		return ndev;

	pci_set_drvdata(pdev, ndev);
	SET_NETDEV_DEV(ndev, &pdev->dev);
	SET_NETDEV_DEVTYPE(ndev, &wlan_type);

	/* setup the structure members */
	ndev->base_addr = pci_resource_start(pdev, 0);
	ndev->irq = pdev->irq;

	/* initialize the function pointers */
	ndev->netdev_ops = &islpci_netdev_ops;
	ndev->wireless_handlers = &prism54_handler_def;
	ndev->ethtool_ops = &islpci_ethtool_ops;

	/* ndev->set_multicast_list = &islpci_set_multicast_list; */
	ndev->addr_len = ETH_ALEN;
	/* Get a non-zero dummy MAC address for nameif. Jean II */
	memcpy(ndev->dev_addr, dummy_mac, ETH_ALEN);

	ndev->watchdog_timeo = ISLPCI_TX_TIMEOUT;

	/* allocate a private device structure to the network device  */
	priv = netdev_priv(ndev);
	priv->ndev = ndev;
	priv->pdev = pdev;
	priv->monitor_type = ARPHRD_IEEE80211;
	priv->ndev->type = (priv->iw_mode == IW_MODE_MONITOR) ?
		priv->monitor_type : ARPHRD_ETHER;

	/* Add pointers to enable iwspy support. */
	priv->wireless_data.spy_data = &priv->spy_data;
	ndev->wireless_data = &priv->wireless_data;

	/* save the start and end address of the PCI memory area */
	ndev->mem_start = (unsigned long) priv->device_base;
	ndev->mem_end = ndev->mem_start + ISL38XX_PCI_MEM_SIZE;

#if VERBOSE > SHOW_ERROR_MESSAGES
	DEBUG(SHOW_TRACING, "PCI Memory remapped to 0x%p\n", priv->device_base);
#endif

	init_waitqueue_head(&priv->reset_done);

	/* init the queue read locks, process wait counter */
	mutex_init(&priv->mgmt_lock);
	priv->mgmt_received = NULL;
	init_waitqueue_head(&priv->mgmt_wqueue);
	mutex_init(&priv->stats_lock);
	spin_lock_init(&priv->slock);

	/* init state machine with off#1 state */
	priv->state = PRV_STATE_OFF;
	priv->state_off = 1;

	/* initialize workqueue's */
	INIT_WORK(&priv->stats_work, prism54_update_stats);
	priv->stats_timestamp = 0;

	INIT_WORK(&priv->reset_task, islpci_do_reset_and_wake);
	priv->reset_task_pending = 0;

	/* allocate various memory areas */
	if (islpci_alloc_memory(priv))
		goto do_free_netdev;

	/* select the firmware file depending on the device id */
	switch (pdev->device) {
	case 0x3877:
		strcpy(priv->firmware, ISL3877_IMAGE_FILE);
		break;

	case 0x3886:
		strcpy(priv->firmware, ISL3886_IMAGE_FILE);
		break;

	default:
		strcpy(priv->firmware, ISL3890_IMAGE_FILE);
		break;
	}

	if (register_netdev(ndev)) {
		DEBUG(SHOW_ERROR_MESSAGES,
		      "ERROR: register_netdev() failed\n");
		goto do_islpci_free_memory;
	}

	return ndev;

      do_islpci_free_memory:
	islpci_free_memory(priv);
      do_free_netdev:
	free_netdev(ndev);
	priv = NULL;
	return NULL;
}

islpci_state_t
islpci_set_state(islpci_private *priv, islpci_state_t new_state)
{
	islpci_state_t old_state;

	/* lock */
	old_state = priv->state;

	/* this means either a race condition or some serious error in
	 * the driver code */
	switch (new_state) {
	case PRV_STATE_OFF:
		priv->state_off++;
		/* fall through */
	default:
		priv->state = new_state;
		break;

	case PRV_STATE_PREBOOT:
		/* there are actually many off-states, enumerated by
		 * state_off */
		if (old_state == PRV_STATE_OFF)
			priv->state_off--;

		/* only if hw_unavailable is zero now it means we either
		 * were in off#1 state, or came here from
		 * somewhere else */
		if (!priv->state_off)
			priv->state = new_state;
		break;
	}
#if 0
	printk(KERN_DEBUG "%s: state transition %d -> %d (off#%d)\n",
	       priv->ndev->name, old_state, new_state, priv->state_off);
#endif

	/* invariants */
	BUG_ON(priv->state_off < 0);
	BUG_ON(priv->state_off && (priv->state != PRV_STATE_OFF));
	BUG_ON(!priv->state_off && (priv->state == PRV_STATE_OFF));

	/* unlock */
	return old_state;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #pragma once
#include <vector>
#include <map>
#include <deque>
#include <memory>
#include <opencv2/opencv.hpp>
#include <Eigen/Dense>
#include <sophus/se3.hpp>
#include "integration_base.h"
#include "ceres/marginalization_factor.h"

class VINSStereo {
public:
    EIGEN_MAKE_ALIGNED_OPERATOR_NEW
    enum State {
        NEED_INIT,
        CV_ONLY,
        TIGHTLY
    };

    enum MarginType {
        MARGIN_SECOND_NEW,
        MARGIN_OLD
    };

    struct Frame {
        EIGEN_MAKE_ALIGNED_OPERATOR_NEW
        Frame() {}
        virtual ~Frame() {}
        cv::Mat img;
        double timestamp;
        uint8_t seq;
        std::vector<uint64_t>  pt_id;
        std::vector<Eigen::Vector2d> v_pt; // point on image
        std::vector<Eigen::Vector3d> pt_normal_plane, pt_r_normal_plane; // point on normal plane

        Sophus::SO3d    q_wb;
        Eigen::Vector3d p_wb;
        Sophus::SE3d    Twb() const;

        Eigen::Vector3d v_wb;
        Eigen::Vector3d ba;
        Eigen::Vector3d bg;

        std::vector<Eigen::Vector3d> v_gyr, v_acc;
        std::vector<double> v_imu_timestamp;
        IntegrationBasePtr imupreinte;
        double td; // time delay
    };
    using FramePtr = std::shared_ptr<Frame>;
    using FrameConstPtr = std::shared_ptr<const Frame>;

    struct KeyFrame {
        FrameConstPtr frame;
        std::vector<Eigen::Vector3d> v_x3Dc;
    };
    using KeyFramePtr = std::shared_ptr<KeyFrame>;
    using KeyFrameConstPtr = std::shared_ptr<const KeyFrame>;

    struct Feature {
        EIGEN_MAKE_ALIGNED_OPERATOR_NEW
        Feature(uint64_t feat_id_, int start_id_)
            : feat_id(feat_id_), start_id(start_id_),
              inv_depth(-1.0f), last_time(-1.0f), last_r_time(-1.0f) {}

        uint64_t feat_id;
        int start_id;

        int CountNumMeas(int sw_idx) const;

        std::deque<Eigen::Vector3d> pt_n_per_frame;
        std::deque<Eigen::Vector3d> pt_r_n_per_frame;
        double inv_depth;

        // estimate time delay
        std::deque<Eigen::Vector3d> velocity_per_frame;
        std::deque<Eigen::Vector3d> velocity_r_per_frame;
        Eigen::Vector3d last_pt_n;
        Eigen::Vector3d last_pt_r_n;
        double last_time, last_r_time;
    };

    struct Result {
        State state;
        FramePtr cur_frame;
        Sophus::SE3d Tbc;

        KeyFramePtr keyframe;
    };

    VINSStereo(double focal_length_,
               double gyr_n_, double acc_n_,
               double gyr_w_, double acc_w_,
               const Sophus::SO3d& q_bc_, const Eigen::Vector3d& p_bc_,
               const Sophus::SO3d& q_rl_, const Eigen::Vector3d& p_rl_,
               double gravity_magnitude_, int window_size_, double min_parallax_,
               double max_solver_time_in_seconds_, int max_num_iterations_,
               double cv_huber_loss_parameter_, double triangulate_default_depth_,
               double max_imu_sum_t_, int min_init_stereo_num_, int estimate_extrinsic,
               int estimate_td, double init_td);
    ~VINSStereo();

    inline void ResetRequest() {
        request_reset_flag = true;
    }

    Result Process(cv::Mat img, double t, uint8_t seq, const std::vector<uint64_t>& v_pt_id,
                   const std::vector<Eigen::Vector2d>& v_pt, const std::vector<Eigen::Vector3d>& v_pt_n,
                   const std::vector<Eigen::Vector3d>& v_pt_r_n, const std::vector<Eigen::Vector3d>& v_gyr,
                   const std::vector<Eigen::Vector3d>& v_acc, const std::vector<double>& v_imu_t);
    void Reset();

    inline double GetTd() const {
        return time_delay;
    }

protected:
    MarginType AddFeaturesCheckParallax(FramePtr frame);
    void AddFeatures(FramePtr frame, int& last_track_num);
    void SlidingWindow();
    void SlidingWindowOld();
    void SlidingWindowSecondNew();
    int Triangulate(int sw_idx);
    void SolveBA();
    void SolveBAImu();
    void SolvePnP(FramePtr frame);
    bool GyroBiasEstimation();
    Sophus::SO3d InitFirstIMUPose(const std::vector<Eigen::Vector3d>& v_acc);
    void PredictNextFramePose(FramePtr ref_frame, FramePtr cur_frame);
    void Marginalize();

    State state;
    double focal_length;
    Eigen::Vector3d p_rl, p_bc;
    Sophus::SO3d    q_rl, q_bc;

    double gyr_n, acc_n, gyr_w, acc_w;
    Eigen::Matrix3d gyr_noise_cov;
    Eigen::Matrix3d acc_noise_cov;
    Eigen::Matrix<double, 6, 6> gyr_acc_noise_cov;
    Eigen::Matrix3d gyr_bias_cov;
    Eigen::Matrix3d acc_bias_cov;
    Eigen::Matrix<double, 6, 6> acc_gyr_bias_invcov;

    std::map<uint64_t, Feature> m_features;
    int window_size;
    std::deque<FramePtr> d_frames; // [ 0,  1, ..., 8 ,         9 |  10] size 11
                                   //  kf  kf      kf  second new   new
    uint64_t next_frame_id;

    double min_parallax;
    MarginType marginalization_flag;

    // ceres data
    virtual void data2double();
    virtual void double2data();
    double* para_pose; // Twb
    double* para_speed_bias; // vwb bg ba
    size_t  para_features_capacity = 1000;
    double* para_features; // inv_z
    int enable_estimate_extrinsic;
    double para_ex_bc[7];
    double para_ex_sm[7];

    // maintain system
    std::atomic<bool> request_reset_flag;

    double last_imu_t;
    double gravity_magnitude;
    Eigen::Vector3d gw;

    std::vector<double*> para_margin_block;
    MarginalizationInfo* last_margin_info;

    std::vector<Eigen::Vector3d> margin_mps;

    // optimize parameters
    double max_solver_time_in_seconds;
    int max_num_iterations;
    double cv_huber_loss_parameter;
    double triangulate_default_depth;
    double max_imu_sum_t;
    int min_init_stereo_num;

    bool estimate_time_delay;
    double time_delay;
    double para_Td[1];

    KeyFramePtr margin_keyframe;
};
using VINSStereoPtr = std::shared_ptr<VINSStereo>;
using VINSStereoConstPtr = std::shared_ptr<const VINSStereo>;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # CMAKE generated file: DO NOT EDIT!
# Generated by "Unix Makefiles" Generator, CMake Version 3.10

# Delete rule output on recipe failure.
.DELETE_ON_ERROR:


#=============================================================================
# Special targets provided by cmake.

# Disable implicit rules so canonical targets will work.
.SUFFIXES:


# Remove some rules from gmake that .SUFFIXES does not remove.
SUFFIXES =

.SUFFIXES: .hpux_make_needs_suffix_list


# Suppress display of executed commands.
$(VERBOSE).SILENT:


# A target that is always out of date.
cmake_force:

.PHONY : cmake_force

#=============================================================================
# Set environment variables for the build.

# The shell in which to execute make rules.
SHELL = /bin/sh

# The CMake executable.
CMAKE_COMMAND = /usr/bin/cmake

# The command to remove a file.
RM = /usr/bin/cmake -E remove -f

# Escaping for special characters.
EQUALS = =

# The top-level source directory on which CMake was run.
CMAKE_SOURCE_DIR = /catkin_ws/src/libslam/slam_depends/sophus

# The top-level build directory on which CMake was run.
CMAKE_BINARY_DIR = /catkin_ws/build/sophus

# Utility rule file for tests.

# Include the progress variables for this target.
include CMakeFiles/tests.dir/progress.make

tests: CMakeFiles/tests.dir/build.make

.PHONY : tests

# Rule to build all files generated by this target.
CMakeFiles/tests.dir/build: tests

.PHONY : CMakeFiles/tests.dir/build

CMakeFiles/tests.dir/clean:
	$(CMAKE_COMMAND) -P CMakeFiles/tests.dir/cmake_clean.cmake
.PHONY : CMakeFiles/tests.dir/clean

CMakeFiles/tests.dir/depend:
	cd /catkin_ws/build/sophus && $(CMAKE_COMMAND) -E cmake_depends "Unix Makefiles" /catkin_ws/src/libslam/slam_depends/sophus /catkin_ws/src/libslam/slam_depends/sophus /catkin_ws/build/sophus /catkin_ws/build/sophus /catkin_ws/build/sophus/CMakeFiles/tests.dir/DependInfo.cmake --color=$(COLOR)
.PHONY : CMakeFiles/tests.dir/depend

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 y?Frj~Z+7    T       @  ow`"!                $               0    %                 D               ,    	                                                                                   
   ./internal      Y           ./utf32            ./utf16 |           ./utf7  :J           ./sbcs-codec               ./sbcs-data     @_           ./sbcs-data-generated   g           ./dbcs-codec    V{           ./dbcs-data     QS           hasOwnProperty          ,    A   !6!0!0!.!:!8!L!:	#x
2@ >*       :aX   0          w  %&&&[.&&[.&&[.&&[	.&&[.&&[.&&[.&&[.&	&[.'&(
fa%)&NLt&=/&&&(&(&(!&X#%)%.'&=%J)&e (           ]                         g       z  *     P
 @ 4<        M   /usr/share/code/resources/app/node_modules.asar/iconv-lite/encodings/index.js                                         1       ~
  ~
 ~
          
 	                    1 
x    @   H       ?   |  &(&'
'	''''U ,    	       \                             
              
   
 	                                  ?   |   &      $           C                                              
         /////////                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                namespace Eigen {

/** \page TopicFunctionTakingEigenTypes Writing Functions Taking %Eigen Types as Parameters

%Eigen's use of expression templates results in potentially every expression being of a different type. If you pass such an expression to a function taking a parameter of type Matrix, your expression will implicitly be evaluated into a temporary Matrix, which will then be passed to the function. This means that you lose the benefit of expression templates. Concretely, this has two drawbacks:
 \li The evaluation into a temporary may be useless and inefficient;
 \li This only allows the function to read from the expression, not to write to it.

Fortunately, all this myriad of expression types have in common that they all inherit a few common, templated base classes. By letting your function take templated parameters of these base types, you can let them play nicely with %Eigen's expression templates.

\eigenAutoToc

\section TopicFirstExamples Some First Examples

This section will provide simple examples for different types of objects %Eigen is offering. Before starting with the actual examples, we need to recapitulate which base objects we can work with (see also \ref TopicClassHierarchy).

 \li MatrixBase: The common base class for all dense matrix expressions (as opposed to array expressions, as opposed to sparse and special matrix classes). Use it in functions that are meant to work only on dense matrices.
 \li ArrayBase: The common base class for all dense array expressions (as opposed to matrix expressions, etc). Use it in functions that are meant to work only on arrays.
 \li DenseBase: The common base class for all dense matrix expression, that is, the base class for both \c MatrixBase and \c ArrayBase. It can be used in functions that are meant to work on both matrices and arrays.
 \li EigenBase: The base class unifying all types of objects that can be evaluated into dense matrices or arrays, for example special matrix classes such as diagonal matrices, permutation matrices, etc. It can be used in functions that are meant to work on any such general type.

<b> %EigenBase Example </b><br/><br/>
Prints the dimensions of the most generic object present in %Eigen. It could be any matrix expressions, any dense or sparse matrix and any array.
<table class="example">
<tr><th>Example:</th><th>Output:</th></tr>
<tr><td>
\include function_taking_eigenbase.cpp
</td>
<td>
\verbinclude function_taking_eigenbase.out
</td></tr></table>
<b> %DenseBase Example </b><br/><br/>
Prints a sub-block of the dense expression. Accepts any dense matrix or array expression, but no sparse objects and no special matrix classes such as DiagonalMatrix.
\code
template <typename Derived>
void print_block(const DenseBase<Derived>& b, int x, int y, int r, int c)
{
  std::cout << "block: " << b.block(x,y,r,c) << std::endl;
}
\endcode
<b> %ArrayBase Example </b><br/><br/>
Prints the maximum coefficient of the array or array-expression.
\code
template <typename Derived>
void print_max_coeff(const ArrayBase<Derived> &a)
{
  std::cout << "max: " << a.maxCoeff() << std::endl;
}
\endcode
<b> %MatrixBase Example </b><br/><br/>
Prints the inverse condition number of the given matrix or matrix-expression.
\code
template <typename Derived>
void print_inv_cond(const MatrixBase<Derived>& a)
{
  const typename JacobiSVD<typename Derived::PlainObject>::SingularValuesType&
    sing_vals = a.jacobiSvd().singularValues();
  std::cout << "inv cond: " << sing_vals(sing_vals.size()-1) / sing_vals(0) << std::endl;
}
\endcode
<b> Multiple templated arguments example </b><br/><br/>
Calculate the Euclidean distance between two points.
\code
template <typename DerivedA,typename DerivedB>
typename DerivedA::Scalar squaredist(const MatrixBase<DerivedA>& p1,const MatrixBase<DerivedB>& p2)
{
  return (p1-p2).squaredNorm();
}
\endcode
Notice that we used two template parameters, one per argument. This permits the function to handle inputs of different types, e.g.,
\code
squaredist(v1,2*v2)
\endcode
where the first argument \c v1 is a vector and the second argument \c 2*v2 is an expression.
<br/><br/>

These examples are just intended to give the reader a first impression of how functions can be written which take a plain and constant Matrix or Array argument. They are also intended to give the reader an idea about the most common base classes being the optimal candidates for functions. In the next section we will look in more detail at an example and the different ways it can be implemented, while discussing each implementation's problems and advantages. For the discussion below, Matrix and Array as well as MatrixBase and ArrayBase can be exchanged and all arguments still hold.


\section TopicUsingRefClass How to write generic, but non-templated function?

In all the previous examples, the functions had to be template functions. This approach allows to write very generic code, but it is often desirable to write non templated function and still keep some level of genericity to avoid stupid copies of the arguments. The typical example is to write functions accepting both a MatrixXf or a block of a MatrixXf. This exactly the purpose of the Ref class. Here is a simple example:

<table class="example">
<tr><th>Example:</th><th>Output:</th></tr>
<tr><td>
\include function_taking_ref.cpp
</td>
<td>
\verbinclude function_taking_ref.out
</td></tr></table>
In the first two calls to inv_cond, no copy occur because the memory layout of the arguments matches the memory layout accepted by Ref<MatrixXf>. However, in the last call, we have a generic expression that will be automatically evaluated into a temporary MatrixXf by the Ref<> object.

A Ref object can also be writable. Here is an example of a function computing the covariance matrix of two input matrices where each row is an observation:
\code
void cov(const Ref<const MatrixXf> x, const Ref<const MatrixXf> y, Ref<MatrixXf> C)
{
  const float num_observations = static_cast<float>(x.rows());
  const RowVectorXf x_mean = x.colwise().sum() / num_observations;
  const RowVectorXf y_mean = y.colwise().sum() / num_observations;
  C = (x.rowwise() - x_mean).transpose() * (y.rowwise() - y_mean) / num_observations;
}
\endcode
and here are two examples calling cov without any copy:
\code
MatrixXf m1, m2, m3
cov(m1, m2, m3);
cov(m1.leftCols<3>(), m2.leftCols<3>(), m3.topLeftCorner<3,3>());
\endcode
The Ref<> class has two other optional template arguments allowing to control the kind of memory layout that can be accepted without any copy. See the class Ref documentation for the details.

\section TopicPlainFunctionsWorking In which cases do functions taking plain Matrix or Array arguments work?

Without using template functions, and without the Ref class, a naive implementation of the previous cov function might look like this
\code
MatrixXf cov(const MatrixXf& x, const MatrixXf& y)
{
  const float num_observations = static_cast<float>(x.rows());
  const RowVectorXf x_mean = x.colwise().sum() / num_observations;
  const RowVectorXf y_mean = y.colwise().sum() / num_observations;
  return (x.rowwise() - x_mean).transpose() * (y.rowwise() - y_mean) / num_observations;
}
\endcode
and contrary to what one might think at first, this implementation is fine unless you require a generic implementation that works with double matrices too and unless you do not care about temporary objects. Why is that the case? Where are temporaries involved? How can code as given below compile?
\code
MatrixXf x,y,z;
MatrixXf C = cov(x,y+z);
\endcode
In this special case, the example is fine and will be working because both parameters are declared as \e const references. The compiler creates a temporary and evaluates the expression x+z into this temporary. Once the function is processed, the temporary is released and the result is assigned to C.

\b Note: Functions taking \e const references to Matrix (or Array) can process expressions at the cost of temporaries.


\section TopicPlainFunctionsFailing In which cases do functions taking a plain Matrix or Array argument fail?

Here, we consider a slightly modified version of the function given above. This time, we do not want to return the result but pass an additional non-const paramter which allows us to store the result. A first naive implementation might look as follows.
\code
// Note: This code is flawed!
void cov(const MatrixXf& x, const MatrixXf& y, MatrixXf& C)
{
  const float num_observations = static_cast<float>(x.rows());
  const RowVectorXf x_mean = x.colwise().sum() / num_observations;
  const RowVectorXf y_mean = y.colwise().sum() / num_observations;
  C = (x.rowwise() - x_mean).transpose() * (y.rowwise() - y_mean) / num_observations;
}
\endcode
When trying to execute the following code
\code
MatrixXf C = MatrixXf::Zero(3,6);
cov(x,y, C.block(0,0,3,3));
\endcode
the compiler will fail, because it is not possible to convert the expression returned by \c MatrixXf::block() into a non-const \c MatrixXf&. This is the case because the compiler wants to protect you from writing your result to a temporary object. In this special case this protection is not intended -- we want to write to a temporary object. So how can we overcome this problem? 

The solution which is preferred at the moment is based on a little \em hack. One needs to pass a const reference to the matrix and internally the constness needs to be cast away. The correct implementation for C98 compliant compilers would be
\code
template <typename Derived, typename OtherDerived>
void cov(const MatrixBase<Derived>& x, const MatrixBase<Derived>& y, MatrixBase<OtherDerived> const & C)
{
  typedef typename Derived::Scalar Scalar;
  typedef typename internal::plain_row_type<Derived>::type RowVectorType;

  const Scalar num_observations = static_cast<Scalar>(x.rows());

  const RowVectorType x_mean = x.colwise().sum() / num_observations;
  const RowVectorType y_mean = y.colwise().sum() / num_observations;

  const_cast< MatrixBase<OtherDerived>& >(C) =
    (x.rowwise() - x_mean).transpose() * (y.rowwise() - y_mean) / num_observations;
}
\endcode
The implementation above does now not only work with temporary expressions but it also allows to use the function with matrices of arbitrary floating point scalar types.

\b Note: The const cast hack will only work with templated functions. It will not work with the MatrixXf implementation because it is not possible to cast a Block expression to a Matrix reference!



\section TopicResizingInGenericImplementations How to resize matrices in generic implementations?

One might think we are done now, right? This is not completely true because in order for our covariance function to be generically applicable, we want the follwing code to work
\code
MatrixXf x = MatrixXf::Random(100,3);
MatrixXf y = MatrixXf::Random(100,3);
MatrixXf C;
cov(x, y, C);
\endcode
This is not the case anymore, when we are using an implementation taking MatrixBase as a parameter. In general, %Eigen supports automatic resizing but it is not possible to do so on expressions. Why should resizing of a matrix Block be allowed? It is a reference to a sub-matrix and we definitely don't want to resize that. So how can we incorporate resizing if we cannot resize on MatrixBase? The solution is to resize the derived object as in this implementation.
\code
template <typename Derived, typename OtherDerived>
void cov(const MatrixBase<Derived>& x, const MatrixBase<Derived>& y, MatrixBase<OtherDerived> const & C_)
{
  typedef typename Derived::Scalar Scalar;
  typedef typename internal::plain_row_type<Derived>::type RowVectorType;

  const Scalar num_observations = static_cast<Scalar>(x.rows());

  const RowVectorType x_mean = x.colwise().sum() / num_observations;
  const RowVectorType y_mean = y.colwise().sum() / num_observations;

  MatrixBase<OtherDerived>& C = const_cast< MatrixBase<OtherDerived>& >(C_);
  
  C.derived().resize(x.cols(),x.cols()); // resize the derived object
  C = (x.rowwise() - x_mean).transpose() * (y.rowwise() - y_mean) / num_observations;
}
\endcode
This implementation is now working for parameters being expressions and for parameters being matrices and having the wrong size. Resizing the expressions does not do any harm in this case unless they actually require resizing. That means, passing an expression with the wrong dimensions will result in a run-time error (in debug mode only) while passing expressions of the correct size will just work fine.

\b Note: In the above discussion the terms Matrix and Array and MatrixBase and ArrayBase can be exchanged and all arguments still hold.

\section TopicSummary Summary

  - To summarize, the implementation of functions taking non-writable (const referenced) objects is not a big issue and does not lead to problematic situations in terms of compiling and running your program. However, a naive implementation is likely to introduce unnecessary temporary objects in your code. In order to avoid evaluating parameters into temporaries, pass them as (const) references to MatrixBase or ArrayBase (so templatize your function).

  - Functions taking writable (non-const) parameters must take const references and cast away constness within the function body.

  - Functions that take as parameters MatrixBase (or ArrayBase) objects, and potentially need to resize them (in the case where they are resizable), must call resize() on the derived class, as returned by derived().
*/
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # CMAKE generated file: DO NOT EDIT!
# Generated by "Unix Makefiles" Generator, CMake Version 3.10

# Relative path conversion top directories.
set(CMAKE_RELATIVE_PATH_TOP_SOURCE "/usr/src/googletest")
set(CMAKE_RELATIVE_PATH_TOP_BINARY "/kalibr_ws/build/numpy_eigen")

# Force unix paths in dependencies.
set(CMAKE_FORCE_UNIX_PATHS 1)


# The C and CXX include file regular expressions for this directory.
set(CMAKE_C_INCLUDE_REGEX_SCAN "^.*$")
set(CMAKE_C_INCLUDE_REGEX_COMPLAIN "^$")
set(CMAKE_CXX_INCLUDE_REGEX_SCAN ${CMAKE_C_INCLUDE_REGEX_SCAN})
set(CMAKE_CXX_INCLUDE_REGEX_COMPLAIN ${CMAKE_C_INCLUDE_REGEX_COMPLAIN})
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 # Install script for directory: /usr/src/googletest/googletest

# Set the install prefix
if(NOT DEFINED CMAKE_INSTALL_PREFIX)
  set(CMAKE_INSTALL_PREFIX "/kalibr_ws/install")
endif()
string(REGEX REPLACE "/$" "" CMAKE_INSTALL_PREFIX "${CMAKE_INSTALL_PREFIX}")

# Set the install configuration name.
if(NOT DEFINED CMAKE_INSTALL_CONFIG_NAME)
  if(BUILD_TYPE)
    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
           CMAKE_INSTALL_CONFIG_NAME "${BUILD_TYPE}")
  else()
    set(CMAKE_INSTALL_CONFIG_NAME "Release")
  endif()
  message(STATUS "Install configuration: \"${CMAKE_INSTALL_CONFIG_NAME}\"")
endif()

# Set the component getting installed.
if(NOT CMAKE_INSTALL_COMPONENT)
  if(COMPONENT)
    message(STATUS "Install component: \"${COMPONENT}\"")
    set(CMAKE_INSTALL_COMPONENT "${COMPONENT}")
  else()
    set(CMAKE_INSTALL_COMPONENT)
  endif()
endif()

# Install shared libraries without execute permission?
if(NOT DEFINED CMAKE_INSTALL_SO_NO_EXE)
  set(CMAKE_INSTALL_SO_NO_EXE "1")
endif()

# Is this installation the result of a crosscompile?
if(NOT DEFINED CMAKE_CROSSCOMPILING)
  set(CMAKE_CROSSCOMPILING "FALSE")
endif()

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /******************************************************************************
 * Copyright (C) 2012 by Jerome Maye                                          *
 * jerome.maye@gmail.com                                                      *
 *                                                                            *
 * This program is free software; you can redistribute it and/or modify       *
 * it under the terms of the Lesser GNU General Public License as published by*
 * the Free Software Foundation; either version 3 of the License, or          *
 * (at your option) any later version.                                        *
 *                                                                            *
 * This program is distributed in the hope that it will be useful,            *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of             *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              *
 * Lesser GNU General Public License for more details.                        *
 *                                                                            *
 * You should have received a copy of the Lesser GNU General Public License   *
 * along with this program. If not, see <http://www.gnu.org/licenses/>.       *
 ******************************************************************************/

#include "aslam/backend/SparseQRLinearSolverOptions.h"

#include <SuiteSparseQR.hpp>

namespace aslam {
  namespace backend {

/******************************************************************************/
/* Constructors and Destructor                                                */
/******************************************************************************/

    SparseQRLinearSolverOptions::SparseQRLinearSolverOptions() :
        colNorm(false),
        qrTol(SPQR_DEFAULT_TOL),
        normTol(1e-8),
        verbose(false) {
    }

    SparseQRLinearSolverOptions::SparseQRLinearSolverOptions(
        const SparseQRLinearSolverOptions& other) :
        colNorm(other.colNorm),
        qrTol(other.qrTol),
        normTol(other.normTol),
        verbose(other.verbose) {
    }

    SparseQRLinearSolverOptions& SparseQRLinearSolverOptions::operator =
        (const SparseQRLinearSolverOptions& other) {
      if (this != &other) {
        colNorm = other.colNorm;
        qrTol = other.qrTol;
        normTol = other.normTol;
        verbose = other.verbose;
      }
      return *this;
    }

    SparseQRLinearSolverOptions::~SparseQRLinearSolverOptions() {
    }

  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        PNG

   IHDR  @       TF    IDATxD\	/HJD,A;4UhRD*x3CY{31:
0"
L112QPu!Ub5FWSUWYU");1<*L:
*X@.w*Y*X`/L>]1**]j,;,L1rLX`aTN,%CcZO*1**LbLL
wP~	FPuv4w@<bM:g,APuV8STUFTQML*Lh1jb2UxSRU&,8U!TL+	PP!~	k:T@B~h
gN`Tx0* !SbVI'?0^+@
=w1:Bx0 z6&&fE;@Y4gE<`DU2d
C8
1XOq0**]ANYkL04&&CUftbP!U8Vt$8) s8ftbU
N f
L1Dl|?"@L*@:q*OLpLpua-pv\19;&pX5<} r*2Z".k@*X"x!P2LUTDy<2*+NZj0!VTNe6CyTUa!PU?T@ePy'(Cp0d:
l{-2j
 ) K2Yb**]EQ!8E	%b!4VQu	tgTU<A9Ly)EVA44&8y!kU5X%q 1_PI3xxgvvSPqZ[u!Tx'8P4@ @U*LL;<8&UU	2YTdwLL)1wbg1lrLiC*|qjpjL*?1w:8@(*YJt5

qb%;kEUAf's!2ET2%0t)CLYj*
rjp%v@Lf+)<=
111) *sN'8L*0{2N g|rdcN.w:q&\B"@`U8;8%8B\TDN,X[TN *p0d
cDUUSQ	`yGfp,SDCL[k@0CtVX3)5rL0B@N2Ux'^Uac98tbPUc5:FlA8!X;80%qd9>M"^Bp+ Jpp*(
q 1w.11L5dp1T@yb%kO9p^B0a8BCL *(yz c@N&NU`n 	R9xA@aX5.F@E3sx;t`E'Ug!@Y;q0b1Z0U0kQPAN{A\P@P9`	W3xSuEk&4NE'V,PcTAQ;Bqf&<ieB'E%AuY`@xRtV@twXQ!y7qs]N8c<*2fq)Z)bw^HYuUPb~SQT<OpCL:)NTdRuF4E\.<1**+g*J&NySyBjfU5 N0Hyj@>tVFETX"xN11
 V~T.Wc&{L jgbcEEw	kP3YN3	2`vxH'4kfwx~UeQQUeVsxgTQf&CUUcUTkQsa~m<UUQSDNtTO5wr7"
j0)*ju gg51CjLf+/*(LO,N'LA8TxU^%0k9W3c%U'U|{0,p]`*11L
aj`X9C^YKaUUPR@_TqKBOqC~v647T^uUTUvv(2+ _Hc391Z#u	>b1ibv %S&ECUAQ4E^9T'>}008yA!G:+*xp Lh_,C:))*@l8V&q*hanCfBpprCL|6yq
'0)#	@'&LQcC|wlIP9>N7U:xQs+vj/$,r0q(,biNP8;YUBA]9Vyr0T0UA^i`'l"CJNlxR2oG2,1hM*Xrq^9T@ &kWTvBb<"q0r) 
5)Nws+i
}SbTj3gE04CQbL(q0+gib,8[<<R	`DabvLx*`
2=KpM<L|*+nXQX4&fXbPBA5TpT1KPT%qv*)<}<t(%`PAUm`g
?'u*b~e(njlfM<'I% 

w(C*J>9RAg'F9&\T4feA7ubS1c|oo\/74z6<rJ^fB`qN~WpMTeBEcNUT-;8 P>}5X-Tf1@L0(u=V/z>ij2"^Z`Yo]UnVUAq
*gq*q1<RQ` 888CLp^ddm}Ioo32lcpS'w^Xs<!fQCtRP?5`8,+>qy5YPKx0h[6;|+W?y}P5L3YSFULAk-864T8&L3YPQT<,NWTE!T-?q5dNcbU'SA,~Kv=^\?vg^&xw*6+:z]*5Z5hT	wNfX
hLLw/0}LA&&feV\DU5Xc`Ue`2~{C~~^v!/yGo}o
gWh* f*jZ:
(j(*"*v\;fATUwh6]'v QxQUx(*1rwLTAcrdvlI343_~>}o'O'~Cy3p)2o,(1Y(Z*
\"J0)jnC8^!8q**3d@;Y-<c n};/>}/cn3:U;)J,qfM8)Cf(ag PPwR,TkR4&;UU&^~@Ev(*p,z/O^Wo/^2/0Xk-Bi)avXtX%8&P8 S c1a-*v_zXu.7?u?/|W?Z?Xd\Ws;d(+S5ZIQIuCU,PS kbHLJ>
*p	`Pwo'KS k_~j_>3}Cfc>\dpr";r2rpf(
N*
qBc8KfNxa
+;s0NLi<oro_=8>}xvf~7f&%`8OIfST^U;@Et91iop"Ew
5L1h
hhl2o<y24>$74)``9?;_v_sVZk
;Z61|Z%8aEY&TwE}N>QW01SA^{sb>>!?%_p}wbcxv?*?gjx68CS`TPQbvyP	TET%;wG9&gk&pcYt__azo?|3T?v:tX3t9!|/5/%by8x)!^aU&B,%STH'Enx'8wBi0w8XE\U"/Y6teE^>}v3|C>1/_|.| t/#_/dLkn+ vr?6p.jaa{+/(bpwTGUVy2pr8xF~Lz0cpe.+(q`zahyv3y>B.dfM:q^(d'fXLcRU;{0N^B'T8UEU1q5>Y#vx0LoUoX/dcm{6"0ggjf8;==96"w^,TxAkPt@g8XhJpVEc`x`53^tY{^rv9Bn_AGu/_>{^U}4o	xE`2qg`sUttT'x@EBAEIdv]U"N]TB|:{pUGn*W\aW>lB;_vVS9tC`=X{@8l
/2l:,',US&P "Q,ACIc/,'vkY__}37elFsfY_:OZ^;1YEx|sh;Z&gJxcEeebI	!8fVP`~1 (z[cuRH/	fsylCCw2j23,8s2xYxatdM,i&T~E6+vv=1B :&xQ!T3jjNMqocL}m7yoU:8SD7xg;C4URu1j5fUTPt</sbqHuoew7Et#|h_?<;L38qfa{e{-;K*g	Kvfs=g2w2bRBUBrf	[,K3=q RA.Tq!A3F_maz$J.*dSAt'b,%|]
>k|q$TIRQn:*_v.6\W!53Rny}2.F~Q?D}V-9&m2jB]wjBPF+T+::RKNB) 4ttL\:v++nu~Vp/ &8E3OJFPt|xK{NW:WNG:}:}o@ecj(fwgaHaHti(CRD
@CGGL44N"4\|QseTb9	\kj,QI
yEIc}:\q_.^'Xb}A5U.H`/%rphgv9@.6CM.wLn"1Jg]Gsq+hotTBb}9$NW.C^SfuCek^T]%}pP@Wy:_TP@S`HruR)\R1V:DGSf9#M%T9gNcH_\K${QWSRp>W<7Z^l6wo~Px\2C~*3C`m9dtrBYsES3 Al
rb@ttq<9QE@$$&uQDF-N:1OO@tTeeGENMn1nm??juS3@\+O7osF"CtY}A;qWf0"5:zfhv&EvbhM4_ct@3m:
9EvNsk=,	+	#9B`bQ?>9#W}*G7#o7_{*6Jqp)b_9b!J16(3H78RP$M<GZ813p+y%%rqul)$RE\//N&Wn}#~[0e7q j=,6wy,9D8*9C]R}ueYm[d5UF3i;HL*w:h~ai])    IDAT\#g=G6!nK:mM5X#'/{s	a;_{y7NJ|ZX	35U]NU<r|8'`P,W1U\)';c&N%ru(g3At/BHhbmIQfS5AhSvS7OARMmtR/*?~`9c7_9$qpuXk]u:2T>8mTNrFbZTJH  9=6(!T!5LGhP)6$XqEi]0<k:h!n/rL4u5nD~O}w*ceT.dx0?T^AmR!:T]'(HYQ;DcZgPPGzjw 4NVAj} ;]Ay63ysOIB5Q]~qYxGcO5^R%yWE:8ZV9\[)q8mR*,h9p&rbhk.u4vbh~LN8!|SY(PDEF2^Ez><f>8oV3>ni11.eT/ZH9g.BZUNK	Ki3,u#@*%TyJ4
i~a$nppEC4E:Hw  B^l'N?}p|Gbx2rgIyQd[%ym}s2L4)Ev-M*9Ky>Dp%=uwD6iHt*LGH\2(|BNB>).*%AGSVbr9}Rn~cxbj=y1
)c^o[mV(NyB"z[:=p2gF:Tg@d%k96NFttLcP;RREM.pc(nu}GINg+UO_u5}_2OFx_'NET]RD,&=;T}NsxH9y4;jwNhfQM64T(HHFI$Xth:UXMe0{e>??%!j"y|$}&A	]94)I,J9^.9VFe/7Acr,PT!d:%;:D:M}P$n\rNnl^6 Z[/;Fm4d]E!FqtxUoCW9zA;CU5IlPJ*pmY )IlY*	!i\%/)UVVbFZyKww>lT59^S:Hgm?>?N30b_kb;Hj'f_*Z3cffeN$<KpN0hvU6!!EmN-h'PF']F|qtzK7@yf&9~cf=yEEd	xscf]Jt9gWhWnMafE	tHgHiH;Pu44(!&q;#\"M 5yS^_7hF7#us[}4kJ})!mp:Cr>7FEQBQRFj<!\
B(%<)KEcs`2NbV	U}@.]&
[gh(2"/4@iV)'fcGrb{JZ<:9B78k}w{uW?=)zR^R'3NcvWip{I54qH*jpZ&t".wNL%W8cMeTRankOOZ_OxYYYKbP><uyIC-MOz<_+JwmHE;qJ\rpu|s&ggr:
&;M!R
C_bIpG 'jFqWe#v-K4*o#o|;X~7Vk8}]%#tXv'ne;5%>s8K&MTlV)v(1:'P)Pv;hLESX[/G4R|U$lUErY}=V<U9cI}	g5BOY/|xu}w?nxZ&2]^tF	"cCkAij2W]3gF6$Q:]{;RI'F`/Y(y/nt- ( e5wq#uDBH'?>U9s_)epG/^ES+3e@Z|0=h'2tQ4Nd(TMt%NCG>_,Y9Q@bq	T?}\=^.}+z;I:?=w7lu<#=|,8gF#.g8/
QTtYY"6gPTY]Sci8&"h~!prNCGC
L"/ReD4s]U&zSAe"c[SV*o]0nU'J#u&}Ac_t?`3= QA]LLL7TP
3C)*ng(SYih'N
tuif/!zns:puI8boTkntB7tyaO"yiR<qys~1{wHWqtA|2'JHSJ*]
rimGiCyQ*73PFKhjB(&4Jp(q:=/u]&ckN;]U,")?1V r9mY_96;m~|Q3WU{W|?;jIuF4{EsErF2CEJ33:ms0a@@GjHpt&	ihTRcM8)(JQYL+qp}\YHEN5n\b=~;{wz>|_	gWCMW4E:PGJU
Nt>>uRTN@V.I3MI7AT@/>Uc>pITZ|f|8t:TT'^fiVuOV81Q=Zt|g,9UqDDJDl5{6d]qgQ$&:Mh0t3K^[33HWfio96bY<YWd]?+y[?1U|8r\s>&lYIU"mFh943/9W;V<x/sa3D6d4NXIUWX/kn,vch7HN?NN9^iv]tn=yx!o[68%Ku*?Cp/oHj+)]3`9+i!@.!zP2&.0YJ!9%R%"ZUG.Gl,qvEF@G_~rwo=nO>Xn{Y.?t}^GUl?\eTe8_T,o*.3W/ITIFO'eNmy"E^[aF4SC6pGN6c%]mv6d_o//oqy{}mQX~Dw5\j=/om4/MsfLQ[d1iQrC1c=fIPttQ*h&/8TEEY0I l5SOq"u"MG|7#JZ-Yq]{]
P3%3<O6V9eUNh>7&E8qU;1!#M	;ur[npcgFf~}M;BM3kRAZU-8s/W]hBn(Z:lajiCGMD2),95b/#giL!v*(&)!DG+ElASw~&u=n&5z]<*]7EYa]p]=ijf]eleEqlKkfjQc=&!pm1kV{^ '
%ZPH<lh!%+2U4am>G]-hufMcSV\.c\%qXjk~mo&M*DKF[*ef<`r{lyrv;	=#5NI+QC(8LtD}e!T]tg(:#D5zWc4F];~rXc5)Zs%Hc_LDoW/{8UjkEL!s1)Q-utY*O9T)Zm-R4&T3y&2	Fp}ez*HQWg(:+^z>xmDs;UHAr1W{>$.J9`'QdROQ{Y[fly&gGUJR$nDvhE&[FFb%xe8O^>?l\Q[mk"[9CS7'h44}e\v98eQ3qU*z8rM<fmD1LYF\\#j9}]n;IuS)owGJOO0tb-^id6.Mi_]sw#Qz>M"S
sel"HEVJV6
`0e)D21R*n]2he:D4
hMI9D!'z^&cN9QuU|Z^w+?l@PQk8?/)+r<z<}dU73xbiJrfKUT_R_=ZvCT4g UR8m>s
hBF.nDxuws<1n|bg.~WYKWr]ws"/340~{bL>-9^J*j]95%f@m]sL;|(N[%]uY0S4BueU^78Ve07ry&:=cD\FuXuzmI&y0W_?nOry+"8^.=l:GJh\;hZfVLp
Rv5eth"qY:$(4hi\vj3
kKklTM_=PDG:]QYFI\N??0u>s;Y+FY}:a0y/["[3N)JDNYcvh PYv;$)&n}\^(aGnOH3@\Gl-TAEnd^o}cnN|?ME]!KF34YnvLNs-DKhS[hKn.TvF+h04m8qi_hqFjp=?MH8TEtnon*
ddicnA~7?j?>7*cHs)WgbmUFJVG/;V13rDN+ MMhD4nF*DCt4}Nwt&a^\u%e^vQwG+]1*r7	wI$K|q?S<\_]oW?oWqY':>zzQuJtl`IflnvC^<I5I - r5FhNN$Qb;uc,Pw(tQ<"wn&vW&/i~upwc?q?Wq0GbgvXS}(H-ml3&!LdLo77)Bt:g1r>Q~H}cb`>D6!rjFywC!DX]N1;pN3P`bEu0tKrMO7FAR[<X+X^n5Of Rzea'  KX:@Ca#!^\h <[?J!A(-N NNnQLKG1(k4Pp+@}QkD0'z_^x}4Bo~OD'?xE'w6vTeS)y{AW0`wE!a)ECM1C16=i4kF8AA8D(BBn  Dt#9! ')0n44 DWl*xE-WG}}^mf*jD<46oRn'~X4N,v5@ )%]RR~)fyD*Gw@.P BJ ,.{:1G\8%Pem<&s!0@E	+=FW)cM1/\dvc@{<jhDZ.>EiB1`	
>[3GoSY"P& Lr P
8n.PZi4JsZZ$BuI;    IDATvC^r[7i DGvyy8Fq"Tz/xkn]{?'7uS$b%p9F^4b*0	k
;#
Y`wD\+R)Uef 1%hn]. D
.!FZ3,OX#wo\ $ ou|se_{O+o_K9ny~Dy84b*q\F1;5WD~zt4JMIXr 9{6B	 g4&i'V~D60{~|`T>WoS)Vx\q/g>TJ?0:y*	rC6a icmzJ8! X i*Jta3TZ
H"AwBB!DVplPyiur`q/v^tZO7/V`\rDXmv2mTpj;ctorw%-kfA!-)Lv"\!0]@  Va)RNs3%lvsKC$`I(.(c1?F>1x9N7_G^>H_~jqD`[n*Zk2frZWqO43Xf7iy[P:(J(	%:biS`	@L(~!ZFR'5{J!Wlt gs;`f'^vO#^no6_]q:zcXr76"fZ*U>mL`1w*6P7=*M \t9!4a, ,iY) 	X*+iH |:78D!9_{@{mo{sY-oSpOnKO(i.D+f\0lu7y0zL@ht(1al `4i`iHP$hiH(# O:o! Jgh7{b{}:SZ{w}^{rU|bNK!/u]g00Rm(NA65\]"Q0WJ+M4Bp_]	CH rNrTR)\..
\:3Oo s_7-OA7_:*SJ-a;Z/f429n[?a%0cBn]o\w
mZfdBhPWAs*BC WX5aPZB   !AJiyr0 `LA:`;.aDZq0xy=_^%}0e[bVo~<.	@jZok,zpsy	6PH0z1pH:J/} g(RC*-\pd! P \`dwHPBr% LQRX-0`tgc*[#|~ZV<z_r^j{OR/S)5j-Q"lLN[+4C;.b*XG*]kpb"w9 ko(
"'f@n)EbL H WS!N8%o	Uqnt u< vg#b=DRkEW/S4: a(?(}D+a p q'6,=F*F,0g0@_7rA@BF\	0Tmx4*Gxm*v=6|lwai-]n""|9 ."KxwX: can*!RL9C.F6r:x(9@ +E  XAR)D-J@Y 4C-;~>H `8T"{V<a=Ik8^e/@ rKKS%'l>N;DdJG4%^	zAwe -`LBY7LI9!Y);seu $iNEru mItn n2\Q)x\W-uWF|kS77Gl~iLu{LZ?Qpr`-NF*)7!u hOPni hL#" ,!$`IK'g;`3[koqnym{S="<:x]q#z1:	^_v/vqBH<C%rr4oY>b:x/x9 yw(}Mt
_TJ@ipxSZ={a8-P _t l\{VCLN=CdywGDF'AQN^hD7_S(-@ci+Hz
W/=Q9$ KO4 6_],r1;@Irh`T~[<#\,j@PWrv R+9]|W,vWOq5/O12Q?6O
tMc%`830@`b h4r m"tDE$VK.O2O.5b[AWJH@{N@7nAB oOU1'=t,;qHV 2a0*HZB` V\6+bN	9 KWPO<~p/nsgwp j/	j=`:p(,CpQsWWA` }+;-6i8VVM]6}K6w1!DPNsTZRAF ,	7&BBHC r)ob.-q=8\^!Cn:eL5i(WZN014V7Ydt]J 6i`o]>xO/?a	cqt+`C(D/#:D)tOKbjw F(p-n"R |M%S	h#\t@t\~>n_L(QaqF'dHhw=in0 O'7tYA_G~,@1Bj;n)t1=,	WED*CIKwaw=XRN;0i(=a))\P'n<&08{A#<P9!<<V%lsExl?qn%O]X(b`T!rJM1JPu!\PsxO R xr;@NCR	WssE3fhtaP.GX{]1_=WQu/yj ppzi8
,8P!Y[5	{5!SrRR(  .Pi<9{;caNPx:V9T E%!nOUL>`ykvw_b\`H9l4A1,<115J)Z*-4D$V 4&T! A#PtlV$`Ho0|bM/074MX_SNs"!=q55?n?n\rc4@}O'9w{!fVfw#.(:z4!;yO
XBprXRH9Ci D?gw)8*n*4]	a]4~A r`/X=}yK v7yvGh}KLk<MZxwOqj	, ]s6%#JN*6Qz95_3 d<(8%9p
pBH Cid(ms6ss	F6?J+SLA^o0lyva!n=_C|scgO}I?GxPcueE^,=<kpHd985#BEHD9@@pQpB@. 4pAHs%zz
u7Nv }RJ!OC7D}}._OE_=gwke\1q7zu7e RckhK`CX,it` Q\	jj`jibLXB RFWrqW@8+yuXxS)%-e1z50^vu"6}7=P.>t?2,JQ2_TQ )T .4EB W GdtGJ
 Y+- i	R.d. ANRHz:n#)G8R 2@X[8kFxal^_hc?:@>XkaHK#lz>arlBX`4SKK8f%Q)W6=@W^sS5mRJ p 0-NHW -!{09Pe=x/ct~>R	v~T<\\=`O	Qw\pg^\9e,5%JJZ0V9[@`XvdkGG-!!xOIru24Nv,"w4P{ QCF}vH<5t>|}Qbum}(gsQfnLbCA0|e04#86G4|!e4C*i B^N08;792`oC`9vnj]Yh,~?T:<{h?+M2zZ8s_}.%a*jw=X5w"*haF/%	NjR. !r-Z\` W|Nnyv*'TDk.iVz*k`^4?d://{t6fAVv[L1mn0W_]\(Jcs+l0DR.^o7jU	D\E&$'&TCtk
4i	Rxw{L v{<P~M+"6>9o iv~~iDa NWd 2zz4f@T\; ,{uNE\ M	!$ $$,9OrK@iixx\{pJ>?-\_$.d|r|xfatTTEysNVzuUnICScj,vV|ut(H6JnLClB
	ixo rHB! )W\tE.ipy\m{ v.81ss.M\M_]'xV8=+|^{eN?sXr6TR,AGHan%!twZ8-a.\13Ap].aLcZ4WuCHN;asNpOf#;{qR1?cT^6qy,N5};_=mO #t ,5Kj@u5W8WlV'J	f`@FbFH	Z #AB
HFW C@:wDX6H[\NL9\8o x} ^?v]|{eY-eQc
w[WCzpwy	pg?+{rOk\,QIn QQV`4mBNI lDB@ $SiH@cOL4pV=Jm/!/Ekf] [zL#9>	.2*zwbJ"Wow9:j++hgI@nViE6kBnam3*;s6)*AC*1RH(0*nqJn5n7VTKb{s{DzitcAlT4v1
[V/jXyw&  (O~$	+cV&;BXR	NPb"<@8 (-! 1&0C
.H @RN@Ait UUc
'*<][_"k,$W'0J/*e;h<J=s?tDSt zb[ F@'z I!!Jb~a9HmDA6,!!0J r4Uaezb.`1Ia9llF>?Kz  g^oiO1P@-~?foKEY>8|]UX]oVEnE B@!"!Xc/C>`A@bK!'C^B@C F'+]zbr1=*Sq6xm6j>Gn{}IiLi{c}~$
_c
7tHF u,-5EOcQBt	c@jL#,Qfccb%:E6m; J
b6B	(</LpkGDt?~Wx-Q+Sc^:n{sw[~    IDATTchXv@=`_6~'a]V[b<:JPh11WWTcF"1%0[C4e@C i	(!WBr8:Cbc^rG*r@=b|pj{xype~`Wcgwnwo?|>wfK F@8 '-u./pTJg
7T?Kpj}ysbe:j.	%nacbDgB0!fpmDb((QQq]Sw]L&B	t@hP3JD_|T$;g>UcU[5 ?zlXk+\D{xcl'_T/~~</I??(PuPe0wsvupG{Uq9+hNl"HN`%-6J75GEsGbzp61Yn"%s%:U%U-:NI%#O__~/>{'?W`>GD$FHzsUcSPjG*MfRj!gnGmds
Q%RNw pqJ4Ngtx;TM$Q\gtP~y5|O[qu$A=|0<\DW?Sqy?~:6O 1*m{0Sh}H"62(AjF5CN2D;jxVNU<`U3_n,E-V8o>"5s%>Y2_Do?}\g>?\KU=ykxkML*\afU}T&#u:F:Q3tnS	V]&rF4n.>td]inHDJB7gKwo2Ui`'ef>	w\g_?X[R/{thfsqFr5Cl.P}3J,}nr&7smm|hnIT2r0-T-dFook)in|e2'?>[ze}m$,/_]?x-\x-M;w9y/eg6T-LWK:;3rAJu&naHcw488q"rfQ$f~{hU>C/>G}q_V[',gO7gOeNWiumGGG-99e'vge-kyh`thP/EwD* Ze\,ERmDSi1*stzt?[U\}~sv2/ZmK(r3Wlf?=9rVJTN'D&HfAmu	Sh(HB]u7v-m%vUmf:C4Dy0*htqv7Y*jN<KIt2q~wO~>d{]7778~hm_='wcP(tWw1g.c@CiuUs_8L/TVBD;P2i:H9a/>JNwopfH7mztUl_CbG797?7q'|5gJxxQ2x*!WFCh_Z~
fJRGm&z=I,XZ#kjX"s3+1=[.
3D{txRx7?n>O /:rX7~xM<"oPX1rn7?k_CF^}zo|}#jeR(DSYr
!BJH*@V.3)pCitmp
BkBUtCr}t3f}W]%|w>-8*e<O/gDmoir=/oPtECOu,jvUG+hokUwnJ,mCb{&39nCiULs	@\t\[X9i]<0Y`:r}4w]?Zv{w;?<e<d~$'|mzo:.r\}H1>bvJ+JHBmD<J	itm 	fHaAi0gP"hXMJgsp9RGO0]?~|G&<|wt:>~Q7wpH%DR7[[}v#$=3h"]]ZZ8Ms)>iKNT;vz9)DnJN4V!IEPDEd3hF$:rDNIgaQO?Y^Uw+>s O/k&&{diV?f#;v"5[VRBy?]H-RS0B]1hvzRJm/tuS!#NT\.QEG/l/koKO?>]rws_^m~AnPR](QWWKwq/bVG(<JY]n3s}93}!)AS:fYmeYmd:@J6EN+!0z8Y<(*#h"Fro>>y/71|;H'cy5>J}[QPRLl"*6e|:y0=z[P.5.[Yif)@1hv_<Hdf5!Kz^Na][x4*]RzW4E_d\/W<6W0WDVV-.!U8tv.=*r(DB<:Wkc_N6b/	*ud	l4Yt6MI4]<dLy=s9<HN\Fy|#YW3u* t
Ry>P7SzUveQI+zhSNkYSU[.m[Lmy('U'{O	Z a%$Nw(T<q{xWqz-r[8>$#c{\1o_Zc_M25<<?WyX]'yoWyU1<<*!	GhCUl+SF*[}=bcerRB:hq	4&g:.>v^!T#=.W{^}%~.\a|XiN%_*7:z{ET>ws{r|PVQd$_=EQV6sVbv;W/jy	vwb\BN"n'$hL[Oe+<@HU>yE/Gx/6]OoQ)Hwp>}n_><*K9~^:?Sm:K
^lK6RrCJ%0<t&O{p5xX;5oWo~J|mtd:>+><o0d1}n*	9$+j q|6j:q9RN@rGpUb+9K>gUp1The3Iv(@}q~T_++ry|=7f]bg5,6qM@QKkEon>_8-ISZ4VeK:gGuGwoEz/W/qIMRXrUS]YZ3CEk6$:C^IZh]|\;Kb=szsuW\^NIg~/UYjXT]2xW[A$WN3]aD]A9^SI^nB9Rq*,>nu3qZevW*!thCLn*q}}:^7E.;GS@>{Z
~ZxX(Ez?b--5kf^;ZQP	*uyjk[i5PHFTJ9gi>jvp8ERyNf6H;t-t;&D7v F%g)osg]*5Jb#2kQU{C4{ >jPs_rz3>UIc(t^t6sRmS%C=D8;z\h"N~{\6SO>^w\Yxn~gW`UW:D^=

Jjz/eX%WsThvU-Um%OVf*v'J,69JwFAmht4\|+jX1X%]kJO*;TXjx;0AHonz$yJz&X	ay`\==5ipmqndbFnp+Jj+V(#X6cwKzwGk<^;noY>\(2E$kXpz$c<L*}ZG(KUp<wYwL[_F.Or5&q`]e2N-@}&s*G-BEGD:	yo71g\I?IJgwM5\j]6p*)-`#8,i-YqYTY"FYt)6v*gw'F{&j9E
g"PFJ3itO;C1$z7GRc:VZlZrXpIP3Y'>@E9FD!zo{Y2vqA9Qw88!:8S
{s2fH
U#S"t(n7Rm58q@ a^|*5X_8)Y4;CkdrwTv;T!*ReQDq[FzXKX+vC$t9{L&JVaoha1i4BA;f/J[itqzt9uX_#UTA:W'-
.C^\91J]J,;zQ^iZfU:6s8',K=&fUGip u4Vu i#i%pM[JZcBoD^$$O^Y{Lqu"|`NqF&UGTstK*C(!oY;k_z'6bgUiC0h78.t9U.>u%A:vARc6\?y\$IVZj3AK't6.-t$#R!gFE&E[U{x\C<U&hf@*2dm83hQv(h7rCJ*Di6OrG$%1"J?uQ]NpmCEJQYrL,PH'AkaLt>D)(M!HgL.kv)<OIs^$Y'J
R(HN=09tmgUC!Hqg~$r3*C)Bq"R"\}Y4jRg/sH@Nl52%}9A%&D@8Ch`V
BevUvi1hEfCMt@Y
>Pdu2gA$D\8r.*3T'IMr4,mi4YLpuuES9VTs,fLbAK!>iBM(jS&U #B(xx$A":s]?Chcf@QdPm(&C"yO:p>b(2f:U**TFmhILd\8N+zvYD;g@jedHRtv4""t%")'oRkU0$Q+%'IAeeKbrB)@1d5U9R)}^7|K5t%XsEF$;:HI+hS8[iI`xduQP7v+@UCYyu.z8!HQi)\5:RNt]	Jkc~V6Xt&9;D:\w*kl bv9
)
)dR*5|3/&(;nQHEGF.}!T:hgQ##)HNEu)BEB +ZVUjHKnUu?gTorBi*7s2hAxm"70V0)J=Yvb48
#&&&@$6l>:I
09 WGGS@i,{@/U4Ti
F Q*DRT34\0T59RQRuTgU)"^[)X;HE*6_iS-N )]1izVLN|Qq qA:Fd<\A{QG3L`NcI 
 #EcX-|DDf=bUwbL5&w(C(gv-;,9O)DNemXDff`^t
At("i7T.ZYKo  IDATqAkRa (EIE:]j8D#8r{c[M8'&3g6;]N~snv<Gb@UH4&)wk2M'REN%.	ti"8i:pftTT/]@Au4Q]Z,dh\e_g*[A4Y*\;z!}$7vqt/QRqj'4R}9I[.fb:#"KR 'GvtfbUSP"jvR"%4c[zrPQfGsz&F;,9s9^,f}IMq&2HResJ0S.gIw4*Yc^"kAdX#HS$yNI:hgEIDzM90(E<A.92Jg.
VNPZ
h:vE;OZPRLa:Z'pVHEZef
w@"K.QE^:8{	EEN2H"$Nw4ET
J9QQseXf@$n)$AtuI'gi2vg)w]N`(=:NZNVbDQv\(YMd5G^&f 2RPIPdt)(*AEBHPQ9#Aa'5v{(fnKY/{N$R^q	'LI
JDNDXCcR/>*@Ga(.\*HgGYsE`io`|a0EMvOZDS10ZWa\o7&>ccp<-FyECu~578G1a
\x^51dCgQU'?j(__A#80E Nads=xVqU1"d.Tc{i^y3:yEG{]yg=Ru@T%N	wT%|5ySfVX)n9S 07|h~]oaHxZXg=-sq}&?0/?o`bF>gq*SfK*,
$8k~
2rLQ'LUT#"o0iGy;k939hfk?3	Rc=;<?3/&[z9oi6_qyS9=^8A	E[AZjV;(Nba,^X<Z;skh}Vo`@}aW^f{bZB/&G~pWleHChq)PvRS>_:pp`EVUcUieD57^sk=bb|5oT/{Okr1pa03[sZ}-4,,Cgc[PU5xA%ijo:SsO^QAZO8T&wL1{EGSFc3d=Ffn&)O~waYc>6TU^Ha2tOE.)6fqjP5|dW!C	`7 `9VGxvQaak`n;-_ipkz9&o}^y$?K>K+K`{Eva~p	@.#*"XU':qnUL'1pSnpzk#:SL_?jgUX4s;/2fdaN9,?.+kT]oCoI-IE?__!tXfYLZ3+z:7Sp<\Sy-C,.;*:==|TEZp~?Z0l=7ggVSb2]Uq:7>Sm`P'0bL#r{Xzb1<sav	^v0Ltp0hsv3>Svgvuw,7j4o?I|@OJBSQTx	SUc5%CC_8U5T8cV<bmgp0s~|`XHn}f0?<CUaQeBL8vafpuXY6UAYa//|68ydU`U	4U	Y,b;)|LAxZ*uy:9 }V8\0:"3Z~:M5XA8Uj{wrz;rGg^zux?JC| kj:L	N ?RaU&UM
Ee48T#FN9`;kT^&fbvVlV*C:T_:3gh*,	et1E=S@N/N&,Ce<+3ZsC=?<;
XvY3Yy'owx~eG{s0l&`U/X'4@!^VgIqpMX&SD>QS<2xM02CQepuX{~n`fTe6SM/uLAX,?Pf3/(au`1;
,Nhq|N*r^y<TFtv'Q\8d>WX@=zpncFxay,sYMi_Ug5%fgE3}!0i"qHV:yB|-fVLQucfbf#V5UD3SYs<bfC:_R]#grf^|a_2\{PkLw}*
a RPBQjMj_)Lc32L*yk2ivV?U{<>SEPAo2?|Q3;KGkygZ7LY5+(j
b"v@&X%<o9T47VA&x1jx
!_kyG816[12OUO>S<t~7;>_y XPY1CjXUTo%7L	)d*!w*)
C/9Cy{GM5nCwX~3Nxs<x?<dIzq|fg1n<>xGLY`8?/:C	`B&NeWw0rU5lx}.xc}(0:GV C,N>wElt8	@oHEM!h.bgMf	oTQ9U;&o<M1bx<\c5G#pXK<}9ze6jNJi3YI	ZChI,fd`dC 
Y&a@e7gzQx@4]3F<33lVlqxk,8%TtU@JY
uP&4VIIG@&QE'Qjfp0d 	s3^Ur,:X!2>s:TU?>X>ENeXN&&OQ8&lup`*YW4&&?>_
r*LX3Ew`T9XL`dfu/r=j*^r9r<Z7X4{{9ok7`|hX1|UTI%N5
_a`Fv`J`<q,r<{#gbM<>WxY@ ;s,|n43=X%cy[C szVgxB	>z=J0YyYQkH	8;06	V'&L GL1>0Sr
/b^4Kc/g;;L8<0Go%&TM:;%ZjMpJH~)LLe0:o}s2d&&2bVCa`	^wzP<Z1Hg	98@9j)=*'L=|*6eJkYq/b(r12O0ZB8;;_'c^3gT<>kXQuSUK,z-o_0sfvL*EQkg<s/d{ex(Y&@llfr|weC@ve)Z@%Mb<>8@[8oIQcdb^a&`C|;FZ,xdf"`bgN0V5w1*#N:;9x~yG]dm//UP5USB68;h}%^T^P-&EZ%@
Tx'wEev!^`29L3TC{{;L)#q h1+w^oyefuo

dqY ,qZ-p    IENDB`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    xUaoFg
'mqk 6(`%>|'
EGlH>qxs~I'0>n]86W^"cx[7`bC\9ea0W?okh/)+F&|u_5NeoT_%P{OPwe:#lkj9plH!5*PxTh\!`pC^O w_mw+Ttu6G'EGV6j3M@l; FEF`e.fEmEL#fa_s*ONagvp$ '0Xpi\1<[`QF#_Xvl_`L@M=2&I+Z1i2UAZeG~6Ng0V1OV*FpG aE0:eY:sTjgpxD4jkiST-R#cJy yMx!/mV4q]DtGTrBcL~QTJV(W&`LesO76Jo&.1Np.jr8z]0 GR)2]`]CH0y>~y OnxjaP,-{ZNVgZ%0KR<BQ~1U]Pe}_|~$=G|eE>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               # Copyright 2013 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import numbers

from telemetry import value as value_module
from telemetry.value import list_of_scalar_values
from telemetry.value import none_values
from telemetry.value import summarizable


class ScalarValue(summarizable.SummarizableValue):
  def __init__(self, page, name, units, value, important=True,
               description=None, tir_label=None,
               none_value_reason=None, improvement_direction=None,
               grouping_keys=None):
    """A single value (float or integer) result from a test.

    A test that counts the number of DOM elements in a page might produce a
    scalar value:
       ScalarValue(page, 'num_dom_elements', 'count', num_elements)
    """
    super(ScalarValue, self).__init__(page, name, units, important, description,
                                      tir_label, improvement_direction,
                                      grouping_keys)
    assert value is None or isinstance(value, numbers.Number)
    none_values.ValidateNoneValueReason(value, none_value_reason)
    self.value = value
    self.none_value_reason = none_value_reason

  def __repr__(self):
    if self.page:
      page_name = self.page.display_name
    else:
      page_name = 'None'
    return ('ScalarValue(%s, %s, %s, %s, important=%s, description=%s, '
            'tir_label=%s, improvement_direction=%s, grouping_keys=%s') % (
                page_name,
                self.name,
                self.units,
                self.value,
                self.important,
                self.description,
                self.tir_label,
                self.improvement_direction,
                self.grouping_keys)

  def GetBuildbotDataType(self, output_context):
    if self._IsImportantGivenOutputIntent(output_context):
      return 'default'
    return 'unimportant'

  def GetBuildbotValue(self):
    # Buildbot's print_perf_results method likes to get lists for all values,
    # even when they are scalar, so list-ize the return value.
    return [self.value]

  def GetRepresentativeNumber(self):
    return self.value

  def GetRepresentativeString(self):
    return str(self.value)

  @staticmethod
  def GetJSONTypeName():
    return 'scalar'

  def AsDict(self):
    d = super(ScalarValue, self).AsDict()
    d['value'] = self.value

    if self.none_value_reason is not None:
      d['none_value_reason'] = self.none_value_reason

    return d

  @staticmethod
  def FromDict(value_dict, page_dict):
    kwargs = value_module.Value.GetConstructorKwArgs(value_dict, page_dict)

    # Infinity and NaN are left out of JSON for security reasons that do not
    # apply to our use cases, so TBMv2 serializes them as strings,
    # but TBMv1 doesn't support them.
    if value_dict['value'] in ['Infinity', '-Infinity', 'NaN']:
      kwargs['value'] = None
      kwargs['none_value_reason'] = 'value was ' + value_dict['value']
    else:
      kwargs['value'] = value_dict['value']

    if 'improvement_direction' in value_dict:
      kwargs['improvement_direction'] = value_dict['improvement_direction']
    if 'none_value_reason' in value_dict:
      kwargs['none_value_reason'] = value_dict['none_value_reason']

    return ScalarValue(**kwargs)

  @classmethod
  def MergeLikeValuesFromSamePage(cls, values):
    assert len(values) > 0
    v0 = values[0]
    return cls._MergeLikeValues(values, v0.page, v0.name, v0.grouping_keys)

  @classmethod
  def MergeLikeValuesFromDifferentPages(cls, values):
    assert len(values) > 0
    v0 = values[0]
    return cls._MergeLikeValues(values, None, v0.name, v0.grouping_keys)

  @classmethod
  def _MergeLikeValues(cls, values, page, name, grouping_keys):
    v0 = values[0]

    merged_value = [v.value for v in values]
    none_value_reason = None
    if None in merged_value:
      merged_value = None
      merged_none_values = [v for v in values if v.value is None]
      none_value_reason = (
          none_values.MERGE_FAILURE_REASON +
          ' None values: %s' % repr(merged_none_values))
    return list_of_scalar_values.ListOfScalarValues(
        page, name, v0.units, merged_value, important=v0.important,
        description=v0.description,
        tir_label=value_module.MergedTirLabel(values),
        none_value_reason=none_value_reason,
        improvement_direction=v0.improvement_direction,
        grouping_keys=grouping_keys)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       PNG

   IHDR  @       TF    IDATxfu_]R:E7	%"HB@0C=a@6B'9BN#[y^u]|0"$QP&:&,|&QV(BEWqtDe=fN5	%g;TOGU*#v,bfcY3RGU6S9mTaEO
LWbaJW7 :rVtZ$Q#UYNJ 4U,sdv8-,(+lV-}uFIc`@<Fg$r.m)=QmQ)SXE@v:45w?@|J::DfCYMge+|bA/)O+ZjdE6ReE	3G/HQAMR2{E3K{'Z1
d+p/} |:waPrhpGd8>D(KJ'bTE[((%Q"c7R5s"5rz6V16JwQlQZc{VY(uh-;v :hR`hY6 LSQ*}1mE;|bOWSAtu!g	6!@, ET[!*V&-+8K;Z#^`LmK,SrNTqKmtN
L_F)?c'mXUM-U-pWP=2*+';(r;RE[F3MW: Ie	'EM!3dZ5UIPR+r=7HjMOAqVt{rERG!W$23PJi24DBT;0(>ip;K
J_@*	rJd8W;!Lz)+7i)j2D	+4Eb&*+NBK/l&NW2/7OtX.@ZYn7*:MQ
(D`3ihY`_E)%	08Oi S9PE:NDg2stJt&y5}N.iN*mPNy>8IQ/GOU9YdM2\X&

2`U~QPV (gG6S QNIAhrQEDUd&2Zd=Ntl}%bbQ::*Re"/;4
),r[*@P((2tt\JPHN' H5w"eQmZs	yg*n/Y9.gos&~619w@H\X0+MH'ltIcqvYVEr'Y(J#'YlO(kLT(Yd#Gr0+FnrsNO||c$RfsPqH<)vp)SeGrfNTd*2bgQFvgAA4!PE	w~!'1TtwtEh+4k!+G-y<`bqbe-t42&1{OSKGBv(J3;:kf\F1*AOI1Mr+UQt[gIY 'AdI6<
I:rv>- E"1vR7b[TEoNs8k)TNUbK1uP{fnmE.<*]bNQ2TARAr
b7hAmh(aLgR! I/Q@g3_'ZhWf	V9P-g=~|G/n^Z	AS;_rL=#7950rTVl,&&mcUDSgE<%Ql=:@;w~N@N8'Q$!dR[i&Y):Pt:;T|ss{Aj3j]IM	T^s_r6B(er
nP4Ac
0}ETvYZHa|2XhAHA^rjX3we-'ci]ErgFPe(hSUlS0=`fRErVQfl
=UMtA(LGb~BA'@iEA3<YHPp)zQZQc[b }=uPN2e%K^h\?lo>{<
[
:zQm6w*;0X~\M"JL),&*KMvc;@GC}?SdVsd;e,zy]T(XbddCWP0ST&EE?0Zq,y\s)grgYd]c2ZrEr"
h\"PeYR`r	7=2!6<~
T!LPI#^%(@THqSfi^QZ+8 oLUB/zIhIeG=KYvgMYTnx5]p)(Tf6AC@60}#CchcP]$hSZJI$d4Qa1B^d2KB
YgEUtP__~USFu9Q<hRdqZy {<T{P('1>De
0iC!++$DDINHY^:XEke3k,%U%+v}pZLjf).UTg}\{1u\yEPUM-U7hS*
jE)g}\C&
(%FE4n~.BV6/G-8aFE"rud1bDiAf(?<C_7_)jLmdr:N1QVOG-O;5{tTG,DQm*giod(:Teb"4X"uP'dQdF4$r*:Yk^2IYdT~IBVV*C3.{_lChRN>vnAY&')rZ455fQ@t%eKPn,mO\,~AT"s*@"*99-%2z=j=ZGY!vNi uw(6U{[cC2mEWM&Qyx:LUd+gc&4q[(*0uKr%D!RAFNNahzKXJqZkZYx^?<sRdTV9ke}MU"K>Mm-x5F}@Gc^	mJnO\0)
hEPW C|"2hXrbA4)RLSR\\/r)c!+kP:59<]\U-O/Hy(dMFg~QqH*vDr%d.)Ud~)MhCnmY	#HFA>s^YoT`VY},5,{q]Ko==rNsr>r~yAc:oQ,M<0&)|US9J3vG5h6b5~qJY*Nt8TqPhs
KQ
f1(k5y%r{7=77q.Pz#76SMf|<'V591q]I&PD	4UQTTnpWpt;(E C	jN$Kdz&>9AnX h\kVR5x~w0h\j/	[/e#7L54dR2fZnl\m=hr6=h:RA/Q 9V Vle;I%!3ImK/k<?:7o&gR[E1]E<-6P1s*=;/AGUeYZ2g*
IF2Mg24`| eO<$+Gh*`M@e$Xa]2L4I,tU.q_dEw|MWu)CUs|p3k3W.imff):\	%.1{Eld4CC&%PrW@L]c'@J#Y!2C"J:CulKb!#&a:1{.?OK7osXJj<'}ePe'pT^j-O(Ec4KP6%'MtvGQ,f"
=~|O,r/@DBm4Kge49Z9N+$UY)yL%//gfEgn9=aj4kd=q]rVz11@-:KBA1;W1Prvp,W?OAtr0j5;z|cH:Rq}	UlKFNEqW?nNaEgo_Z:s"P[rc1bV9j-zv|O93v3fIPM6h#56MmU4
_<IQ C&@PfTCYYySM7I7	{ooh;,lW)7sn.UTfiID1rsP!g{iQ
,E;@0D1*@X*H`:%UF9M?{&NY_eF'w90s#,43?^7vz6f/PM(^*tp+c6(Q=E@%w4KmdPV=!I25<=Ukb?93S?NR%,7:'[Tzx>FtU{ttY63K$lj8:UYt<-l3GYgc
EEGGevdY^bDP"JHg#Tw	Y#DT
V<~{{s^.:M><zdWwxZ*q~~FvG3eMgx3rG(q=b
O?N +Iz!INfueh&gTkVtWc}{w}=|U*|v>W77'
T,=yEye-Gy:`HbBu}74T!%CTPLUAm>h#YQW$OTttbuTld2jA*k],2NsJ,_}CSyhg_k`z1{(.!vFu6Ys2O,D*X=hRYuT`,%vTV5phKIW)DW ::8%(NAEd")k-X9?e= $X^}62unhv\A(gDu:kVO6xG*R^
hVc+T,]n,rEI-L]|bWX"UP|:NRdDf A\Z#J)	Xwc}yHX_{F|ql1JY~BmEe]r:2EZ0km{e0E)bhWlm:SWVR@"D(+Sd0I^QP9j^	Rsqw.~8.~/:4)Pn}+2
xa9fGJs-rVDX<L{L6E{ttQ*mh=h/S^+kU0V4IrJb\?g2,P0p/.?~arn+"W-_>w^z]X{Lgok]r_(xy"7w1\kss}&EXlDf(A1Mr:J_dV*I>tfF/	"Fe~Y":2 QOsKg-c?G\e_as/~pw~O<afn(chO'U2JY\=w)f	Yi;	V2?iNBzT#YDs8Y,$5t2m{/?%?}{C}<w=Ls<_9`vn'I>SR|bwY'&DhOejMtlr4]"'PCNQ(I+e`_uj;C:j1a/6w___~|6o~/^^o?|)oocYg*`?t2zIGGYm:JrSfHQB8B`	\Ls*1&i2Ng?<7T=w?.7o?7/]KoW(\7&Gssn(f'UdQ.kO\iJfB1;BTN-m&*h&CE3E
R#1s50)'izUl1?^y}<?}s=|oJ1>/\n?rAjkXcn#FTAm02MU(e*fBurSU2Pg%t3StN$dHx[{Uv*1}9cd#+T9?~|y</w>}WY$/r|#_5	Sguo}`[bjl*67(MJ#7"    IDAT6Me"d"CJ^z\s3{^n^$VrDz{o?OZu?}W?eE,O/b-d}bXK5e?Owj*/YMl{VnT4;j
rQ;
hHje)2DbY1j5JWB
1r=_g53Op\ TDD82EMRMoC7K12Md"PZ(HDr#^?aszgg+?/J}_XQO<NNrzT6dX15Mzz[sx6!4 !t-#@#ic0	$$yB5*D@]
-\%U	U:lBh:M#i~X[rp#+ =<^\xs)	xT	AjUh}a%
Z]1=J rM8h(C]Ia*``43@pCzA49(DaHneWZwbX)k1u{TjZ2}xLz^0/WaR\{/DpG"YK!v<(pC\Y
R
A[ $$D0(
p  @|H&%"5TPGC(I,(XB@V;}]0l26w6	+PMNinnKs<LmoEtm^_wQXdKoXt{XQGx("8tux#PS3bPu BIf!lbsLrV]n.m hFx%
I}fePgS2i~7;En:^[Ow6f\BDAz7yuF	!+A|pp !jHeYr
Q0@jWTh05y O&f|5t__-x9G<7/vEp0(V
 P`WkguVTu_Sk8 -,
: C@ 	#@	 ~LQ[T c:
h0 {!@]6Fcj M{yy"
';2><V7#B?u77*jnF
DK}-v7!puB4*"$
]u;m+!pWx p%%p-p $!
$JXT JH
QWPf.`R{{w{BQO'H]ww?/>l~y7on|~v3 `'<4f$kg}S2((M2Jo42mc/J6j%Sp
p W8wJQVa0d)0@(!	`H7dMv'I5;!Qt1zz2\\-?AoZ,ykE%fkhNQ<<$40:J
@ -Np@A IB
\k s3P`*$s5x8*K' [tov8{9-])t|>;MHzfkK!kcn
WnEY[tT	GHV 2A	W[JD (j0	TD`Q	Fp	P+nkr>
T4f6~r?.n~pbQ8vp|v Ww6.;Y%c		
QE(@ap@!XH7@dA@JW!WXRTpTP	iB@ (L4CQ1jJ
u3FuMUv`= hM[$;6JqOY<{~:)- vTi4wC,)*$<kCXlQE"C 0';4=4A['Y|EVSwnGUHc,W KF'G>v7E+Z,5/M&w@t iuuRe*J% gEEZes (AVZzpD iv ]F' % x;_ 
K@R3%D&&h|su2K7WG%nhMii4OfvEg/h6p gF[u"Wl.ATJ 
^;2hAT <CUd` <aW= -;_JPD!RvwQj,]uhAqEnONOp_PO?}y\<O'/N>&!(*OpTPHPLUFB0{	^Bz!T p# p-@@|	DLK*P *a$7\.+a')U/WQOnnu8~y	f7Yj!EWw4[EF8::":u@e
w!D< #!>
p#$\wh*
 jF*Z`P1`VjW>Mpv~t}.l!!?>?ZImMF'dP_?|\~(V9P<^U))0jZA/!S'X.$GlUj!+EQxT(0|+$U(JQxmUs[$L`Zw*F]-
'/E{r_zrrr6& 7Ww'w;zHB;NfMb!klU iU<+J[VIi&:V0bK#BNX'@/Qp W$@&jC-0a?IWvu$ p_VoxunQg'z ]s~1=?-N1c@~v"*
:dEWV5fZW}W{otD	:3!I YAI  pJXHPw<	4	`$	|$0`I`F@nQ@j?duYn~}Xvjt2Mr=[lr:MZUybz~h5(DZgQ,MB:JQnW[<fu_80!@8b+(< B8K@|bJd^T$):J)QHht?|x\&MOVv~t}{SPNN.	_Mfwf'$BI(6R0tT	t56kj(9mSsM
h  e`9z@z`ETF%\8:AUI (@JU=5&1L[^^_X,V^)e}y6K?qGgf/7]&~|C|ilAlK\XFlF,{9yG
Xj(*yl(A
RA  (*
wP*>
iD4$u,
H.OFcc_Z+7Mi>e?M91]|JS~xg96uJKtJU6a@FIJs3e(]Q(,T9^P@'RkQWP(Pnp $ 	@QH$QZUNC=9O2d<TF}QA3M^v'\-(VO1zzr~x2x.X/>.V1 nC9-#]	=l*n[W@u4WJ'>rpn=p(p|mjnP]aH SWy2B5Wvqx|PQbZw0Ln)\!Z?]^gW]gBF`#,%$DxCR`@zV*t!b%ht:$ \#( PE:(]BWWBppO5 Cp@G4&vq E'z\?z2Yx8{yp!6<{~og/zY{;9,do7.f`Ra$!D!J--x/LJA	7GNQ@ $  T@Hn1C ZP5ZnGe{'unX>lK0iy} L?}z*/j7NY??=Xlwp"YP[tCR 6h!4hEU_uHP" << p (Hn1 Q`I@BH@,dP G[}a TpwIQ~O&eussq0>??walO`'S!xAxwV:#c-BYP+`
W6LKap*-P8p% GZhNn !IbiAP[3w6;'GQ|uh='|&__]/|s{5o'fx2)W,\O&VS&]:{C A8a((cT 
(t"O  !W8bP
<*(=J4U0 +vU-`|2zu1_h>n|g~Xt*.fTe={~1\8z~zZ!\QrR[E7hDp*jRzWt+-NxBp ?G(d Bh*PM?
G*u:N&MS~D}z
jN>GD[rlO?^?~l6vK}~<M={~T;vvD3zU'y,XKB!BCg,@[R@'"QIt 

N% C	p$BXc QcMOR%/75iZ7y[upYh~/4#.:gGN5g/`tby6Z_10=?;?O}6*$,[+$ZdWii% V PJh#`t w$T$@+ >~2&udWjh.rI|$L&8}i|4NQ*bfbPUVll&w>/?]Zgm[>]1YVJ&TrF5PJzH-QpcN7WRpu8~OpX#
3He?r@p4ls-lPN's?==80$`f[??2G}vqy+rqan=l4M.[[ZGPo6MK`Z(Z
80Wm8>
W*4PiT;_'an
4W
MKIU7X-><XCF#d2<mv
p28>M|I}>9t{yUGxWWs_!6<o>Pe}z2Zuu>PY!jQuOU&,
*A	QaD8F
@ !A	 (;_#R#D
DxrsKzI3j/TXi:"/_6O&!/~hvvM}`/o:K5*#/WHg_
D+:j#z'tHDPRgWWVL$F( $	a:`H Q b
xe=wW-Q==aHC\{T3N&'M-y~h7:t]WoiTf>z/g}wz5	i.l87__f/e|($!ru8F!(I== HdGx [x " #w07 6?,k|*N&]98[\aR;t oAVtztwvMwG]4(?_,l"[f
T7
%v.[FMDz$ AO(%+>*;C AW;Na'tW8,LvL=Kv|9;y,"^?dP! Tl:}1`;?]>|f=:p q&m$+!
6d% c_A%GYw E]IsQ $@Az5DH4E`jY>]7] &~Xc'<L[/.pWI |w7[M>&*1K}7aBHjxbE`[`1 D0@xH8%[JpO^+ 	s	&D|P4e b"(itivhRaOFE7y!k54o~:% ^{    IDAT6
Gg_>o?\LuFXm:\| g(JeA
Z($< nC	eOBTWLpEr5
*]^\>O%~zrT^0k;7t6;h bq{;_lrn7}U?;;twt@g_\[Mu
{/axau rPP Fzs\Kg8SYb pJ1U pp|$7*Jf"oMa6;Mjd:>Zd::r~GO'kwi>{q2>\x>(zlYgSAo$FgB
 @I+AP2-GAWYjtD1u pt%PD@BCG  v`
u_{xCohr4lj]}1}t
`2Lg^{'g L&gU93hlL_Fh=fePulJ7FV,p-@ l	 WA#@ZJTb@ ?e4>6C}YX- FZ'qv~uz6xk|KKS=>{y	4}zv~qfZ&=2joU=B:"b}R#0RTHH	:  p 	9w1dZ mcd4l*]Ye %2yL?7?\n1?<;nn]^oCo$;M[Mg/PLr;(_~mJ/gek#>\:Zk	E3([ @7TDHz Nl* ah%?]GfR7d)mZe:Q[#N.~ `u=&!m ,c2w+g5W2yy"wg~|Z MQ2$tRBWZ*$!CY)J@,-@!!P%<@8WIb!*+k(m5iD7rBNnjr4|`4rrw/O>|c_|^6ejyJ8OO,$ekeWMmIZNs-8A: !c *u` :zThe*P#>^dz|p-?/>lONgnp7M_7ONqRt{M/fvyutxn]![_*~%Jg+^,=-G ([lNpaQp*
|&:$PAJ~\ f8iuJ|[}z:lVx"_ah==sx(|6;voo1u_yu0B^&J!UVGuD1!YE!!at b8(pG* AW'@	8>
~d@L5zUw+Yyn:o}`Jd4L0~ZMtxrOipu/+0I8=m??;IkL7o~|aQR 7tYZ(J!2 lyOAA84GUz@@pATCi@rnXmpTZZ?kXFz2=Y<oVPHvpB=i^-C>>\=gg/F$_+n+6:!-]UTukVj- Q$d@zx+
$@7P W  %@s J|mqdY\)e W Qqq"4=;X+c54=[TTY!eVqT(!`pi]L)#5pVY<X`" gnX\/OC\m_V"(@YLN ~O/.h'(OA	;cpLI*`jj"AL@3g;@  
@0 L0`Ab'"@eGPT/E{ng`(P9aY|(%L?VM"8^W#Mm07|)xuy^60z#L~wvrY`Rp%-j LR,Hz41']2GH@	^(AA	)`wGK]Dy6]ITb1, Mnz83X6~mq:N'0V]71E~Ts *}?z(xw2~s&1?6,WaiZ(i/+	\H] ){D^@ 8l	`p	@h@@},F~oMDv=8i\|29fY502r[*_S,KSMiX\]?x[`?,u s/v/_Wt|o9$#"2"3E >QnX)IyM 
 = 0@La
( 5@aJ`?m08xfYyn|(I|<"2<HGWMGEVEXznA	i 
iw}\F(,YG\Yz';]":s.lAj<A{%YE=CajN@{"3 ag
a~]M|9_x'r/W	|2
_4uDm7O!8-NI)7G??u0qZ\~jTe[~>tK6[1 4n4N\{x9SSa@D,$P1G" Jj%33vK	!mm28P^/1B8.&y^}<={V<xT?olb6j~Y!h_V}8gzs~12\nzQay@ou[cJJaQ^M#gFaEp)
	%&+zY! L@ 
s\
9B GyP6E8+\}=:py^Uq^S7g tqUcg,:zzss_gn1'|}q9kznZ?N|?>DqY~=n p'"%a5$<<E Pe LI@)$p{K8/B aus/",,v"mY6]C.Iid>.vC
6g67NOCLh"F'.ot<Y#L.\/Wp$oYw 8XL(& %Dq4 @;)$P bPB L<t5Pr; 07om~b:R{aU>G>_L r}S%7qelpGa}9q8;r7CeGSlJy~enwU8xS$JJ^`81 qBJ50P
!' %q"/R:SLgX6Q6m+{I|<G3'z+L]o&1:EU[|vjPndP goNCL}w}aUv)O{!5V&:S7gLp P,9s(SR6YbwjB\0gJPq(	 5g*l/{yFEs}'Mq>zYKMlu#\BF3inQ2DrSO!Wpmm-sp}}Y.,'^^]!q W.t0n'"H^;5N,K%5TjJ(jJjpURR3L0PoS9Z=a2^xmjS:95bcbRn6.,Cj pV4!z#QMr~rk?, 7/Bh?lx&=PG[rA{%QQBpD@`jJII3558 5@	 $g0 qVAfj]&GJKl7fxZfnNbQqy-\^T8@R|7-^U10j~3go/=7Ooa]>m_[=8t	9(0BIA 
8
+ 'BAr0%@Mv@ZQ!X.j+"p6iEFeuZcq5M'~Ix(g\ylOtR_=>Q>_a@2R65uL_Z?%.^Vyt:P^X&xKX`DSsEID.*TsB
)AA
O)
B~Xb'*&,]pfEyw$s y?<dr5
JW[^.~UmzpW{B(||w	I<}3?Qpy(4o%PWKqd@		l@")it   @M
`p:'%5@! w>%1p".,']mEEYMi6&:sOr}O*]]G-;JnY^G	rw'J/</G^{PWo\^ *OS|My:d&*8:W:H^5V 53 r(I9[}b/k@U?9.|ma\MfYPow>.M~^UsBM{{Z
P_\%j7XO5<!3l%W"% YP
X.(	EX D	;;u9XsB~';'u8A&eyL8Fy^}]5w^!=&tQU,YNJn|rpG?lxD1gECq8m	'^${1gc)z<1Dp"5'v PSS%>S5|z@@Ih!Iw!cx08%I8y~Ze^.a^P-frU?Ug~cjLa~uy6l7D!t=3p"r]w9}aJ{AA?
1)%D80@s@ 9gc@lbvc>90e0
?VX,n]Xo>>s?$T|1ei\V1
;RtzaOpR>\}}W}w, =!!y%&(6W
BH!Q0 
'Br$JJPs$cm1(e\0iLS1h| JYERf>LW	^CE5zuNbJy5O\zYoY8Br:|qTN2<DDbI6Pid$9EP1NpUaScl
rsFEC0I159yTIg ViMyZo~Qf3W>8Ym8Vm?moO^&N_$8o]>bW8*` G@\2$%a-AI B
q,XJ*HMX	X@APsAr4b#Ry!`	Sdy6q(JR~|jDXz.O*8'"~X?o^_;7Ydk~8_*<y4P/OM)3,d"*"J^gDp=$r&
j9 a%QR!% `R()&3&2)82XwDKx:Hl6d'eJ]'0aSA}Y,f[;/M]?c~uv>m_}ufZ1w(n}iE Ivg`DbM$,VrwpbDWg`  Rp4`{6@9;v1+/qIb68beQUy!mn!'R}:yW/Fqsp3jvIYBmz=](qG+%!N'SS&J&aPgN( `pbpB0 *H %=`N PC3bE}|7L*=5M[%[9i6QI8~1va]-W_w+q^i7Ji~Om{o	>IwI\]LWy^<w0ED@J{d8QLIH$%q8 31gPr9N{@IMqt1xyH]xD wIM(wmr2C"7]xJMv	j^M|vO    IDAT#j|5W]-k2a><2-bytV/Ogo2PKd,
x5',B(@))jQrR3@ut0|	j=:w!XXB$`E{pl6]*fU	5&0q5enT?w#N=sQv@]4,2*Vir7]~jGyuu>~S3gg	pS\ `e9*.#$( S
(POg&0@G*>Igykj2inwb:zYy<<=6-L6i^NO'	{eHU8)}in[W_c?.v2|{g/z3,oVm)LfTCy97Dt(5g(=r $pR;gjPRR@  r4wQ6YfKP6nwz<k;VsqY3Ix~zlbeqqpX>|\n26!noS'B(_M4 r.oZFWzP;;1,2 EhUHEjJ(L)PS35` A33 M];7H8'n(];?J_Q'dr>&46f.1b6TkV0g*,iuzx>^/wj6 ?u ,[|r&[m@\\]$QWHrC:S(
AaB8)8aH3GIc6G&2TrxAvI2/z.b67" .&WYY8~St8.OOfH:ox~rQO?^?F ;\WPx>t'eF1a ^{XHNvG{A% Z&"y g 9B LRscM8zd~;.<5mEYni'K'[YzV
EYMcn%i5!.	RY:E&d"Y-
/wkbvVL_]oj__E'_pR
og,j^g G5@t!1KD
5)3( K:P3 J* $p q)
Dp@CN(kN/*lgcQOYFT=qDW'Drfbas5?[T;k?NS47yT~7siDP^^cd"N@ gR L!
30()$)`lNHa%	l@UHm/'Ul'"f'xLm)qcY>LI|qZU99vn;|SgWM}kDQp:?Y;`m=w?)}~JJi%@@
()%q`A`P  RsLIXP>;M eRAJP&aVZ{,npN]K/6I8;'!Cg;/S<6M+Z}QKzyWo~q:_x}eo^K:[TO?n.^qw0tP\O*^z& hJb IFCd( zQ3HfqBC"d
P"p$`zt"I "8<M<"=Ntw4hIUzunGC~hO,]W.Wha2{$X!zu/T#CO?~@L_Mx^77r O/i(Pr">R2GY
	+L! DaE
3!Na 89G!pj
.vm<j>5oZq0mi/r]q^8-;}('m)$gn\12U4kVmx1O?'cU:;&Q4H  RTX	)	@Pr ((9)	` %Ggt:r1a86OUU mT.eq+xR]-<9E7G5% g~A|@ 'i>}UjPi|;t0e1Aap@sBP@@8!A	$0%*1!lh{Jz*Krmj$*8!ve-z.=<uQYmMrz<w2rOOQ$jqgc$B /3,ONIBhGL$LI	N 0@S q0gj
R@889SRJ AY:F}<Ps}<>a,KfZ"Uy~H`PVr':btR~@r-8:stZ!D,ju?|7s#'m~2@	"^$+x%Ed
{gNHRg'PScAa;' Ic5 a6uEpYsv.!)HVA8{\F_=]y1}~oKedy>fq;f+bv.?ous$!qRCZT9ge$	t q@0sb,b)*^I) 0V!HJ^zA\ QOgSL>Q8-F=a\L/e	/O*_2_==g_e'Q!?]k'/]]?<dpQ:inNhWy}va&YDW
Ss,ap@D(A
 ATP9XP=z?H`#t}:_mS'sQ*f,'Eid,{h:r8{'UO[<4\&&?tWW#~l>z\x(~^&PHF|05bK )%	b	ljHJTN	USs( )X`P  )
9z%tE2&9D;;<K0K&hgVu$P2P@WuMTr_8=<6.l6N~yto.P|.)}!^]VC\}~I8Tq@
fsenRBT^# j
RRqs, 5q5\
RACg!3{%U]T|=GT%]l5ybti8WRi?~r]6u'>U'e^6J~iZmY146H-MT=0H[5@	\UQlWFLO( >1  AEAP	P0@  jGOmr|Hb1E96Q1.=NR,qbQRzEO	.U^5u#~|t_y+~09>y]1i ~t:/KfK_b(*RCCB,1E(A)5)))' 5(9+H"Af)Gy`rII
_3k#B^.uPd^}Au/cNRm?-O<]cprxJ=8uGGoW2um _\-*^?YxKhvo$J9
65(	\	!B8:R@H3( Bq&P%5}rIbd1Aaph.E9ihzp2t1nvj>Qt\5 \ML4uwt{\>u!xUtu\|}1Os@Zv*e50A"'Qt9K^g
X`jP(0(H"?s,dI=!(4P#C4Mxl"?v$Elil:<TY=6rdJ]Qp<MU nwz[,WngsX"IodI_F^Q$/8P"$68Dj8TJ3g(HHMX` 	l8wTQI$@aIiE^C ic 
/"G=yIM;r:?IprBVFc/r}`|lfD,9B4ACjq.[j{P l?;?U/2j[{Y~@#
eh])7Jn 
PR49)s076MCn2_g
ZD2LpV]LqI\g..Da<qsvyom'pzTu9)VmH_0bzL	' W/ERmSCNW8 U4N`alnn
0) )+
8``al|(R$QL,Blz)SnS4KH4Y<K:ku]'k}{NY%} mO]'OO6Q!?lHX}A7OlQXBcc1edpf ( Cqc A%7VAAp9|c zYd%@%(Si6WBn:c^obrtkkwK9o'cwZexO1I}/rj 7</G1q=/\'(M!j\N
aS7Q(T'7a09AX	N
&(Y,R\eh.ucE-ZM2Ye/6]orh9J}Z\p.Bi:|.E?=|<~~hN/P+?e 5aN"(qV0euP3%7e`c(A0'.
jrr$Y1U)!CRJ>k]:lZ&[Vsl!:i!p9+Rl6 u8Sx|Zvco|>~q3_vBoPcFj5 
@l
Q( srHeU@n`sPQVbll -PHJvNl,qR4i\Nw@T:jnwn8^Ocq_PT.y|N?Q8|9*vqw\
<Ocu?nc~kv9d^O{t[38 (TLS'70ye AnllCIYYH\WB-h8l}3~mm|)YrX<a<CRWa3k7~4R64hXHqnv5)c`;p]7ES'a"@Recsr'esWr3V|0207nkuJ!JP\f0R.%S\a:Vxh7H\ i:*i<|=Nn=q&hv~;~i'/oI~5/u1.v7UY/_)<K[8l*N \	npW7&7?(9 .0'vgSVAV:d5$5"ax!my<v{j%Nynn{n-gn8_l/Oi}@L[w]h\_>zs~>tSC0'17A u 8nNlprS&8`?5e
Y6
:,_ziQE1OYi>$t|sCy&iS&F4ftz)l}+)W8)MxNK_R8IvoH
`	NUJP6TVcb '7`Xk
'&+N,Qbj4N"tq]@LRw4}1{L}}MvhD*x~HJh"wm09p\~m@~:;ba668B	
eBe1 
s** Il (Yg)dVUZAB uSN<~x6<SC0VUr`)vd=T5.zi"-kz?/z54>7PP5qE070M08s|g|[)MYRRR/7&DrM)	a&
teBD/Nz~W]i^/?lZ<*Ncv>8LBmD,0p:Kz])Z>CwG&U}X*P.*+0lc VnV%D8f)U!tR$ZU@  u<8ByoFe]noJq!]/SnaJt(RuO7O+wMi;ar!0PAp1(laVl`)$H4Ukx`HFW	L%Oynp_vXS2wp,
i<8v2bwDO{zzA?#8rM_>3#A    IDATN|3rU@M\WN>"zQ799 R7Q l0 lnpJl`@|ecBV*G!9TUS$56^Qr)ZC4OyRcHz:Q]!%f}x9]r*p Og[r(>t/vFp2ixW?n8Wuw?
Df[pPL!n,1P&7@ ' 6%@~iT
b/W'	1H/Rgbc	MZU5vSTq`6Q.zw}aRZ}? zH7=o\iX@6Y0cB$lII6vOW6EPdnA Jal 8Q060F+`*
$h)BHZV%UqFsbInIu>fiF/qtz>fVC%~$\\	Ts6~j2Htu4+ EQa9`%') '76Jr@	Z5H9;"AB^eJ1JJkb SER8y,]\d.&mL/tK|^~_>C'0/
zhvQyRp?=W;W6 ]/DA4UsIO:l 378AU 6768j`*pbWPecsbswXkIQD9O:5"TGJkm I4-Z\)M1I8|mwUB.J=c<==Xda8rQ}H)$=HYt)@aaLoJ5L] R0*+ `Np(96CaNp]$p*f\14FJ*mL` kZMb\W](kIVR |*oq+E:s"}>^v<NcQ.=ju{e*_>WiYCtUG
 l	*pf\	p7 N799D.nHy.nM
5hc+3f!E.Op`nS\	x:H.0Ih>~f %c*ctK![nzc>>|gtVoW,n.*
?
Jn0c%(n`'wf  knU%27U`KlC #4IB6MZm:qN B1aZ\Y|^3XBN 6}7JKC6iS/J?v2~(IG>"c"5
79@`fNnNf.9 PHsBl4Z@) $n[6S9;DBbXAx.mD3p*CwRav}p.>ll8nllS|_
I#[1$cAS*iT@U "N7(P++6Az,!R$ctlm 6ABL]H /rev6Ai:5a	UR^0'n
_rA?ty[!wzNgcsY\oNp1`lrmNr2I  `cCe2	+TVe&)<[u
l,V:J@~q86ch%BnRYh9@bm_]p:LYMG|Tm6o/,7ecr9lp%8) '7qcRAj@v6CH2HYC"_3LBPzX	Cl:NEA*@aN .
KU96Szu-41MzbP4Wzne~} Gek18S?ezW	mz< Vrj 9'7 NprXA
0+9	pSU7F"@
"2Zg	19<d)5laycFK9+$uq$<qI",W\/((hJ1e|&df4>zrINX?pvIV*l!v:l*#|Fba`2b2H1``J8["f"7\Z)&!tJ0QL!5<l@k"K*nbzaRcblL.g-4tvU8fn/e/#}jZmC1HyfYCBr.#00Val eAp|w^f+
0f0-  RylX|"	54sE0x>	Bj7>\RK.T#}c:oW7`c#3p;Xq6exyr=q[iu*~y$
IO]oGMYVRsFd&8 r7 NN 60q>jUL`aia%Tu#\=R2zfSya`n#tK.n y-QXub"`+a?v@u*$ra{{\a1umqra+o/w,iMQ4]VH:6sl)`f e|G
+99@{/o%	8LNk15
.A3Ie8m<~]%g7)-gZ]qA|)R2lLou 6&NC}}>
8fx)K79(99`P691?fc(T$0qSN	UK:f#m|!zM}r.n'EDxxM[ai.-WLn:fE8eFXUxx5<*S^l!1q:
&u0ALr J7}Mg"7W)6ConNU)E6<[jr'ju\gHpg=2Tn<b<n=9aB9W+lau:\dpEfckr8^Iu23.('(7  nl allo+\`(VA Mi.%	m(Y,$%958gbipmmH6Je~5Xn.m(a2NoUasZmeAP2/W7}lj&Un6r! 8HYc*E	PBe%1pc%8,(9i1oS TnLAab*k)TBE22.NoWpL&f<L{."m~<7}r.>!NTe00jt[ ^r a{X8MnZ6vIrIP76 Np(99`N\E 8	P6 3 jA!zlUT@lBYip#s,v5)Ny*&c3e
HL.2~Ud{<#B\l<9t@Sy`R)Gj nNp;al.alM``a``Wj:@VZ6!!UheX b&\nZNJF-X2#bdkz}
8lX~Y/y&Vjnb*En"cKoCMJ) 6Bf 8)+`l	9`Lnln H4!l (Z"J
 Pq!	1.MDsqP8gu<evCuHm:]]fKi<yP5`lud.1b
v mP\R`&6PqCT +P`NN06 ~Xt0	A[4hXX J*$HF0ZJM*,WIk|V6I}4F6jk#vKSo1#!W]/\xF15SV 931JprSTD]p@ eA66+@VS1`<J1DGT,	!8j:7]jStQNTa:Jafd0St1P8L $qnmn:Rp[v)(5;qjn 
R&Xp;'8 % 0wO$NnZ)Bu*Jfq\Z%DHU*lajnQk6b$*Ey~
. %+zJ?~/9li
NM(8vA1Ib&n*l06%''''
JA(`wO@!Dp$|6i.K>c\a	6WiS\XmShkn:0&m;SoypG7^joZ vT&' f 7f3 8l 99 8%8 o	 
oBdb+n<%CjQ6!6uM,%W6)Q8
	)H\_8fQu<8i9l|<\ ILY8i9,~=+\vtVGZaCF\!81T`|jR% nlAP
f eSq(AIQ 
bVE SE0C$VhZTko
f-g&4bUq@\{sAv3:zy-K":3I]Gfc/hz	)J31@Vf`f1q\aN2I'a`30|b]Mg
x-$P7HjW^)#q1z:XK6u	Bn8BCksY9&T|8]vn:K@Hmjc.ixI6LrK\3YoPdU+quX0[lN )`c6'' bl`U)
f
Z.]6:W-f
.]-W.u 18sRC%mX!9Yu*.(OvZ6O:7EOuZ@qUb! Waa0's0	N	R069 
fc_]`3N`
)b&TtQ(S.W<ch%. Zsh%fv{;aR(-JaRX|}m1{6 =	u9xm8BTNnalNpc`q;r`Npaw 0V5ubWbbBj)i4"#n0MRhS8$5Z.Mi"n>4 :V1Q|@
O6=]FoY<VI1EA.*n.8n all L VRbNN{6If\a"N`L ajAV|&TuQFZv]hur"W:z
v<n7A"O qy<\hDmBJA>!675`fln) '' 'n s;r%{0Ac(1*)jQX9WMRXX<$!um@-dI`s-j N*pbiLoC5#fyl `<]/zu4zh"CRNW7" e$&S6ncpc(A]`'8Pj5)6QyRRh3`7l%'+YPE&he*2)z9!:z: ]=L"0(k&suZ9X,r>%EF}8>m:~49uo:.[8^_mz?AG~aquUCadN,lK`)2Mmd;rG*,0Q
d
eaqUAK /U>wmG\mi1"y9^ ~z}zL'musqZ1c65@6t*;vCG;JD,ii	hDD @GFK),JUI.Z_SR9>1ZFom~_5>\V_c186xgyr-tm+d;=aVNJ<)r4D &UB#vi^m}_oy|TGh,x=?yy}/>{}_sxe9k|XY~xP
,ybM4T!J,d0Xe:h%'RtV }XPncU=}<fU#*{^nvw+?>y
xy]TF{~u?rjfv,0T
Nt%DcMeECJ~#e0!be@Owth#Rs~<L95:q|g3X-c_s?fo8n[=(;mhB"JAgU4D!~2UM :@MGA&"U8u.cd.X2blKK5ST}mZl=m}6loq|rx=(m}wXd xyM2%16 @4/(:&":3 ,2ky"Ua\u":E#?;Rc]q`m?f9_gE]YGmF04*Bq>.&nYtTtyP}n  IDAT8+_@tj%Lm2{*QT{MQrypqm}pUge(5+n?b^N}VZQ_DpR3dy4D['&trl*:*TA[eMDRY$55Q\WAk9ui?9Lj,
}GM|x=yL$n1gm+z6flkOm8FCq&@t)-6%D[OM?as]GqX:*rhgpL&WLnqx?+m mAc[8J2gbIPy c/3)w"4QXn,rG4Xh(JpTU(7;nXAd8c5+zg12`cy}_o<>?mYr:5/?sVWc>>f~9UNEGeQbJp'%tADG
tnift 8Aca~/XDX@/pe:]#u@lc}?rdWyr5}G1YGE^^^-9G1d}[j?wY:z}+;2\FFT	my(dPD$`!#wP=!IQ_=!t#nk]g{l5>zFkUjmOa:^x;gh%Wm}Z62yEA%7TtZn~rPnCAeWh:rG[`yTm:hhB<=L!Cdcq312}>:M\B5k<f|%yZ|9yOPnK*]:ed/p[V(KiJD'V41(:4X.2At46
d|ULB+:\3>:Ym	Ukd6u|>{6nYks\FvXXEu($!
R>!,L wttQM&t4OF?,Aza=.VT("*;PM59)+B_;XG2rqxuz:k"q'eU`KahN7X&KpA4OAcaYe:^~C":+:6	t(dS5Z42:CcV;hM{q~|k?v5cq"=xG\sa:h,w"iD;h7FyjL2Y:Re2IC4K,JdP"c6'	l>Q1FUr1=k~2mD
Qu<9uK;#/Xedat "*vG`p`@a:QVee<XY2"TE&G39"p~Vz(r]{Y9Ko'_gr&2|4(9r6mU<(Y*Y
#*hSni,,SBz ddhD)|*BYXHeqeuoQY&7)^Uu|Vz	:TZ4p-sDs@mYTt2<Y`Di624J<5Q
d7aY/X!|T^R9'cr_USQc>Aq=u$@nY{[eCFFz aMM":-dw4XsPN*:haYE_RClNpv(Ag2jAHv}$}2r<}*:IuS86RVrKE@G1Q`;NADme:S+ #(m;:JQ!*A2M>A.sV9>DnT([Hsk}R+YGyyy:hb&x2BU(EM4O`:gr4D`&2F_C/&X<Pv@Grrm:gE2|Yc0'z]B:Qbsd`yku?&#qmeG9[B.E}y ,dU8h`h)&On6 %
&PyV XX CN"Nl5AfLYLrBL9STHPTrZG9n[YX9[r6yjd-LFQXAc}mT<u Mt4&h ^~D% =.hY
@)W#V)w^^G6Q~bPR9XR#dz8bkYyzTgIXAEm1v!C(pvteamLG5YU@cTTGG|gCt9DP4nH\juAP2fn4sGDf*9mj_?V 8>(,l92iD[t
p6%tUDWh0O24<u4Q0]O7m)JyR9i`IKP5Y }E.ovO"#G=?#Wi&:X&)hThUA	<AcM-JLgaadhdd::@t4
\mbi,CGik]s)092Y/EQulPqdjN9bA?J<::ttgsvAibl(4@4!F"aa4PJF&U6YZdEOwT[-1KZ.fcZ(py!,xqpTO_tt4)
Md4TCn&PzE!$tJTR&d.\A2Q2Ory~HwB?5y*l\*M)0DGG[,@JTIt4Q2/J_lrBh,!|P/DE7A5)BdZ>f,&}T$1" P-d4@IQr!&
0
,J<44`W;	Dre9y,7h|EiE7\fczrOt&j*1U 9Bh-,,LC4E@,#+	m@wtVA LQ4eeu
#&!    IENDB`                                                                                                                                                                     PNG

   IHDR  @       TF    IDATxyggy<{oRkkYl 	Bl6xKTy&w3'Na6$$V	MRo276]S.K|UsA$fd%vR9B]%NBAB)2#@Lc$L&h|xM?Ur7eDn<q!7rc&1l[PF}:Li6@i
tXCSSlOFeh((Uz ugS(`J5<uz,-a@3.3
#'I@!A9XDTs&fqC4!eKJdkjJ6mt6jQ4`[Rr"!ZvoQpfpIjP\eN:oLRc7wT	Z\kjQBr!tPP T"XXI
P6QDv6.,>n1"G#kgXgb#|X1HMJora#%OEOK)sp%CMe|tWQSu2:/u }rTP)"TQaU(Pip&1I	S##J,a!XAB	(fDfvND>0"M70	wI	1FM)dM5-(Krr0GG+*u>j<EVc[)QRj5Yrr @fUM0RE!z@A$	\"$Q0{"&O<Q294Rs"s":"+}S- 1GnE T(&SR4|1lY6w!B:WDTZe2RJpOfP
eUX"rDNHb	3e%dD&E4`(95#J]$qRp#fAc%yGzM*10Z,kTSJ,o%cUXJI#.2[s1I14x^(A^S#\kvRSs*p)(- D"LJB qbL
0A`;JJ 2IK<e<,#p-<LY}mb5 @?<c&(34-<y&<4;J4E72UuDgz6(Gk0P crL=N%T*} hRNDv(3A(FI#k"$ b"FYZ-hnOXqZ91B	Il>P\jMjh	l2P8ZE je!mQR}E*tHT8aaand03'%#ZeU$"3) $goZvOl#!9X&fXeIP7nmMbRZ2lLi)m{Ft'6)&r"M-[Iy/N&mgE 4JiQC(kDBLEFP]-*43YQ"b!S$,``$k8$%3y;`iF>/+y`buK%b$-0|?g#>D<AT#+*P*dA~Pj=ScUdaxaw3^Y@3;H(	DH"2DQMa
JFuR9E&4fcuci;K] yTGd	8F&<G%"UkD68zB%	/=n51E+);,)p09$C2M$K!B"(kIricA	S3H1R'N%Zmih3-aI2@EMZTXlpq$*HoEhmP@Ajv3,E}0l0i%7@/L,
h"1I6	q82shdI$+Cn<-V%a[y*X%Fb9'F|TK5~J7TBM!/njR,I[Jl6T#
R	b&	)1K@LHfdIL<3:J&&9FVTK3=>]c|_i g '$ah1-3[J&&jD4C4TCAze,>		"	`82X)F)6%]/$hB16oh17j3z5r)HVLa%U"8-,4!^FpB9A&x6L1b6BXC&e4JSvOAR3o0KH7CC -$k/QV@u%-\C({J^:H7D	1h9!mP#j"IBKX5<F;:kizgZf08Mif@bQh*C7;%u4<AFhzs{0D\s($V!x"mK4;0b&QTIqT	mM	C42Ja'#i0@(TFUsfnd%5(Jk8N QVh9&igZk8[#@Q%R IDj["]Nx9VKdWsr+S!30TE"\2.8-9X,H@D98(4@1 U5GMpFt';duK:
{!pjxCa=ji(:<d5nN=dg$M%qgb0A$ sk$)`l#JZrT6kTM")yicd2NmECy
Nz"H*Th=G2.y"ajFaN;,AhM""P$D%VCqdni-MIv[_nMS^b81sS4s9B[k R#.y]+aZ5nl:tK8= 0MHPND HgvP$$Fj]y<QpeJiba{bdy=pcZY	(0>@p&5>$0nil9$@ydp%PHcHlL9E
r$%n",$rE*R;0,h4$2@6;T`1[#H:+^+,Sebn9q /`B#`131E,RIsPH)xMZ3+2oiz$Ik[=:O+Z5#T!"Ka,4$.^"L{lZ V5@h;xrhAH!-[qCh$37&yrC'.DIy8w&T+s	IE}O=O"xONwE4A;
:]2}P(VJp
Wl(FftKKj(%0dJGF.gSxdLOY'M+_uS-Qoj<wJ>((P hV+!%UJh[qGFE8j*kw&1S!)2iv$({}d+?YxK<Y}_9u?g8w ijLE(z0.BS-J> jSSTLc0	zNXhA(I8Q$yN%#	GZ'[=ik;NMb8[xgWB{_b@yCf`vBR4CM!5cUQ@au^7q	:$2J<JH|h'_3gWWpjPgwRijz}6:'9PqfiDyN~R{m`|+UkG	*1A'D"F)vKsolGp?i7mR_}[O&1`}4~{}i#_|zd:i^ul^2\'pK4Wpj%jU@'pGOobd!ODIna/)I$\F>K_=:jPG~iUMllfI>7cj75QaMO+>,z57OP(z`RY - 7f Fhi!aD)bQkGHHM$yx^4A-Ii<>WjTYe<}l#) 
F8'6) 'HDZYjpI:"p(CPHn5tk(X7YDSf?vp023R<)oE |M?c8"nzv G[[P3n9z:94K#km!6K  5T@)!t; 'wr4s@b<ainQ=@+gLI=@q{<&ae/W:l#?@%J;ngc ;=enW916<2T
%J4fVds0hBc uDn3E:pzD4q;1k/[?uOGD </^~=~ck"_}|/s+yslQG*[5O5fD;HC{Pp%LDCbA0: urmn	'JK]vkWva}eK@	$ytOKF;o/}nLg}q[vM|wAYbC)UVs1p
ZQT(U^[63l?oO~oiFV)~zs<tsnt<g_~zy.`7y(_c7j%o;8Mf;YlZ\k<YPmqSuJ*!
/jhyq,)om#Ig
_/3OtiW |YSxBKm?MNG>u>%M_W~(.}SW\tWwa_Onx k
NM%*f{G!>/VR~5m/-vg [8H{+|=]x9od
wt;o@y@|xmk
}gsVuGIpT+CP``Y0[6Fmcv;j9x?dAv%mitKst]s&cUXLu=G?]?<W}]n;6}=_[r/c0^`wa}Te!f+y*fP{jV6W-$/10en}u4=Cv~o9W,7>D<fsvO^<Gw|W|t'6>K*_u?_w9s"OsxUaC pu
6 zIF2y k1#mktE;mvq=/hyh5%[O#w=4jf}	>\V}%_>gN}?aK\>}!=tx5_?sfn3itTU#884KE@p3CuVrlk=v^jJ;&ku9M}iOG7O.v5}S~O\<?y#6	^+-_\Ym|<	D>jbf%2Gc1wF*0+TK4-$\cn{VyWVw\C/~=9|ftN>~[kz3>Y?p+:G|yS|E?5@mYWL:*JTQ^uHfj)NV\-
m%b#%
HX:}dyV=wiwo3eq#`kgu+n#*?r~gw|'lrz<vt55\Wvk~a%DZYaH>@48yBa 7F'ntG	8(nn}8g.}/{x=!6|qB\}i97A\z6*9e9x}Th>;}=5gl{{6'b5hHN]TP3z
>ya*QDE	Z\AoPZuHiSyc{O<IL|;t{ruY:?x^SPg0"aCH6T7s(T|pDEkxAzAZ;#0V)-dc=l=[K]T
nkn Av ?7g Yo}6{AizT35cDzMilXIu),>K{.]$_rz3 IIxK^}w_]R"<B{^=8UxTvvv<OjfMub,	Kj\L:uD^`RbdQPeUsXe	7]Zw5Vb; /AR6IIl=ti2}mL|)54-Sydk vx~EEkqNVHzA<wp#oP "g@=o&$anak
YDrg>aWH:bXw]gy5?_3~+Jw~(JU]+<r+2K
    IDATyc3VfXF8H?t|+wF,"<Ct@3>#w_g/~~;o~7*-5`1QX`O^C!*{PxfZHWvpI!sJ{O#*MxQfxsc=g=V,4Nk+5iA}I{S*4J7t2B93g/d%2rFc|+7#=ui5o;{KX,_O'_1]3Sj\3J(P5$EBEg6<}$fp}+cDa<[#s.e`e[/^SsI8q4Z x$e[7JjwpV4doGx>~h}>);4jRyj=AwLa?h"qyWHJhBJ}K9y`,w-EV-Yr|OoYf_M!3O$aKsY3PJ#=BE]kTJd;nm28E!Kd>I,<l^"`ApJ8?K4Sn|blAd2d+/yah`-A:EQbN-0;vJ{Zp$wd;s`tv{c 8"7q~:!3?|;}&6:dlV#At0;k[o/)j#^^+s(zp8V;G+BlAF=f~ 1WOb/v
yZb-w#OSMo;_7C^+W>s>_sO^tx!:2%*P>8U#.s ,zuNln(3[?9;Sc )
^}/o'Oz8W>
jV.u_~}etgm..~o?w6})r~?
]HjIWBZeNc%E4\3gqy>M|s^;ogZ%r-7|Cx-'~>sToiw@g?w<KaL<H[jxZ+NZeeSOO/<}mx4|SXdz]>|~'Ooq/]w>f snG^3gaB.)~nf+F5s Yl;rvV-'pP:^4k+W=9<<-i:oM|U{u:=@s1:'W?yk <%dKeda9>?|V~'{^yTR4b#Jw;G WmD'I34-]vF<8|qd~{r+fw	/}Fo-7>'y'rw_
zOl?>y/;q|h{[*P5j5(&kNkRh8m	$r?P9?KwNf~wz+G_qqoz[}z_'y &U=arOMg]p)fr| / ,5)ZTW%*I%<H'n{zu}g{Sw?|vOO&_A6?yZ?>/ ?~nG>8&tKJgpk/ORP=ALj,V1P%TaXo	;#f3ToSI]Goxdq<oSg^|[~G,.dw_ Ggflz79UO_/cGyMw3xWo/!z5aO^jMLuRe>pjL(OvS~f{cm'#v~/w_h/um~C}|i|\`~;^~^M>~+kg?;f(\QM8z]4\z*ihfJ1w!C8m8X~u}[d[/~v?yhN}x\y|SO:?_G9\|%6>P(*^IUASU!0p:xGKAr'v_<K~x(^2_/;O=O}3X&v0-C]q#XZldzmWc-/baj=7qsFwIkY+w'5au'cI=^hve~,=}Lo=?`v&NkV.]K,ONmucAhWN\7{~2@5k7Fs GU)
n$W29bK_e2])-5=46E]nvV~&)76AfK"!K ~5US$
fv7?NythF^ 	D/8$q|dwS\dSc@ )6SHQ~}rgZ0a.8N`=+	\	&dgT~*R"pUX@i"rFk5CD4u4@BBDJ8:SuD)J5.o!#DBL0={*@T$D2$Yl^WLPe<B>1WG9q=g=(ikzEEPZ#nY1+w(#136st>mHq&:Ig4n`"/boj22|9-c%AB`|>p=u6.ph"pihJH8S _8%FhG&9D4b_%wqoVf|Wq=&Cy$D2orsJY26LX9N[{
TUQeH"jJ2De_99Nq2Jq`Z:b"
B*
So~W]}:GY_>I$T4S'MVSRN\cTbgw(&E3{tqm1jwv1Q|I_R3m?avi\h_;6c2sCg uo98xs(X.a1E*P3,6"deXih$FxOIsoI?cA-SRwl<2G3s#``m$ynUC%9*=)+R.*aPv(@Eu:Cecv~?zpm<+sAg31x_ b:p"IM)/Qz 38@aV @@3
]SZbP?XT,u<n!($N)5(3"SG]Z$uKO
{R|"'jvuz @FE9kg^ y=sD	 EZM  EK%0Dd\!jm&&O8@:K:xs#O!GdqcDQ0xc=iHeUCN+R%(DZ0;YiRp'(6w"NT->W,V$K5%8 N[s&52b J6}WL)K/J=OF*}_5LI4K5~DXCP&?jdUf7AjBBg:BFw{J6Bv,Ha*5TB0>41,L3\Ce?-@cOZ"Ei_]L ?M`y}t8Ou'{]}YDy2f<pN&dqV^AXFRHsf6i>])GG=c]WG}{.M~xE#QG{i/P2>[r/{9,b#]x$
b\qn9B,,{Cx<;QCP,QbK6wZ}NHF]m[s6{EXig6>'/;ooa6<3<;C_y73ye7&7>ks`(shOe.8*!X(=jl JvyzA5ecGs.l0GS_m{`XvK?U+geP}:+y?/xI=1;	NjPlv^qpz,5C@jUIU{LhFkyU:q5=-ktk5NSMwb//V\\ Ew-/_z< LzLr\(!jN>aBlPFxfKV-S2s]#WH-l82[wml@<Vc}Gg_pWoc#(] <~kpSY8<TRq<L!Bj$TEx36eln(&V'},68/8[m;Tl_S'WK]njo~(M~	>c9b.sAeT7=Ip<BcQ^26LqxF=jZ8?UZUE_w*Ss}nK/Y58:V^SZv ?[^XcoG}oO/-5\BUG9qAm9	
l48a'vJ|P%r?c} Jfk{9:evwu4_|a MN]xma6 ?mkJL-y^7}O_
ypS]g-<;xlP#Pd@IC/*niX1vqV]S:Kc^vZ}?Sn:x6 yytI=|<Irl]:{x`!QG=j4C9SCe`mpP6WUSPo;)=-M\yUmp	g/]]L;/w=4qcwy%~$I 2+5AgZ 
mR#0cm	ON74=%*MKHLp0uy~ I^,n8S@wKc'59l}	v/lLy;~I_w_=57]}=~EcraYgrU\PG!,pC1z0%ebYF#(&\Sl "A qxv4U.U.4c.	t7LXwF7&mzc
]#U-"&;r. Y:x%N2O\#WBU~|H{u:H1 C7>ydH{Dew\&(57 RyR~-8J((1j0X5>
['^XX(`r/JlcZ&"&-1DqAs=NvBiAISOa
VP>:>}ww )!"Na9t-0B&R>r2 g?FiO*N*D+VBQJQ*zLBQL.P&ez9GG
:Jp^!4&+xuB"X	58 n8hp?UZ8CTIW3PZE\r%}kDl*b'R%M/?>f:}X/dQJp6 g8
}H2)$R94BI(L+8STX7On|v.oKsQJE.2(xvre6'9Tcv$RwYfk]76Q!7E}h[JJrBow#.dBV.G)
LVA*GR.8b:y/<s`JUJ:B=S^4=2,:H97-nQz1(s.O*;BoSVWt< @68pJ[sk}j@Q*	HVDnVqc
hDHDi1s}S\57-E>V	9tO>EV`26
9`W8 grxQbJ4R9>H@HSpW QD#_(D!jqM+8"&JRIE%K1~pL|8
('T	Js!#g\0J(pD:aEB-Wgw0 R RBp+ 0BRkq?a%e    IDAT$I+5T2#@]qqY|>b*6fW9'yHJml[tK92 @Q3'L5,50'l`8InZGE @4 wy@.z xCp{+Y}`/Q)  })z-Gl*toih={qo\?[ltL4rpmYjZ"t0ujI it{}5KC- a'
,V.HUA8=	H0~h 6ZNMSP4.i]{nBe7(Yx7W5,\v`{5_y?O/</+b3??:_yo8v1GJ||NqW$N{**XAW#mCS
g>Duie^uuR~5QH\t]~j`Ok+=eW}`]gm?s8vQmcS=waZ>qyPN|W%9r[rUP
}Q+T66Of0{J}mAyOT\1soXw7>>R~g;h|Z;yl,s	EU3WBpy{fd.)c{U2c~\yGj[NJhrUcLiqcCLzhoMxR@7>j=6f7=%2;3>u~vwbX:8]09q<,U=F'k*6T1Kzwl164-n^cKvzE9:.vu{oJ@]xf=7/nOyh}][GUw`ecI] "F*+ByedJ0~\6~L.ic6l;jSi`C6nD6^MOpeFE4/d7+)8V]=vM8?xZ<tpe{Nt.W*,0S -[bfT"XUK~iUR.;7[WxT},8@XTT4k:sj o oM+pOm_uv/vRqt>j[rA2"+^jC` pn(`1HDDR0%%%mbm.TjxcVy56WoV_qj`O%hP$ m{[jyouy3Mrg\v+MVL6%f
y6xM
V\90NP">BDS4;iO}oQo)Uk/k?=3GO$Z6~9pw/_	EdO/0={oAOOI/	-cbX,	UF/'(-;"wmo;(f6;W^qQ^ywS(ng3ldCu_3 >^y]hqks*]~&++,bP7Q dUC-}#y!q&R (O3W)%}MkoIW~LCwF~;.g0m!s;Z.=7o1}]h.yq=IL:2JNU=r@a8OA]/%DY/3Q5-qoE 76_
zQ,>P7o*&|_N?51QQ=?wq_v1pTk0:T!*98\D S&KtTT:%>%6R@lb
B$K^~%yW1;FFJ1T48d$tNFn
xH{>8^/q`&!c@y:P9Q%j\u$.2+8yq:c{i'6=d |7gXD&daBNKudXWb>T*Ly	2B@S-
TQBaGw|P*HD*5Ds{({y!lJ>sG4(F.8O
):F6i(g"k8:	P:u1rQ\,"N;alp.|PJ)"O*NYLaFU~R0#tO(Zu;.T;l^fo4+[t+.8,3P3"Px|{FuaVE18[Ucv7'
S\{KbUi#&[{\&".'c)z(P!.9@	q{ZWV$E$'=|n!]p2\[i}?R}<y*O-dr3GCnD%p!8
~8zYci6T4u4T10\9IHEJ$=Ifi66[\p%ZZy`&K\cqv
l+xLQz(b"Q\?r,h"JtyS&2Ju]SH$RQbDTU3b	QnY;i]Uik.a<hA|xrx#v!z(1V$T?vK0BIEK8RVT^rz*'EZ+hC6!2JHJQ0O]q},&Kj>x|?XpI\+)!wu3N'G`}(sr71PfcM7hU)-Vz<"am3,)PTd_l(RR	}0QJ:nU
U`2Y%:@.NrdL[ X%NFp9ysle_W\8p5^|{W3[iq:{uGO=7^')(L07ZHH),\C|d2	<Z<DFIpbd'z
$yXM	Rn[;3v/KN=MYS|^2`-g&R0aU'p:c<879Q$8=P 	C<Y=}<F(ZYb!vQq9[t]m{'Rg<*&PPq:Y*.|`6&kcM,o2dN0NfB3$|"y	AF
<:P.@<L/)qyBG'Sm;gn/SV^|+;KXr!h6t_13;M!}0GAnY	.,x`.&>CEXn\P3xe|V&Y@9P3{(_VQ?9ry*i)pI+MJwuSXtf=T|ge0G8Etcu8Lcna8Xm\IEmpAmj1T
$8&'#x{K:;}T	zW,r8XqIxvw&tYbH|gJ8{juxh Ni>s9c:]Y?mTO-e</3QN9AZ
l`66[Y3gZV,t{}yT*xR<x.tC~VgI|	Cm#17`l_/l2pW^{0L#^+gZ[.3l('$$tOY<SU3h\-8qhaB~3LYTntT=,T>okx7;n/+aJfmWYpaFjd\gl6i{7yvzTx2 Lbbsuws_dFs]9v.\tu?0:z0Zr,D}uxkLW}.zt,G+	|oHo&xs{3	^flu7_4)Iu*l.<d,5qvN<|yD0[RGF
Ew\4KjKt:3mwOqcZ\x4}xmb5ZX'pv^lW|9[a
f?4UBFoI!(a99r]NAUDkqqY=:FDnxbk;7Ktc7Wy_lQcg1c\sf::?(dy+|%bD,Q&G(,#)+B
P/Yl;8J
fLa-d#wN;u`?Ol;gw~|lces98>me5^jg!z:L"W5M.*9a<2'/	"PvK!<<\H !S7;]Do.OJM'MMTUs?y]9VZ4vn)Kv]m57v\]6)p>&\7F{;@wfU0W}p*#%A&8v^yXa3D:Tr{h(#J&"3	Taa8 B
@<cn%Uc16`*GT<L/;K/W1aTbpygX8,R<\V@F q]62ZPCi_
?
85Q3kQf/+}OBZX7`#P`*_C? t+0\Y8
9GUg1V;aAKIPIpq">i[5=0BdgPnmi}G8pTF [0LP db(eT\P"Fw>
: R3P)'*az 
hmIA^S2"HRw3:ZB;Dz01g(!5L!sdygIU{TLx(%@
Ju}j=&ugAS(g|BF)g=J'at81B@D''{t^!rTXt|(4z{|gfVLp&v@/g"TLeQ<G1YAUl&Up!c2A=*CQpRJk(PcQbtzZ%oZ&W1K3v-};B5rl\-)/a%/!H&*Ja|4NbraxDPJ2]bUERh@o-fIqdU]uer1SO`R[V ,OD!0UA\W:I1XPq!2be	sVcPPQZ'K:,Y4*(qZ6aMq;~n..\}>fO83Y-YrLYB]0`UEP<F85>bX7vl
If[MM0!!Jq{JXQIJ"	".vHscsSf|C2<3_&TsXjuj+k5H=e d)/2FjjCQsN]T0sV2 Sc_;o#/E"4d#~u<BHy-FL*4{*m$>fHLVUSe]O\:e{o:##sr WyPeTF9/YWn(NSbw`S^~`}bSCj;_=;TL"1x1cD"UTiA7O}
.!3(se93w,ur8A"X5tjz|C}4}U3RyTN1}%G~q{Gp~N#'t\/Y(" /}WZA	O\	DQQq0Y\TRSuxr#gu-Y(@kF6<mUB[}Q3M|QlO|yiq4+?9PUcX| o&<c$1EZQT^#&9
\ rU<xBsg/4LgT`OSCj,9}p 3-qxs%q8MGGl1-Ou~7>K<Kq%0eQPNe)?warid.'X=`Uk*pW[#tb%5:/G^RmGcFmnn\tl_:4o~iw.ycj} n/KsJLcnk&}f;WcrpuWd} i['T90AbE$?7Lm&DVP(:iPnh_{]Z}c\|@md_WLyd=x77,T7qCc/OLsv=2]5!UZPu+%xfgM-!Gb~4HNS-=PMzN5|`)yWHC5]y?|qOUdlL>^+<y7n _9r]	?):qt%h*#|V9	skZ;y]kACi]+"n*juLCC>jdVk{K    IDATT2qv8!3E 6t/Z<}]&*I*U`tLxLgO9y4L=y/T?vn;__k%/yyO|n__+|)>\rU?5 ~/}O}7UxsfsrA@xlqp9 #T)3\e'?G]>yO>8]?ayW'|nxG_[o3~O~#Oeyz<+k_~^oxvd~-53w3gb5_8_ }rR./z||yO3woYq?O2|vyS>qm=WoCCr+S_x{gE$utdpZC/nQ3~tn.,G !#o|8o_O?}w,;nHz7?;o_T;7~\}_m?|W- g~1dv~=,8Dr-c}SrFd^q)yO%SU_'*V]}~;(kxz-G~] >o_w_>|{_go<oa8#=#&H{s
G^Yc6V/w^|H$R\yJV^q%Kv-?.C|'w?~Wxcx^}~x<z]UzH+32yKyu{CRJ=3c]^{3

Duqh/x#?lP.^C?<-x|>^oC{{[?K/o3Kx(FD/_cc2fAf`[yy+\.wW_iv+8'\_*~=Q>+iwG`m? G_rx{._#0~=?O}''f=H5U1.cwyOp{e*Cq~K#%?|^#X^U}D"!r|wp\nLh{"/[YX^o3/w3'nsRrfLIakZ6Dm/M^};.%I,sB)/{7=7?<(lvF~3yK^mf\js$P<kdUeT{EzS,Lp|S/xKR([>~acf;H#SuxV]A$,fms^pp2E5#4^gh*m,amD{t^3TbE_Y51HKTstO
j._c_}o^%l-aO/mx&q6}a1M,iy%vD	>(&1|O#W"SPxa4]ne'ryW(vYq_o8~>/n|_?qrw/Lmpl7F
n)YB3Z<;
5ZSWj8o]Gk}:|g~~{w}cWt}w-xd^BnbxVK`xL| k[`bb&r`[#(V5.8<R<:T>	Q| KLu\SbFHU"ge"	H^,TIBWf$%GX8e$u6e}<soo?;o/7.^_rkt+i6>gUEm!Gf?hISp)(ZufkP`lQjE:W.Er^*m#._ 3$rf7*O3,=+},Fez\K$dpRM[fYG/HFf$"qc[X.fpO/?m?!X:+vJ{S1Q,[9e%:`
W7UUM";.#MU.+Zziuy@U[b39a+z}P0)IdLtSz!fXK^1Q-R-F_yF')6GH['CmH0C}rg3r $NR%i\TPJYVzn8nznR6QJXpn7x(N>+WkxVTjVs,Fm``a76"EUkFh+DrqXlE_u	vl)x9~q
>QHx@c
nHS&39flD8N( -M"1Ea!>TG5u4d<>Wb=vL{e9)yl'/{H>#u:#bSR)j
.\4!xm`KR]01bCjCp[6dYSwF*cVF!YbV8!{iIQk1f,-J7s53#c^K.vq8Fr9g}#wnr$3l:k"f`dk}qX-9
F4@En@WmJXbu/s9\3U,x=<I"1G4~
c/Gg,g~OZiuU DZ	V4]MR C)*yg3/8RzssS>N9eDD$3fEbw	FF:"fHF\\dgB(xbem%h24VcfyHI}3^YX`Is]"&10g*&+*)3g'RbzRj@fS\4[Y",.b1o`MZX#f&I|[tC,dujFAO $wchV:KYX0:
me\HPe3!l\~B^WTS<GXGFL1bLt^^,rr{* 3ybLnT[w)iP%b RFQ.bt]\Z)6E7
l}Ud;~ bL 5FVNTJBck~w'VuRb.f",lePa\k5)UF"r1*tq~a!7+9,AWVD9<IV
IR>$]`Bjj*UpG;%o}UUwxyKn9$v3#5fR3Y92a+@egd-D?OjBEceWH0Ai^k	agvt[lvc-qO0U>{geDLGwV1%2RGfIeBZ7QY\"^N;K1Ev-%2L
)eF#1E-n =}O.gFx1fD`H==QYA88;p&DUB+1*n+7B;mMZri%UB+y"qu:4[u6.+Y`^M7'7+P#+#\^RQJwDUI=*7~"%&Lh2^)4-!ZYx}X9ekEX%9l.iszq,fLapUHTtNJD`CDeo_YJVRZ+k(eZhD.a4p\u.H;Nq JZ]3 p3)]j`/.5AJj:s)P 'sN
gWEYb"3&C)ZQXTPeZB-ja6?M]S(5de	Y?gGZb s5rs,ssls[%d@hnDDgDZj&05 g4DHJQ&)).NA!"k1M&8)L4<cD>t~9`(9x "0ggVo3aI
2 V
2r}du!.z<JCPY[TAqykgL(pKy[C93RN9Y'*"c/ F` B.F$(@6	$,[ZhkDug3Q*]v3"	&jk]
Bp^-[a-S8c8``F8%gm'>5Q(xFDfVPPiiFW6MEGcZsJ
C3[\y</"x$$o86i9OT dd|Z2g;FFzIb<qL
zPlChJt=WlUSXD'lZVef=69|I!o.;fa==ATH^Q	O:jZAyhfJ"j(l)/RV
8V!4`EP@&}qrlskuZ%S*QR21
QDLwQM%*LZ6BU^ZZmM lsI	,f+.B_ Ysp3wLbv625C$<sypdNm%jXBP$2lhBLiHV1%]4X\=X;bME)$By49bTP.:F]rKbfVX{9t`3gr;B
@!XJaRBE I
DTvZ+DEajvK%].ZK-Rm$F<preDp6TdDfFr"2+k;!jJV$P"
cf**47<p1!Nnzf]k9,[KDo?u<}tycr-B7@# g3+dwonP)Jf6wpVZBAyHJMJtIAd[M#$zq2a17'6$*6{4SrD	zLV`N 	Zy8S{*-!E	`)(4ZiSv%
T%$\yPl)E7PM
DzRcYAxL
cY;#zH(ITp g2k;Pr%U+UEAcZRU! KJ;`.m1a?Lj]5#`jN-iqEDN^K^f|)+Niy(s"B3CY <<#PMfC*AyxPdISR@-JKH($^LT0Jk5J.cdqK5m?hh.+kC
sWleu9+s^YqbqwNnUfD#IOO'AO=|VN$~E(jBQVZDC)`yCEDTYRm5/N-]Wgz~E7hj#&<gc:czs_ =U0@QcBN~R ,@M P#!h@ zeijy(FBjR59\EF/ d_F
nIc475e=g=#"D9AxdE ;!T4j/gVE.^&Ch E,*C*IAlP,Pr\Vg,uHI3B&AaOMnneSx&IdJ,8f8Y@VW8tTEtxd@%ip5j/$TF:0+mX.E\X_f;v=3Lzzc-n}z'n ]<*%2vU#egyHUBzpTR((P1#!2DB***UkPT%]A[\y60%O
-CK5JG+%zr_8b^6C^8M]Ea+?5)Q^9$3XQqr4R ((,LTjR"AU<$JHD%EU uUfRUe4@eGf	%
Pr/P<^0<uFUfUrA5&vE9cy%#tf&tb$k,sdUoES#F8JTF`iPh(CeT2}9hU&k?goycR!/~pp~s[6er<mr.|F~p4{gB'I2;=QRgL YC>oJH5GT`|TD	*RS!R~hv(%Kj5r-7MgwBHvYc Av7e^tEX-vx9vQYC2TA{$Cgap"%3f
Up|*JB
Y{a*U`LluDhj.B{Emm:6+x93^ NCm@>8t,2Tt>mnh9*h7t<  IDATk&9WV%4ls ;<33
YgdDHLHB22)hHmY"b)(8H)c)S*TB^zKrva(U'9teJuC!Gmvq?8t6T	#}HY}m{"g#s1#"7
e`U`8*`1&,xOXRPDBHZe
7VJE<.
MVQ(hcR9h14r}:x{/Sp(|SD8m7J+dI7m.yQ%<4oM("\Q9c29j
e;GdU8#YUR	n5LieK*Je	BD,#()31IdZwH]_"^SKHDShiuYc8F#U0Y^Yr3y/bSCe}W?KKFV)hEbD%fMB2Ab"29
~} E$2!MKe%J:T=^9BWf.%K;DqXSz {kXKBvy/wzb	Kr/jM*D3m}1\GH10U{#2\PY,IFx1*1XrN~]Rh$ M(+$=YJ4.dchiB*:sf33]'e+-fF|jc;1c FCryH<ViL,;9dc6wtDVjs]33f
@3Y^Q,x4)PB)A)QRMaRz6)prtaq'WrtVp }S^v2]&.K?GGX^yszn	>q&;.<JKn:U[be5#PN9 DT9J:*vDEJBPZ"HJVjkh5"\*5L*L6)Z%;Gb(6][/V#ohv*;C$6a=F>;4HFzDVTd|&
N	d%"W%Fd~Eoe"EPIJ"[ADLXtN"kjy	G^Kk$"X O}~y%1vcG9kYI9dxk=O.[\asNkKR-p5P9,PgDgPU
2`e URTaXA,jP({.Nf:C*D2)M&9|b$5rFon_ gLme#2xc.EckmkR08\2d=pRGIgC>g$xYD &Re%_eWEpY4"3[e{%?v9.eBHG] YOC/zx>>9y;/2x,9_|v
^\C|~{u`H&}"NW|pFkp-Y}n.U!Fh:QL3vB5Dz1O`np2z`/?g<ig>+?P|nyu??#|ze<;u;}F'6bS']nSCK]} }ByEVdA1F3i)GLuNk2N"Y@ yElO R'}P]DO\p|:9/%}cx^U^qB5ZbnG'n5vlCqda8jTm&1 AD%2H$eK*JC++SP J9rrFFdp;>onZL)^_|uR=ru{i^t{UK)]>FZMF9TPwj?2xPLSRC
9SDd~S85SH<>x?TFNc8izDw$bR?AG>#G7i#b[%vVGC-4=9i2U  S41608W"d8sn~<"4R1r,dW~\*|W<fzgv{l=o*C~slPgD1&w7K6f{f:j6Z6-E8A@H
##4vk#"vx405,uB>}u)<Bq>G|J_5F_V7U#u{7}2V(luVv98>ydl$e[8Z(!H"4Q	Qk4U J$adycDs^2FG_]Dy7{dD?{Z3w{4cBa#}B?Kmsn2e.5,/5nAi    IENDB`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               PNG

   IHDR        8    IDATx 4}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ~0    IDAT                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         	!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           	                                                                                                                                                                                                                                                                                                                                                                                         N                                         IDAT                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               	 	                                                                                                                                                                                                                                                                                                                                                                                                %$                                                                                                                                                                                                                                                                                                                                                                                            $                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  E                                                                                                                                                                                                                                                                                                                                                                                       	                                                                                                                                                                                                                                                                                                                                                		                                                                                                                                                                                                                                                                                                                                              (                                                                                                                                                                                  	      	                                                                                                                                                                                                                                                                                                                                                     	

                                                                                                                                                                                                

                                                                                                                                                 
 A                                                                                                                        
                                                                                                                                                                                                                             1    IDAT 9   
                                                                                                                                                                                                                                                                                                                                  	
		                                                                                                                                                                                                                                                                                                                   	      
                                             